#    Copyright (C) 2015-2021 by Kevin D. Woerner
# 2021-04-15 kdw  indent work
# 2021-04-11 kdw  indent work
# 2021-04-07 kdw  long lines update II
# 2021-03-27 kdw  long lines update
# 2021-03-25 kdw  mnor reformat
# 2021-02-05 kdw  wikipedia refs; test lines
# 2021-02-04 kdw  add spaces to test lines
# 2020-12-03 kdw  float explicit const work
# 2020-11-28 kdw  macro syntax overhaul
# 2020-11-23 kdw  replace 1.0E0 with 1.0
# 2020-08-17 kdw  macro syntax changed
# 2020-07-27 kdw  block syntax
# 2020-07-24 kdw  comment cleanup
# 2020-07-20 kdw  erf__3 tweak
# 2020-07-16 kdw  erf_[_]4 work
# 2020-07-15 kdw  erf__[34] work
# 2020-07-10 kdw  polynomial refactor
# 2020-07-01 kdw  tests modified
# 2020-06-30 kdw  tests changed
# 2020-06-16 kdw  comments changed
# 2020-06-09 kdw  comments changed
# 2020-06-06 kdw  comments added
# 2020-05-13 kdw  comment trivially changed
# 2020-05-11 kdw  block added
# 2020-05-06 kdw  rmed boolean vars
# 2020-04-26 kdw  block indentation
# 2020-04-12 kdw  comment change
# 2020-04-08 kdw  preprocess sigil change
# 2020-04-05 kdw  py: lf_ca[l]erf work
# 2020-04-02 kdw  erf rework
# 2020-03-25 kdw  tests
# 2020-03-09 kdw  LO[C]AL_.* keywords
# 2020-03-05 kdw  s/TRU[E]VAL/TR[U]E/; s/FALS[E]VAL/FA[L]SE/
# 2020-03-03 kdw  comment change
# 2020-03-01 kdw  .*_NE[X]T deprecated, et al.
# 2020-02-28 kdw  poly eval work
# 2020-02-26 kdw  arr[a]y and hor[n]er work
# 2020-02-15 kdw  array comment change
# 2019-12-26 kdw  module name addded to funcs
# 2019-11-17 kdw  include Macros file
# 2019-10-04 kdw  comment change
# 2019-08-24 kdw  for and count loops have from clause
# 2019-08-18 kdw  B[O]OL to B[O]L
# 2019-08-11 kdw  comment cleanup
# 2019-08-06 kdw  rmed backslashes
# 2019-07-03 kdw  rmed commented out code
# 2019-05-29 kdw  comment changed
# 2019-05-24 kdw  local replaced private
# 2019-05-22 kdw  s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-16 kdw  loop limit def mved
# 2019-05-01 kdw  consts explicit module name
# 2019-03-19 kdw  re[t]_val to re[t]valu
# 2019-03-18 kdw  macro syntax changed
# 2019-03-11 kdw  comments to array dcls
# 2019-03-08 kdw  is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  is.* funcs changed
# 2019-03-04 kdw  loop-limit work
# 2019-01-03 kdw  Await counter changed
# 2018-07-22 kdw  erf refactor
# 2018-07-21 kdw  comments
# 2018-07-19 kdw  comments; array reformat
# 2018-07-18 kdw  func renam
# 2018-07-17 kdw  private lf_.* funcs
# 2018-07-13 kdw  float number reformt
# 2018-07-11 kdw  var nam change
# 2018-05-17 kdw  ARR?AY.* and HOR[N]ER syntax
# 2018-05-16 kdw  AR?RAY syntax
# 2018-04-03 kdw  rm () from return
# 2018-03-26 kdw  macro redef
# 2018-03-12 kdw  made PP statements not need semicolon
# 2018-02-17 kdw  bounded await loops
# 2018-02-15 kdw  python debugging
# 2018-02-14 kdw  P[I] changed
# 2017-11-26 kdw  FR[O]M, B[Y] keywords; deprecate CO[U]NT
# 2017-10-24 kdw  Underscored numbers
# 2017-10-23 kdw  AR[R]AY syntax
# 2017-10-21 kdw  macros start with "at""at"
# 2017-10-20 kdw  COM[M]ENT format change
# 2017-09-20 kdw  rmed useless trailing 0s
# 2017-08-30 kdw  s/DBL_/DBL/;s/FLT_/FLT/
# 2017-04-26 kdw  keyword COM[M]ENT.*
# 2017-04-21 kdw  comment change
# 2017-04-20 kdw  func to function
# 2017-03-10 kdw  get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  sigils rmed
# 2017-02-26 kdw  var renam
# 2017-02-24 kdw  REP[L]ACE rework, et al
# 2017-02-20 kdw  array var names
# 2017-02-14 kdw  FWIP Loop syntax changed
# 2017-02-12 kdw  FWIP language change
# 2017-02-07 kdw  comment rearrangement
# 2017-01-06 kdw  ?[?]USE.* to ?[?].*_MODE; ?[?]DIGR.*
# 2016-11-23 kdw  support of I?NT deprecated
# 2016-11-21 kdw  DE?F to FU?NC
# 2016-11-20 kdw  language change
# 2016-11-18 kdw  _?_P?OD_?_
# 2016-11-14 kdw  LA[N]G stuff
# 2016-11-11 kdw  seca?nt algorithm refactor
# 2016-11-08 kdw  bound loops
# 2016-10-31 kdw  comment reorg; lang change
# 2016-09-13 kdw  lang change
# 2016-07-02 kdw  format tweak
# 2016-06-01 kdw  comment change
# 2016-05-18 kdw  comment change
# 2015-12-31 kdw  bounded (possible) infinite loops
# 2015-12-28 kdw  _?_I?F_X_?_ to _?_IF_NONE_?_
# 2015-12-25 kdw  rmed unused functions
# 2015-12-15 kdw  comment cleanup
# 2015-12-14 kdw  erf[c]xinv refactor
# 2015-12-11 kdw  s/LC_// from some consts
# 2015-11-26 kdw  long lines
# 2015-11-18 kdw  shortened comments
# 2015-11-17 kdw  tweak
# 2015-11-16 kdw  tweak
# 2015-11-13 kdw  shorten lines
# 2015-10-27 kdw  minor refactor of erf
# 2015-10-09 kdw  renamed i[n]v functions
# 2015-10-01 kdw  float equality checks to is.*
# 2015-09-30 kdw  minor refactor of e[r]f
# 2015-09-20 kdw  created

{INSERT_FILE "Macros.fwip" }

BLOCK:
   BLOCK_DEF FUNC DBL lf_calerf(DBL xx, INT jint):
      # Support function for erf funcs.
      # This routine was cannibalized from code written by Peter John Acklam
      #    (email pjacklamonline.no), and retrieved from
      #    http://cpansearch.perl.org/src/REID/Games-Go-GoPair-1.001/Erf.pm
      # Coefficients from "Rational Chebyshev Approximations for the Error
      #     Function" by W. J. Cody, Argonne National Laboratory, 1969
      DBL result;
      DBL retvalu;
      DBL absx;
      DBL numer;
      DBL denom;
      DBL rsqrpi;
      DBL rxsq;
      DBL xsq;
      INT flag;

      absx = ABS(xx);
      xsq = xx * xx;
      flag = 0;
      IF absx <= 0.46875:
         numer = (((((
                  + 1.85777706184603153E-1) * xsq
                  + 3.16112374387056560E+0) * xsq
                  + 1.13864154151050156E+2) * xsq
                  + 3.77485237685302021E+2) * xsq
                  + 3.20937758913846947E+3);
         denom = (((((
                  + 1.00000000000000000E+0) * xsq
                  + 2.36012909523441209E+1) * xsq
                  + 2.44024637934444173E+2) * xsq
                  + 1.28261652607737228E+3) * xsq
                  + 2.84423683343917062E+3);
         retvalu = xx * numer / denom;
         IF jint == 1:
            retvalu = 1.0 - retvalu;
         ELSIF jint == 2:
            retvalu = EXP(xsq) * (1.0 - retvalu);
         IF_END
         flag = 1;
      ELSIF absx <= 4.0: # for 0.46875 < abs(x) <= 4.0
         numer = (((((((((
                  + 2.15311535474403846E-8) * absx
                  + 5.64188496988670089E-1) * absx
                  + 8.88314979438837594E+0) * absx
                  + 6.61191906371416295E+1) * absx
                  + 2.98635138197400131E+2) * absx
                  + 8.81952221241769090E+2) * absx
                  + 1.71204761263407058E+3) * absx
                  + 2.05107837782607147E+3) * absx
                  + 1.23033935479799725E+3);
         denom = (((((((((
                  + 1.00000000000000000E+0) * absx
                  + 1.57449261107098347E+1) * absx
                  + 1.17693950891312499E+2) * absx
                  + 5.37181101862009858E+2) * absx
                  + 1.62138957456669019E+3) * absx
                  + 3.29079923573345963E+3) * absx
                  + 4.36261909014324716E+3) * absx
                  + 3.43936767414372164E+3) * absx
                  + 1.23033935480374942E+3);
         result = numer / denom; # now result = EXP(xsq) * erfc(absx);
      ELSE:  # for 4.0 < abs(x)
         rsqrpi = SQRT(1.0 / Kw.PI);
         IF jint <> 2 AND SQRT(LN(Kw.DBLMAX)) <= absx:
            result = 0.0;
         ELSIF jint == 2 AND 6.71E+7 <= absx:
            IF Kw.DBLMAX / 8.0 <= absx:
               result = 0.0;
            ELSE:
               result = rsqrpi / absx;
            IF_END
         ELSE:
            rxsq = 1.0 / (absx * absx);
            numer = ((((((
                     - 1.63153871373020978E+2) * rxsq
                     - 3.05326634961232344E+3) * rxsq
                     - 3.60344899949804439E+3) * rxsq
                     - 1.25781726111229246E+3) * rxsq
                     - 1.60837851487422766E+2) * rxsq
                     - 6.58749161529837803E+0);
            denom = ((((((
                     + 1.00000000000000000E+4) * rxsq
                     + 2.56852019228982242E+4) * rxsq
                     + 1.87295284992346047E+4) * rxsq
                     + 5.27905102951428412E+3) * rxsq
                     + 6.05183413124413191E+2) * rxsq
                     + 2.33520497626869185E+1);
            result = (rsqrpi + rxsq * numer / denom) / absx;
            # now result = EXP(xsq) * erfc(absx);
         IF_END
      IF_END

      #  Fix up for negative argument, erf, etc.
      IF flag == 0:
         IF jint == 2:
            IF xx < -SQRT(LN(Kw.DBLMAX)):
               retvalu = Kw.DBLMAX;
            ELSIF xx < 0.0:
               retvalu = 2.0 * EXP(xsq) - result;
            ELSE:
               retvalu = result;
            IF_END
         ELSE:
            # now result = EXP(xsq) * erfc(absx);
            result *= EXP(-xsq);
            # now result == erfc(ABS(x))
            IF jint == 0:
               # done this way to prevent round off errors
               IF 0.0 <= xx:
                  retvalu = (0.5 - result) + 0.5;
               ELSE:
                  retvalu = -((0.5 - result) + 0.5);
               IF_END
               #now result == erf(x)
            ELSIF jint == 1:
               IF xx < 0.0:
                  retvalu = 2.0 - result;
               ELSE:
                  retvalu = result;
               IF_END
               # now retvalu == erfc(x)
            ELSE:
               retvalu = 0.0;
            IF_END
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC DBL erf(DBL xx):
      # The error function: domain = R; range = (-1,1)
      #        xx  EXP(-t*t)
      # INTEGRATE ---------- dt
      #       -xx  SQRT(PI)
      # via rational polynomial approximation
      RETURN lf_calerf(xx, 0);
   FUNC_END

   FUNC DBL erfc(DBL xx):
      # One minus the error function: domain = R; range = (-1,1)
      RETURN lf_calerf(xx, 1);
   FUNC_END

   FUNC DBL erfcx(DBL xx):
      # EXP(x**2) * erfc(x)
      RETURN lf_calerf(xx, 2);
   FUNC_END
BLOCK_END

FUNC DBL erfcinv(DBL yy_orig):
   # inverse of erfc: domain = (0,2); range = R
   DBL retvalu;
   DBL xx;
   DBL yy;
   DBL xx_pr;
   DBL dx;
   DBL cc;
   DBL uu;
   INT ii;

   IF yy_orig <= 0.0:
      retvalu = Kw.DBLMAX / 2.0;
   ELSIF 2.0 <= yy_orig:
      retvalu = -(Kw.DBLMAX / 2.0);
   ELSIF Kw.iszero(yy_orig - 1.0):
      retvalu = 0.0;
   ELSE: # 0 < YY_ORIG < 1 OR 1 < YY_ORIG < 2
      IF 1.0 < yy_orig:
         yy = 2.0 - yy_orig;
      ELSE:
         yy = yy_orig;
      IF_END
      # now 0.0 < YY < 1.0
      dx = 1.0;
      xx = 0.0;
      cc = -SQRT(Kw.TAU / 8.0);
      AWAIT Kw.iseq(xx_pr, xx) COUNT ii FROM 0 TO {LOOP_LIMIT}:
         uu = cc * (erfcx(xx) - yy * EXP(xx * xx));
         dx = -uu / (1.0 + uu * xx);
         xx_pr = xx;
         xx += dx;
      AWAIT_END
      IF 1.0 < yy_orig:
         retvalu = -xx;
      ELSE:
         retvalu = xx;
      IF_END
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL erfcxinv(DBL yy):
   # inverse of erfcx
   DBL xx;
   DBL xx_pr;
   DBL dx;
   DBL cc;
   DBL ex;
   DBL df;
   DBL uu;
   INT ii;

   xx = 0.0;
   IF NOT Kw.iszero(yy - 1.0):
      dx = 1.0;
      cc = SQRT(8.0 / Kw.TAU);
      AWAIT Kw.iseq(xx_pr, xx) COUNT ii FROM 0 TO {LOOP_LIMIT}:
         ex = erfcx(xx);
         df = 2.0 * xx * ex - cc;
         uu = (ex - yy) / df;
         dx = -uu / (1.0 - uu * (xx + ex / df));
         xx_pr = xx;
         xx += dx;
      AWAIT_END
   IF_END

   RETURN xx;
FUNC_END

FUNC DBL erfinv(DBL yy):
   # inverse of erf: domain=(-1,1); range= R
   DBL retvalu;
   DBL xx;
   DBL xx_pr;
   DBL dx;
   DBL cc;
   DBL uu;
   INT ii;

   IF Kw.iszero(yy):
      retvalu = 0.0;
   ELSIF 0.5 < yy:
      retvalu = erfcinv(1.0 - yy);
   ELSIF yy < -0.5:
      retvalu = -erfcinv(1.0 + yy);
   ELSE:
      dx = 1.0;
      xx = 0.0;
      cc = SQRT(Kw.TAU / 8.0);
      AWAIT Kw.iseq(xx_pr, xx) COUNT ii FROM 0 TO {LOOP_LIMIT}:
         uu = cc * (erf(xx) - yy) * EXP(xx * xx);
         dx = -uu / (1.0 + uu * xx);
         xx_pr = xx;
         xx += dx;
      AWAIT_END
      retvalu = xx;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL erf__1(DBL xx):
   # See Wikipedia::Error_Function::Numerical_approximation
   #      ::Approximation_with_elementary_functions
   DBL tt;
   DBL ans;
   DBL ply;

   tt = (1.0 / (1.0 + (0.5 * ABS(xx))));
   ply = ((((((((((
            + 1.70872770E-1) * tt
            - 8.22152230E-1) * tt
            + 1.48851587E+0) * tt
            - 1.13520398E+0) * tt
            + 2.78868070E-1) * tt
            - 1.86288060E-1) * tt
            + 9.67841800E-2) * tt
            + 3.74091960E-1) * tt
            + 1.00002368E+0) * tt
            - 1.26551223E+0);

   ans = 1.0 - tt * EXP((-xx * xx) + ply);

   IF xx < 0.0:
      ans = -ans;
   IF_END
   RETURN ans;
FUNC_END

FUNC DBL erf__2(DBL xx):
   # See Wikipedia::Error_Function::Numerical_approximation::Polynomial
   DBL tt;
   DBL ans;
   DBL ply;

   tt = 1.0 / (1.0 + 0.3275911 * ABS(xx));
   ply = ((((((
            + 1.061405429E+0) * tt
            - 1.453152027E+0) * tt
            + 1.421413741E+0) * tt
            - 2.844967360E-1) * tt
            + 2.548295920E-1) * tt
            + 0.000000000E+0);
   ans = 1.0 - EXP(-xx * xx) * ply;

   IF xx < 0.0:
      ans = -ans;
   IF_END
   RETURN ans;
FUNC_END

FUNC DBL erf__3(DBL xx):
   #        xx  EXP(-t*t)
   # INTEGRATE  --------- dt
   #       -xx  SQRT(PI)
   # via Taylor series (for ABS(xx)<4.4) or asymptotic series
   # Range (-1, 1)  (includes endpoints due to rounding)
   DBL axx;
   DBL xxsq;
   DBL sum_curr;
   DBL factx;
   INT nn;
   DBL add_arr[80];
   INT kk;

   axx = ABS(xx);
   xxsq = xx * xx;
   IF axx < 4.4:
      factx = 1.0;
      # done this way to avoid catastrophic cancellation
      add_arr[0] = 1;
      AWAIT ABS(add_arr[nn]) < Kw.DBLEPS
               COUNT nn FROM 1 TO ARRAYLAST(add_arr[]):
         factx *= -xxsq / nn;
         add_arr[nn] = factx / (2.0 * nn + 1.0);
      AWAIT_END
      sum_curr = 0.0;
      FOR kk FROM nn TO 0 BY -1:
         sum_curr += add_arr[kk];
      FOR_END
      sum_curr *= (2.0 * xx / SQRT(Kw.PI));
   ELSE:
      # this uses an asymptotic series for erf(x)
      factx = - EXP(-xxsq) / SQRT(Kw.PI);
      sum_curr = 0.0;
      kk = Kw.round(xxsq);
      FOR nn FROM 1 TO kk - 1:
         factx *= -(2.0 * nn - 1.0) / (2.0 * xxsq);
         sum_curr += factx;
      FOR_END
      sum_curr += 1.0 - EXP(-xxsq) / SQRT(Kw.PI) / axx;
      IF xx < 0.0:
         sum_curr = - sum_curr;
      IF_END
   IF_END
   RETURN sum_curr;
FUNC_END

FUNC DBL erf__4(DBL xx):
   #        xx  EXP(-t*t)
   # INTEGRATE  --------- dt
   #       -xx  SQRT(PI)
   # via Taylor series (for ABS(xx)<4.4) or asymptotic series
   #    Range (-1, 1)  (includes endpoints due to rounding)
   DBL xxsq;
   DBL axx;
   DBL sum_prev;
   DBL sum_curr;
   INT nn;
   INT kk;
   INT twonnpone;
   DBL factx;
   DBL factz;
   DBL twoxxsq;
   DBL term;
   DBL denom;

   axx = ABS(xx);
   xxsq = xx * xx;
   twoxxsq = 2.0 * xxsq;
   sum_curr = 0.0;
   IF axx < 4.4:
      factz = (2.0 * xx / SQRT(Kw.PI));
      factx = factz;
      # adjacent terms combined to avoid cancellation
      AWAIT Kw.iseq(sum_prev, sum_curr) COUNT nn FROM 3 BY 2:
         twonnpone = 2 * nn + 1;
         factx *= xxsq * xxsq / ((nn - 1.0) * nn);
         denom = 4.0 * nn * nn - 1.0;
         term = factx * (twonnpone * (nn - xxsq) + twoxxsq) / denom;
         sum_prev = sum_curr;
         sum_curr += term;
      AWAIT_END
      sum_curr += (1.0 - xxsq / 3.0) * factz;
   ELSE:
      # this uses an asymptotic series for erf(x)
      factx = - EXP(-xxsq) / (xx * SQRT(Kw.PI));
      # adjacent terms combined to avoid cancellation
      kk = Kw.round(xxsq);
      FOR nn FROM 1 TO kk - 5 BY 2:
         factx *= nn * (nn + 1.0) / (twoxxsq * twoxxsq);
         term = factx * (1.0 - (2.0 * nn + 1.0) / twoxxsq);
         sum_prev = sum_curr;
         sum_curr += term;
         IF Kw.iseq(sum_prev, sum_curr):
            FOR_EXIT;
         IF_END
      FOR_END
      sum_curr += 1.0 - EXP(-xxsq) / SQRT(Kw.PI) / axx;
      IF xx < 0.0:
         sum_curr = -sum_curr;
      IF_END
   IF_END
   RETURN sum_curr;
FUNC_END

#TEST: erfinv(erf(0.23)) == 0.23;
#TEST: erfc(0.5)   == 0.4795001221869534623172533461080354712636;
#TEST: erf(0.5)    == 0.5204998778130465376827466538919645287363;
#TEST: erf__3(0.5) == 0.5204998778130465376827466538919645287363;
#TEST: erf__4(0.5) == 0.5204998778130465376827466538919645287363;
#TEST: erf(1)      == 0.8427007929497148693412206350826092592961;
#TEST: erf__3(1)   == 0.8427007929497148693412206350826092592961;
#TEST: erf__4(1)   == 0.8427007929497148693412206350826092592961;
#TEST: erfc(1.5)   == 0.0338948535246892729330237383540521413186;
#TEST: erf(1.5)    == 0.9661051464753107270669762616459478586814;
#TEST: erf__3(1.5) == 0.9661051464753107270669762616459478586814;
#TEST: erf__4(1.5) == 0.9661051464753107270669762616459478586814;
#TEST: erf(5.0)    == 0.9999999999984625402055719651498116565146;
#TEST: erf__4(5.0) == 0.9999999999984625402055719651498116565146;
#TEST: erf__3(5.0) == 0.9999999999984625402055719651498116565146;

#    Copyright (C) 2015-2021 by Kevin D. Woerner
# 2021-04-20 kdw  var name change (mainly mm)
# 2021-04-15 kdw  indent work
# 2021-04-09 kdw  indent work
# 2021-04-08 kdw  comment changes
# 2021-03-28 kdw  upped line length work
# 2021-03-15 kdw  lx_.* const names
# 2021-03-13 kdw  line len upped to 77
# 2021-02-05 kdw  wikipedia refs
# 2021-02-04 kdw  add spaces to test lines
# 2021-02-01 kdw  bool syntax debugging
# 2020-12-08 kdw  explicit modules on constants
# 2020-12-04 kdw  float explicit const work
# 2020-11-28 kdw  macro syntax overhaul
# 2020-11-23 kdw  replace 1.0E0 with 1.0
# 2020-09-22 kdw  blackbody func renam
# 2020-09-20 kdw  blackbody dist work
# 2020-08-24 kdw  var renam
# 2020-08-20 kdw  boolean checks changed
# 2020-08-19 kdw  comment change
# 2020-08-17 kdw  macro syntax changed
# 2020-07-27 kdw  block syntax
# 2020-07-24 kdw  s/LO[C]AL_/BL[O]CK_/
# 2020-07-14 kdw  s/px/pbrx/g
# 2020-07-12 kdw  sqrttwo const
# 2020-07-10 kdw  normal cdf approx func
# 2020-07-01 kdw  tests modified
# 2020-06-30 kdw  tests changed
# 2020-06-22 kdw  local-use mved before var decls
# 2020-06-08 kdw  integral function stuff
# 2020-06-06 kdw  Gompertz distribution
# 2020-05-14 kdw  local funcs only in blocks
# 2020-05-11 kdw  BL[O]CK work
# 2020-05-06 kdw  rmed boolean vars
# 2020-05-05 kdw  magic check func changed
# 2020-04-30 kdw  trap[_]rand rework
# 2020-04-24 kdw  comments; const renam
# 2020-04-14 kdw  tests added
# 2020-04-12 kdw  comment change
# 2020-04-10 kdw  comment change
# 2020-04-08 kdw  preprocess sigil change
# 2020-04-07 kdw  comment; dup func rmed
# 2020-04-02 kdw  tweak here and there
# 2020-04-01 kdw  t quantile work
# 2020-03-30 kdw  s/_cdfinv/_quantile/g
# 2020-03-30 kdw  comment change
# 2020-03-29 kdw  func renam
# 2020-03-27 kdw  nbd and polya work
# 2020-03-26 kdw  _cdf trap inv func
# 2020-03-25 kdw  tri and trap simplified
# 2020-03-20 kdw  tri and trap work
# 2020-03-10 kdw  fixed pd[f]bb
# 2020-03-09 kdw  LO[C]AL_.* keywords
# 2020-03-05 kdw  s/TRU[E]VAL/TR[U]E/; s/FALS[E]VAL/FA[L]SE/
# 2020-03-03 kdw  comment change
# 2020-03-02 kdw  s/_NE[X]T/_E[N]D/g;
# 2020-02-28 kdw  poly eval work
# 2020-02-27 kdw  comment change
# 2020-02-26 kdw  arr[a]y and hor[n]er work
# 2020-02-16 kdw  array comments change
# 2020-02-14 kdw  incomplete beta work
# 2020-02-06 kdw  ks debugging II
# 2020-02-04 kdw  ks debugging
# 2020-02-03 kdw  more funcs have single return
# 2020-01-15 kdw  more arg checks in [cp]dfgeo()
# 2020-01-08 kdw  added several rand.* funcs
# 2019-12-31 kdw  maxwell-juttner distribution
# 2019-12-27 kdw  comments changed
# 2019-12-26 kdw  module name addded to funcs
# 2019-12-20 kdw  _pdf[mb]b long names
# 2019-11-20 kdw  black-body work II
# 2019-11-18 kdw  black-body work
# 2019-11-17 kdw  include Macros file
# 2019-10-23 kdw  lntwo const
# 2019-10-14 kdw  comment change
# 2019-10-04 kdw  comment change
# 2019-08-24 kdw  for and count loops have from clause
# 2019-08-22 kdw  comment changed
# 2019-08-18 kdw  B[O]OL to B[O]L
# 2019-08-17 kdw  L[O]G to LN
# 2019-08-11 kdw  comment cleanup
# 2019-08-06 kdw  rmed backslashes;macro arg renam
# 2019-07-22 kdw  func comments
# 2019-05-31 kdw  NR_DO to RAPHSON_LOOP; et al
# 2019-05-29 kdw  comment changed
# 2019-05-24 kdw  local replaced private
# 2019-05-20 kdw  rm unneeded comments; s/function/func/
# 2019-05-01 kdw  consts explicit module name
# 2019-03-19 kdw  re[t]_val to re[t]valu
# 2019-03-18 kdw  macro syntax changed
# 2019-03-16 kdw  tweak
# 2019-03-11 kdw  comments to array dcls
# 2019-03-08 kdw  is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  is.* funcs changed
# 2019-01-03 kdw  Await counter changed
# 2018-11-29 kdw  upper cased fwip defined funcs
# 2018-10-05 kdw  l[o]g to L[O]G
# 2018-09-17 kdw  zipf and zeta dists
# 2018-09-13 kdw  cdf[t]inv2 fix
# 2018-07-25 kdw  cdf[k]s_a
# 2018-07-22 kdw  lf_cdftinv_gt_half
# 2018-07-19 kdw  comments; array reformat
# 2018-07-17 kdw  private lf_.* funcs
# 2018-07-14 kdw  float num format
# 2018-07-11 kdw  var nam change
# 2018-06-09 kdw  mved tests
# 2018-06-08 kdw  tests
# 2018-05-17 kdw  AR[R]AY.* and HOR[N]ER syntax
# 2018-05-16 kdw  AR[R]AY syntax
# 2018-04-19 kdw  comments added
# 2018-04-03 kdw  rm () from return
# 2018-03-26 kdw  macro redef
# 2018-03-12 kdw  made PP statements not need semicolon
# 2018-02-19 kdw  secant and macro refactor
# 2018-02-14 kdw  comment change
# 2017-11-26 kdw  FR[O]M and B[Y] keywords
# 2017-11-22 kdw  var renam
# 2017-10-21 kdw  macros start with "at""at"
# 2017-10-20 kdw  COM[M]ENMT format changed
# 2017-10-03 kdw  dont die for bad args
# 2017-08-31 kdw  [pc]dftri, [pc]dfgeo, [pc]dfpoi added
# 2017-08-30 kdw  s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-20 kdw  rmed/renamd .*_P[E]R_.* vars
# 2017-06-21 kdw  added ";" to COM[M]ENT lines
# 2017-05-25 kdw  line wrap problem wrt python
# 2017-05-16 kdw  chisqr work
# 2017-04-26 kdw  keyword COMMENT.*
# 2017-04-24 kdw  extra parens added
# 2017-04-21 kdw  var renam
# 2017-04-20 kdw  func to function
# 2017-03-12 kdw  shorten long comments
# 2017-03-10 kdw  get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  INS[E]RT etal
# 2017-03-06 kdw  sigils rmed
# 2017-03-01 kdw  RE[T]URN syntax more finicky
# 2017-02-28 kdw  REQ[U]IRE function ()
# 2017-02-24 kdw  REP[L]ACE rework, et al
# 2017-02-20 kdw  made die more uniform
# 2017-02-14 kdw  FWIP Loop syntax changed
# 2017-02-13 kdw  FWIP language change
# 2017-02-12 kdw  FWIP language change
# 2017-02-08 kdw  SE[C]ANT syntax
# 2017-02-07 kdw  var renam
# 2017-02-06 kdw  SE[C]ANT syntax
# 2017-02-03 kdw  cdfb[e]tainv
# 2017-01-31 kdw  beta dist
# 2017-01-06 kdw  ..USE.* to ...*_MODE; ..DIGR.*
# 2017-01-03 kdw  var renam
# 2017-01-02 kdw  Pareto
# 2016-12-23 kdw  die change
# 2016-12-03 kdw  comment change
# 2016-11-27 kdw  long lines
# 2016-11-24 kdw  reformatting of await loops
# 2016-11-22 kdw  moved cdfno[r]mal2 to ap[p]rox and renam
# 2016-11-21 kdw  D[E]F to FU[N]C
# 2016-11-20 kdw  language change
# 2016-11-18 kdw  __POD__
# 2016-11-16 kdw  comments
# 2016-11-15 kdw  MOD/BIT* syntax change
# 2016-11-14 kdw  sec[a]nt algorithm refactor
# 2016-11-11 kdw  sec[a]nt algorithm refactor
# 2016-11-06 kdw  while loop replaced with await
# 2016-11-01 kdw  debugging t-distribution
# 2016-10-31 kdw  EX[I]TL[O]OP
# 2016-10-30 kdw  lang change
# 2016-09-15 kdw  lang change
# 2016-09-13 kdw  lang change
# 2016-08-15 kdw  layout error
# 2016-07-19 kdw  float numbers (added ".0")
# 2016-05-18 kdw  comment change
# 2015-12-28 kdw  .*2() functions rmed
# 2015-12-28 kdw  __IF_X__ to __IF_NONE_ _
# 2015-12-26 kdw  commented out _cdf[k]s_1
# 2015-12-16 kdw  long comments
# 2015-12-14 kdw  long lines
# 2015-12-11 kdw  s/LC_// from some consts
# 2015-12-03 kdw  long lines changed
# 2015-12-02 kdw  *student* to *t*
# 2015-11-26 kdw  long lines changed
# 2015-11-19 kdw  long lines changed
# 2015-11-17 kdw  variable rename
# 2015-11-13 kdw  minor refactor; long lines changed
# 2015-11-12 kdw  rmed useless function
# 2015-10-27 kdw  variable rename
# 2015-10-19 kdw  ga[m]ma to tga[m]ma
# 2015-10-09 kdw  renamed i[n]v functions
# 2015-10-01 kdw  float equality checks to is.*
# 2015-09-30 kdw  use p[o]w function
# 2015-09-27 kdw  tweak
# 2015-09-25 kdw  use isodd, iseven instead of [M]OD
# 2015-09-20 kdw  created

# http://www2.econ.osaka-u.ac.jp/ (tilde)tanizaki/cv/books
#      /cmse/cmse.pdf
{INSERT_FILE "Macros.fwip" }

FUNC DBL int_pdf(DBL para_nn, DBL xx):
   # PDF Uniform Integer
   # Support: 0..PARA_NN-1
   DBL retvalu;
   DBL ff;

   IF xx < 0.0 OR para_nn < xx OR (NOT Kw.isint(xx)):
      retvalu = 0.0;
   ELSE: # XX is an integer in [0,PARA_NN)
      ff = FLOOR(para_nn);
      IF Kw.isint(para_nn):
         IF xx < para_nn:
            retvalu = 1.0 / para_nn;
         ELSE:
            retvalu = 0.0;
         IF_END
      ELSE:
         IF xx < ff:
            retvalu = 1.0 / para_nn;
         ELSE:
            retvalu = 1.0 - ff / para_nn;
         IF_END
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL int_cdf(DBL para_nn, DBL xx):
   # CDF Uniform Integer [0,PARA_NN)
   # Support: 0..PARA_NN-1
   DBL retvalu;
   DBL ff;

   IF xx <= 0.0:
      retvalu = 0.0;
   ELSIF para_nn <= xx:
      retvalu = 1.0;
   ELSE:
      ff = FLOOR(para_nn);
      IF xx < ff:
         retvalu = (FLOOR(xx) + 1) / para_nn;
      ELSE:
         retvalu = 1;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL int_quantile(DBL para_nn, DBL probx):
   # Quantile Uniformly Integer [0,PARA_NN)
   # Support: 0..PARA_NN-1
   DBL retvalu;

   IF probx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 - frac(para_nn) / para_nn <= probx:
      retvalu = CEIL(para_nn - 1);
   ELSE:
      retvalu = FLOOR(para_nn * probx + 1);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT int_rand(DBL para_nn):
   # Random Uniform Integer Variable [0,PARA_NN)
   # Support: 0..PARA_NN-1
   # Average = FLOOR(PARA_NN)*(FLOOR(PARA_NN-1)/2+FRAC(PARA_NN))/PARA_NN
   #    If PARA_NN is an integer, average=(PARA_NN-1)/2
   INT retvalu;

   IF para_nn <= 1:
      retvalu = 0;
   ELSE:
      retvalu = FLOORL(randd() * para_nn);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL normal_pdf(DBL xx):
   # PDF (0,1) gaussian distribution
   # Support: (-Inf,Inf)
   # (-Inf,0,+Inf) to (0,1/SQRT(Kw.TAU),0)
   # MEAN       0
   # VARIANCE   1
   # MODE       0
   # MEDIAN     0
   RETURN EXP(-xx * xx / 2.0) / (SQRT(Kw.TAU));
FUNC_END

FUNC DBL normal_cdf(DBL xx):
   # CDF (0,1) gaussian distribution
   # Support: (-Inf,Inf)
   RETURN Kw.erf(xx / Kw.TWOSQRT) / 2.0 + 0.5;
FUNC_END

FUNC DBL normal_cdf__1(DBL xx):
   # approximate the CDF of the normal distribution
   DBL retvalu;
   DBL sum_curr;
   DBL sum_prev;
   DBL bb;
   DBL xx_sqr;
   DBL ii;

   IF xx <= -10.0:
      retvalu = 0.0;
   ELSIF 10.0 <= xx:
      retvalu = 1.0;
   ELSIF Kw.iszero(xx):
      retvalu = 0.5;
   ELSE:
      sum_curr = 0.0;
      bb = 1.0 / xx;
      xx_sqr = xx * xx;
      AWAIT Kw.iseq(sum_prev, sum_curr) COUNT ii FROM 0:
         bb *= xx_sqr / (2.0 * ii + 1.0);
         sum_prev = sum_curr;
         sum_curr += bb;
      AWAIT_END
      retvalu = (sum_curr * EXP(-0.5 * (xx_sqr + LN(Kw.TAU))) + 0.5);
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:normal_cdf__1(1) == 0.84134474606854294858523254563203792;

FUNC DBL normal_quantile(DBL probx):
   # Quantile normal distribution (0,1) to (-Inf,+Inf)
   RETURN Kw.TWOSQRT * Kw.erfinv(2.0 * probx - 1.0);
FUNC_END

BLOCK: # normal distributed nunmbers
   BLOCK_DEF DBL lv_rand_gau_magic = 0.0;
   BLOCK_DEF DBL lv_rand_gau_prev = 0.0;
   FUNC DBL normal_rand(NUL):
      # Random Normal Variable
      BLOCK_USE lv_rand_gau_magic;
      BLOCK_USE lv_rand_gau_prev;
      DBL retvalu;
      DBL uua;
      DBL uub;
      DBL ww;

      IF Kw.ismagic(lv_rand_gau_magic):
         lv_rand_gau_magic = Kw.magicnot();
         retvalu = lv_rand_gau_prev;
      ELSE:
         AWAIT Kw.isbetweenx(ww, 0.0, 0.25):
            uua = randd() - 0.5;
            uub = randd() - 0.5;
            ww = uua * uua + uub * uub;
         AWAIT_END
         ww = SQRT(-2.0 * LN(4.0 * ww) / ww);
         lv_rand_gau_prev = uub * ww;
         lv_rand_gau_magic = Kw.magicset();
         retvalu = uua * ww;
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END  # normal distributed nunmbers

FUNC DBL gau_pdf(DBL xx):
   # PDF gaussian distribution
   # (-Inf,0,+Inf) to (0,1/SQRT(Kw.TAU),0)
   # MEAN       0
   # VARIANCE   1
   # MODE       0
   # MEDIAN     0
   RETURN normal_pdf(xx);
FUNC_END

FUNC DBL gau_cdf(DBL xx):
   # CDF (0,1) gaussian distribution
   # Support: (-Inf,Inf)
   RETURN normal_cdf(xx);
FUNC_END

FUNC DBL gau_quantile(DBL probx):
   # Quantile normal ditribution (0,1) to (-Inf,+Inf)
   RETURN normal_quantile(probx);
FUNC_END

FUNC DBL gau_rand(NUL):
   # Random Normal Variable
   RETURN normal_rand();
FUNC_END

FUNC DBL normal_quantile__1(DBL probx):
   # Quantile normal ditribution (0,1) to (-Inf,+Inf)
   DBL retvalu;
   DBL p_low;
   DBL qq;
   DBL rr;
   DBL denom;
   DBL numer;
   #Define work variables

   #Define break-point
   p_low = 0.02425;

   IF probx <= 0.0:
      retvalu = -(Kw.DBLMAX);
   ELSIF 1.0 <= probx:
      retvalu = Kw.DBLMAX;
   ELSIF p_low <= probx AND probx <= 1.0 - p_low: # mid region
      qq = probx - 0.5;
      rr = qq * qq;
      numer = ((((((
               - 3.96968302866538E+1) * rr
               + 2.20946098424521E+2) * rr
               - 2.75928510446969E+2) * rr
               + 1.38357751867269E+2) * rr
               - 3.06647980661472E+1) * rr
               + 2.50662827745924E+0);

      denom = ((((((
               - 5.44760987982241E+1) * rr
               + 1.61585836858041E+2) * rr
               - 1.55698979859887E+2) * rr
               + 6.68013118877197E+1) * rr
               - 1.32806815528857E+1) * rr
               + 1.00000000000000E+0);

      retvalu = (qq * numer / denom);
   ELSE:
      IF probx < p_low:      # lower region
         rr = SQRT(-2.0 * LN(probx));
         qq = 1.0;
      ELSE:  # not lower region
         rr = SQRT(-2.0 * LN(1 - probx));
         qq = -1.0;
      IF_END
      numer = ((((((
               - 7.78489400243029E-3) * rr
               - 3.22396458041136E-1) * rr
               - 2.40075827716184E+0) * rr
               - 2.54973253934373E+0) * rr
               + 4.37466414146497E+0) * rr
               + 2.93816398269878E+0);

      denom = (((((
               + 7.78469570904146E-3) * rr
               + 3.22467129070040E-1) * rr
               + 2.44513413714300E+0) * rr
               + 3.75440866190742E+0) * rr
               + 1.00000000000000E+0);

      retvalu = qq * numer / denom;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL uni_pdf(DBL max_x, DBL xxp):
   # PDF uniform distribution on [0,MAX_X)
   # MEAN       MAX_X / 2
   # VARIANCE   MAX_X / 12
   # MODE       [0,MAX_X)
   # MEDIAN     MAX_X / 2
   DBL retvalu;

   IF max_x <= 0.0 OR xxp <= 0.0 OR max_x <= xxp:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / max_x;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL uni_cdf(DBL max_x, DBL xxp):
   # CDF uniform distribution on [0,MAX_X)
   # Support: [0,MAX_X)
   # MEAN       MAX_X / 2
   # VARIANCE   MAX_X / 12
   # MODE       [0,MAX_X)
   # MEDIAN     MAX_X / 2
   DBL retvalu;

   IF max_x <= 0.0 OR xxp < 0.0:
      retvalu = 0.0;
   ELSIF max_x < xxp:
      retvalu = 1.0;
   ELSE:
      retvalu = xxp / max_x;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL uni_quantile(DBL max_x, DBL probx):
   # Quantile uniform distribution on [0,MAX_X)
   # Support: [0,MAX_X)
   DBL retvalu;

   IF probx < 0.0 OR max_x <= 0.0:
      retvalu = 0.0;
   ELSIF max_x < probx:
      retvalu = 1.0;
   ELSE:
      retvalu = probx * max_x;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL uni_rand(DBL max_x):
   # Random uniform variable on [0,MAX_X)
   # Support: [0,MAX_X)
   RETURN uni_quantile(max_x, randd());
FUNC_END
#TEST:rand_init(1.987) == 1.987;
#TEST:uni_rand(1.0) == 0.215913421134297049512607014065679323;
#TEST:uni_rand(1.0) == 0.950541046512970850407286960148667276;
#TEST:uni_rand(1.0) == 0.697258003092750480375605626193191711;

FUNC DBL exp_pdf(DBL para_scaling, DBL xxp):
   # PDF exponential distribution on w/ scaling 0 < PARA_SCALING
   # Support: [0,Inf)
   # == PARA_SCALING * EXP(-PARA_SCALING * XXP)
   # MEAN       1 / PARA_SCALING
   # VARIANCE   1 / PARA_SCALING**2
   # MODE       0
   # MEDIAN     LN(2) / PARA_SCALING
   DBL retvalu;

   IF xxp < 0.0 OR para_scaling <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = para_scaling * EXP(-para_scaling * xxp);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL exp_cdf(DBL para_scaling, DBL xxp):
   # CDF exponential distribution w/ scaling 0 < PARA_SCALING
   # Support: [0,Inf)
   # == 1 - EXP(-PARA_SCALING * XXP)
   DBL retvalu;

   IF xxp < 0.0 OR para_scaling <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 - EXP(-para_scaling * xxp);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL exp_quantile(DBL para_scaling, DBL probx):
   # Quantile exponential ditribution [0,+Inf] to [0,1]
   # == -LN(1 - PROBX) / PARA_SCALING
   DBL retvalu;

   IF probx <= 0.0 OR para_scaling <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= probx:
      retvalu = Kw.DBLMAX;
   ELSE:
      retvalu = -LN(1.0 - probx) / para_scaling;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL exp_rand(DBL para_scaling):
   # Random Exponential Variable
   RETURN -LN(randd()) / para_scaling;
FUNC_END

FUNC DBL poi_pdf(DBL meanx, DBL xxp):
   # PDF poisson distribution
   # Support: [0,+Inf)
   # MEAN      MEANX
   # VARIANCE  MEANX
   # MODE      MEANX - 1
   # MEDIAN    approx FLOOR(MEANX + 1/3 +-0.02 / MEANX)
   DBL kk;
   DBL retvalu;

   IF xxp < 0.0 OR meanx <= 0.0:
      retvalu = 0.0;
   ELSE:
      kk = FLOOR(xxp);
      retvalu = POW(meanx, kk) * EXP(-meanx) / factorial(kk);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL poi_cdf(DBL meanx, DBL xxp):
   # CDF poisson distribution
   # Support: [0,+Inf)
   INT ii;
   INT kk;
   DBL sum;
   DBL term;
   DBL retvalu;

   IF xxp <= 0.0 OR meanx <= 0.0:
      retvalu = 0.0;
   ELSIF 1000.0 < xxp / meanx:
      retvalu = 1;#Kw.uigamma(xxp, meanx);
   ELSE:
      term = EXP(-meanx);
      sum = term;
      kk = FLOORL(xxp);
      FOR ii FROM 1 TO kk:
         term *= meanx / ii;
         sum += term;
      FOR_END
      retvalu = sum;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL poi_quantile(DBL meanx, DBL probx):
   # Quantile poisson distribution
   # MEAN      MEANX
   # VARIANCE  MEANX
   # MODE      MEANX - 1
   INT ii;
   DBL sum;
   DBL prevsum;
   DBL term;
   DBL retvalu;

   IF probx <= 0.0 OR meanx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= probx:
      retvalu = Kw.DBLMAX;
   ELSE:
      prevsum = 0.0;
      term = EXP(-meanx);
      sum = term;
      ii = 0;
      WHILE sum <= probx:
         ii += 1;
         term *= meanx / ii;
         prevsum = sum;
         sum += term;
      WHILE_END
      IF sum - probx < probx - prevsum:
         retvalu = ii;
      ELSE:
         retvalu = ii - 1;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT poi_rand(DBL meanx):
   # Random Poisson variable w/ mean MEANX
   # Support  NN = 0,1,2,3,...
   #   PDFPOI(NN) = MEANX**NN * EXP(-NN) / factorial(NN)
   DBL prob;
   DBL poi;
   DBL sum;
   INT nn;

   prob = randd();
   poi = EXP(-meanx);
   sum = poi;
   nn = 0;
   WHILE sum < prob:
      nn += 1;
      poi *= meanx / nn;
      sum += poi;
   WHILE_END
   RETURN nn;
FUNC_END

FUNC DBL geo_pdf(DBL prob, DBL kk):
   # PDF geometric distribution
   # Support: 0..Inf
   # MEAN      (1 - PROB) / PROB
   # VARIANCE  (1 - PROB) / PROB**2
   # MODE      0
   DBL retvalu;
   IF kk < 0 OR prob < 0.0 OR 1.0 <= prob:
      retvalu = 0.0;
   ELSE:
      retvalu = POW(1.0 - prob, kk) * prob;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL geo_cdf(DBL prob, DBL kk):
   # CDF geometric distribution (0,1),[0,Inf)
   # Support: 0..Inf
   # MEAN      (1 - PROB) / PROB
   # VARIANCE  (1 - PROB) / PROB**2
   # MODE      0
   # MEDIAN    CEIL(-1 / LG(1 - PROB))
   DBL retvalu;
   IF kk <= -1 OR prob < 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prob:
      retvalu = 1.0;
   ELSE:
      retvalu = 1.0 - POW(1.0 - prob, kk + 1);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL geo_quantile(DBL prob, DBL probx):
   # Quantile Geometric Distribution
   DBL retvalu;
   IF probx <= 0.0 OR 1.0 <= probx OR prob <= 0.0 OR 1.0 <= prob:
      retvalu = 0.0;
   ELSE:
      retvalu = LN(1.0 - probx) / LN(1.0 - prob) - 1.0;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT geo_rand(DBL prob):
   # Random Geometric Variable
   # Support  0,1,2,3,...
   # THIS IMPLEMENTATION HAS SUPPORT STARTING AT 0
   RETURN FLOORL(LN(randd()) / LN(1.0 - prob));
FUNC_END

FUNC DBL cauchy_pdf(DBL para_scaling, DBL xx):
   # PDF Cauchy distribution w/ scaling 0 < PARA_SCALING
   # Support: (-Inf,0,+Inf) to (0,1/Kw.PI,0)
   # MEAN      NAN  (0 principle value)
   # VARIANCE  NAN
   # MODE      0
   # MEDIAN    0
   # cauchy_pdf(1,x) == t_pdf(1,x)
   RETURN 1.0 / (Kw.PI * para_scaling
            * (1.0 + (Kw.square(xx / para_scaling))));
FUNC_END

FUNC DBL cauchy_cdf(DBL para_scaling, DBL xx):
   # CDF Cauchy distribution
   # Support: (-Inf,0,+Inf)
   RETURN taninv(xx / para_scaling) / Kw.PI + 0.5;
FUNC_END

FUNC DBL cauchy_quantile(DBL para_scaling, DBL probx):
   # Quantile Cauchy distribution
   #      (0,1) to (-Inf,+Inf)
   RETURN para_scaling * TAN((probx - 0.5) * Kw.PI);
FUNC_END

FUNC DBL cauchy_rand(DBL para_scaling):
   # Random Cauchy Variable
   RETURN cauchy_quantile(para_scaling, randd());
FUNC_END

FUNC DBL logistic_pdf(DBL ss, DBL xx):
   # PDF logistic distribution w/ scaling SS
   # Support: (-Inf,+Inf)
   # MEAN      0
   # VARIANCE  SS**2 * PI**2 / 3
   # MODE      0
   # MEDIAN    0
   DBL exs;
   DBL retvalu;

   IF ss <= 0.0:
      retvalu = 0.0;
   ELSE:
      exs = EXP(-xx / ss);

      retvalu = exs / (ss * POW(1.0 + exs, 2.0));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL logistic_cdf(DBL ss, DBL xx):
   # CDF logistic distribution w/ scaling SS
   # Support: (-Inf,+Inf)
   DBL retvalu;

   IF ss <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / (1.0 + EXP(-xx / ss));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL logistic_quantile(DBL ss, DBL probx):
   # Quantile logistic distribution w/ scaling SS
   DBL retvalu;

   IF probx <= 0.0 OR ss <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= probx:
      retvalu = 1.0;
   ELSE:
      retvalu = -ss * LN(1.0 / probx - 1.0);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL logistic_rand(DBL ss):
   # Random Logistic Variable w/ scaling SS
   RETURN -ss * LN(1.0 / randd() - 1.0);
FUNC_END

FUNC DBL tri_pdf(DBL pp, DBL xxp):
   # PDF Triangular distribution w/ 0 <= PP <= 1
   # PDF* is triangle defined by (0,0) (1,0) (pp,2)
   # Support: [0,1]
   # MEAN      (PP + 1) / 3
   # VARIANCE  (PP**2 - PP + 1) / 18
   # MODE      PP
   # MEDIAN    IF 1 / 2 < PP: SQRT(PP / 2)
   # MEDIAN    ELSE: 1 - SQRT((1 - PP) / 2)
   DBL retvalu;

   IF pp < 0.0 OR 1.0 < pp:
      retvalu = 0.0;
   ELSE:
      IF xxp < 0.0 OR 1.0 < xxp:
         retvalu = 0.0;
      ELSIF xxp < pp:
         retvalu = Kw.divi(2.0 * xxp, pp, 2.0);
      ELSE:
         retvalu = Kw.divi(2.0 * (1.0 - xxp), 1.0 - pp, 2.0);
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL tri_cdf(DBL pp, DBL xxp):
   # CDF Triangular distribution
   # Support: [0,1]
   DBL retvalu;

   IF pp < 0.0 OR 1.0 < pp:
      retvalu = 0.0;
   ELSE:
      IF xxp <= 0.0:
         retvalu = 0.0;
      ELSIF xxp < pp:
         retvalu = xxp * xxp / pp;
      ELSIF xxp < 1.0:
         retvalu = 1.0 - Kw.square(1.0 - xxp) / (1.0 - pp);
      ELSE:
         retvalu = 1.0;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL tri_quantile(DBL pp, DBL probx):
   # Quantile Triangular Variable
   DBL retvalu;

   IF pp < 0.0 OR 1.0 < pp:
      retvalu = 0.0;
   ELSE:
      IF probx <= 0.0:
         retvalu = 0.0;
      ELSIF probx < pp:
         retvalu = SQRT(probx * pp);
      ELSIF probx < 1.0:
         retvalu = 1.0 - SQRT((1.0 - probx) * (1.0 - pp));
      ELSE:
         retvalu = 1.0;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL tri_rand(DBL pp):
   # Random Triangular Variable
   # Valid only if 0 <= PP <= 1
   # PDF is triangle (0,0) (1,0) and (PP,2)
   DBL xxp;
   DBL yy;

   xxp = randd();
   yy = randd();
   IF xxp < pp:
      IF 2.0 * xxp < pp * yy:
         xxp = pp - xxp;
      IF_END
   ELSE:
      IF (pp - 1.0) * yy < 2.0 * (xxp - 1.0):
         xxp = (pp + 1.0) - xxp;
      IF_END
   IF_END

   RETURN xxp;
FUNC_END

FUNC DBL trap_pdf(DBL prob_a, DBL prob_b, DBL xx):
   # PDF Trapezoidal Variable
   # Support: [0,1]
   # Must have 0 <= PROB_A <= PROB_B  <= 1.0
   # PDF is bounded by (0,0) (1,0), (PROB_A,HH) and (PROB_B,HH)
   #   where HH = 2 / (1 + PROB_B - PROB_A)
   # Support [0,1]
   # trap_pdf(A,A,) = tri_pdf(A,)
   DBL retvalu;

   IF xx < 0.0 OR 1.0 < xx OR prob_a < 0.0
            OR prob_b < prob_a OR 1.0 < prob_b:
      retvalu = 0.0;
   ELSE:
      IF xx < prob_a:
         retvalu = xx / prob_a;
      ELSIF xx <= prob_b:
         retvalu = 1.0;
      ELSE:
         retvalu = (1.0 - xx) / (1.0 - prob_b);
      IF_END
   IF_END

   # scale to force area under PDF == 1.0
   RETURN retvalu * 2.0 / (1.0 + prob_b - prob_a);
FUNC_END

FUNC DBL trap_cdf(DBL prob_a, DBL prob_b, DBL xx):
   # CDF Trapezoidal Variable
   # Support: [0,1]
   # Must have 0 <= PROB_A <= PROB_B <= 1.0
   # PDF is bounded by (0,0) (1,0), (PROB_A,HH) and (PROB_B,HH)
   #   where HH = 2 / (1 + PROB_B - PROB_A)
   # Support  [0,1]
   DBL ff;
   DBL retvalu;

   IF prob_a < 0.0 OR prob_b < prob_a OR 1.0 < prob_b:
      retvalu = 0.0;
   ELSIF xx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= xx:
      retvalu = 1.0;
   ELSE:
      ff = 2.0 / (1.0 + prob_b - prob_a);
      IF xx < prob_a:
         retvalu = ff * xx * xx / (2.0 * prob_a);
      ELSIF xx < prob_b:
         retvalu = ff * (xx - prob_a / 2.0);
      ELSE:
         retvalu = 1.0 - ff * Kw.square(1.0 - xx) / (2.0 * (1.0 - prob_b));
      IF_END
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL trap_quantile(DBL prob_a, DBL prob_b, DBL xx):
   # Quantile Trapezoidal Variable
   # Must have 0 <= PROB_A <= PROB_B <= 1.0
   # PDF is bounded by (0,0) (1,0), (PROB_A,HH) and (PROB_B,HH)
   #    where HH = 2 / (1 + PROB_B - PROB_A)
   # Support  [0,1]
   DBL ff;
   DBL retvalu;

   IF prob_a < 0.0 OR prob_b < prob_a OR 1.0 < prob_b:
      retvalu = 0.0;
   ELSIF xx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= xx:
      retvalu = 1.0;
   ELSE:
      ff = 2.0 / (1.0 + prob_b - prob_a);
      IF xx < prob_a * ff / 2.0:
         retvalu = SQRT((2.0 * prob_a * xx) / ff);
      ELSIF xx < 1.0 - ff * (1.0 - prob_b) / 2.0:
         retvalu = xx / ff + prob_a / 2.0;
      ELSE:
         retvalu = 1.0 - SQRT(2.0 * (1.0 - prob_b) * (1.0 - xx) / ff);
      IF_END
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL trap_rand(DBL prob_a, DBL prob_b):
   # Random Trapezoidal Variable
   # Support  [0,1]
   DBL xx;
   DBL retvalu;

   retvalu = -1;
   AWAIT 0.0 <= retvalu:
      xx = randd();
      IF xx < prob_a:
         IF randd() * prob_a < xx:
            retvalu = xx;
         IF_END
      ELSIF xx <= prob_b:
         retvalu = xx;
      ELSE:
         IF randd() * (1.0 - prob_b) < (1.0 - xx):
            retvalu = xx;
         IF_END
      IF_END
   AWAIT_END

   RETURN retvalu;
FUNC_END

FUNC DBL pareto_pdf(DBL para_shape, DBL para_scaling, DBL xx):
   # PDF Pareto distribution with shape 0 < PARA_SHAPE
   # and scale 0 < PARA_SCALING.
   # Support: [0,Inf)
   # == PARA_SHAPE * (PARA_SCALING / XX) ** PARA_SHAPE / XX
   # MEAN       IF PARA_SHAPE <= 1: INF
   # MEAN       ELSE: PARA_SHAPE * PARA_SCALING / (PARA_SHAPE - 1)
   # VARIANCE   IF PARA_SHAPE <= 2: INF
   # VARIANCE   ELSE: PARA_SHAPE**2 * PARA_SCALING
   # VARIANCE         / ((PARA_SHAPE - 1)**2 * (PARA_SHAPE - 2))
   # MODE       PARA_SCALING
   # MEDIAN     PARA_SCALING * POW(2, 1 / PARA_SHAPE)
   RETURN para_shape * POW(para_scaling / xx, para_shape) / xx;
FUNC_END

FUNC DBL pareto_cdf(DBL para_shape, DBL para_scaling, DBL xx):
   # CDF Pareto distribution with shape 0 < PARA_SHAPE
   # and scale 0 < PARA_SCALING.
   # Support: [0,Inf)
   # == 1 - (PARA_SCALING / XX) ** PARA_SHAPE
   RETURN 1.0 - POW(para_scaling / xx, para_shape);
FUNC_END

FUNC DBL pareto_quantile(DBL para_shape, DBL para_scaling, DBL probx):
   # Quantile Pareto distribution with shape 0 < PARA_SHAPE
   # and scale 0 < PARA_SCALING.
   RETURN para_scaling / POW(1.0 - probx, 1.0 / para_shape);
FUNC_END
#TEST:pareto_quantile(1.3, 2.4, pareto_cdf(1.3,2.4, 3.5)) == 3.5;

FUNC DBL pareto_rand(DBL para_shape, DBL para_scaling):
   # Random Pareto Variable with shape 0 < PARA_SHAPE
   # and scale 0 < PARA_SCALING.
   RETURN para_scaling / POW(randd(), 1.0 / para_shape);
FUNC_END

FUNC DBL gompertz_pdf(DBL para_shape, DBL para_scaling, DBL xx):
   # PDF Gompertz distribution with shape 0 < PARA_SHAPE
   # and scale 0 < PARA_SCALING.
   # Support: [0,Inf)
   # MEAN       EXP(PARA_SHAPE) * Kw.Ei(-PARA_SHAPE) / PARA_SCALING
   # MODE       IF PARA_SHAPE < 1: -LN(PARA_SHAPE) / PARA_SCALING
   # MODE       ELSE: 0
   # MEDIAN     LN(LN(0.5) / PARA_SHAPE + 1) / PARA_SCALING
   RETURN EXP(para_scaling * xx + para_shape * (1 - EXP(para_scaling * xx)))
            * para_scaling * para_shape;
FUNC_END

FUNC DBL gompertz_cdf(DBL para_shape, DBL para_scaling, DBL xx):
   # CDF gompertz distribution with shape 0 < PARA_SHAPE
   # and scale 0 < PARA_SCALING.
   # Support: [0,Inf)
   RETURN 1.0 - EXP(para_shape * (1.0 - EXP(para_scaling * xx)));
FUNC_END

FUNC DBL gompertz_quantile(DBL para_shape, DBL para_scaling, DBL probx):
   # Quantile Gompertz distribution with shape 0 < PARA_SHAPE
   # and scale 0 < PARA_SCALING.
   RETURN LN(1 - LN(1.0 - probx) / para_shape) / para_scaling;
FUNC_END
#TEST:gompertz_quantile(1.3,2.4, gompertz_cdf(1.3,2.4,0.7))-0.7;

FUNC DBL gompertz_rand(DBL para_shape, DBL para_scaling):
   # Random Gompertz Variable with shape 0 < PARA_SHAPE
   # and scale 0 < PARA_SCALING.
   RETURN gompertz_quantile(para_shape, para_scaling, randd());
FUNC_END

FUNC DBL zipf_pdf(DBL ss, INT max_kk, INT kk):
   # PDF zipf distribution w/ parameter SS over 1..MAX_KK
   DBL retvalu;

   IF kk <= 0.0 OR max_kk < kk:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / (POW(kk, ss) * Kw.hnm(max_kk, ss));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL zipf_cdf(DBL ss, INT max_kk, INT kk):
   # CDF zipf distribution w/ parameter SS over 0..MAX_KK
   DBL retvalu;

   IF kk <= 0.0:
      retvalu = 0.0;
   ELSIF max_kk < kk:
      retvalu = 1.0;
   ELSE:
      retvalu = Kw.hnm(kk, ss) / Kw.hnm(max_kk, ss);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT zipf_quantile(DBL ss, INT max_kk, DBL probx):
   # Inverse Zipf distribution w/ parameter SS
   #    over integers KK in [1,MAX_KK]
   INT ii;
   DBL summ;
   DBL target;

   target = probx * Kw.hnm(max_kk, ss);
   summ = 0.0;
   AWAIT target <= summ COUNT ii FROM 1:
      summ += 1.0 / POW(ii, ss);
   AWAIT_END
   RETURN ii;
FUNC_END

FUNC INT zipf_rand(DBL ss, INT max_kk):
   # Random Zipf Variable w/ parameter SS
   #    over integers in [1,MAX_KK]
   RETURN zipf_quantile(ss, max_kk, randd());
FUNC_END

FUNC DBL beta_pdf(DBL para_shape_a, DBL para_shape_b, DBL xx):
   # PDF Beta distribution w/ shape 0 < PARA_SHAPE_A,PARA_SHAPE_B
   # Support: (-Inf,Inf)
   RETURN POW(xx, para_shape_a - 1.0) * POW((1.0 - xx), para_shape_b - 1.0)
            / beta(para_shape_a, para_shape_b);
FUNC_END

FUNC DBL beta_cdf(DBL para_shape_a, DBL para_shape_b, DBL xx):
   # CDF Beta distribution with shape parameters
   #    0 < PARA_SHAPE_A and 0 < PARA_SHAPE_B
   RETURN betainc(para_shape_a, para_shape_b, xx);
FUNC_END

FUNC DBL beta_quantile(DBL para_shape_a, DBL para_shape_b, DBL probx):
   # Quantile Beta distribution with shape parameters
   #    0 < PARA_SHAPE_A and 0 < PARA_SHAPE_B
   DBL retvalu;
   {SECANT_DECLARATIONS}

   IF probx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= probx:
      retvalu = 1.0;
   ELSE:
      {SECANT_LOOP 0.25 ; 0.50
               ; probx - beta_cdf(para_shape_a, para_shape_b, scvx_xx) }
      retvalu = scvx_xx;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL beta_rand(DBL para_shape_a, DBL para_shape_b):
   # Random Beta Variable w/ shape 0 < PARA_SHAPE_A,PARA_SHAPE_B
   RETURN beta_quantile(para_shape_a, para_shape_b, randd());
FUNC_END

FUNC DBL gamma_pdf(DBL para_shape, DBL xxp):
   # PDF gamma distribution w/ shape PARA_SHAPE
   # Support: (0,Inf)
   # MEAN       PARA_SHAPE
   # VARIANCE   PARA_SHAPE
   # MODE       PARA_SHAPE - 1 for 1 <= PARA_SHAPE
   # MEDIAN     ?
   DBL retvalu;

   IF xxp <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = EXP(LN(xxp) * (para_shape - 1.0) - xxp)
               / Kw.tgamma(para_shape);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL gamma_cdf(DBL para_shape, DBL xxp):
   # CDF gamma distribution w/ shape PARA_SHAPE
   # Support: (0,Inf)
   # MEAN       PARA_SHAPE
   # VARIANCE   PARA_SHAPE
   # MODE       PARA_SHAPE - 1 for 1 <= PARA_SHAPE
   # MEDIAN     ?
   DBL retvalu;
   DBL rr;
   INT ii;
   DBL sum;

   IF xxp <= 0.0 OR para_shape <= 0.0:
      retvalu = 0.0;
   ELSIF Kw.isint(para_shape):
      sum = 1.0;
      rr = 1.0;
      FOR ii FROM 1 TO para_shape - 1:
         rr *= xxp / ii;
         sum += rr;
      FOR_END
      retvalu = 1.0 - EXP(-xxp) * sum;
   ELSE:
      retvalu = Kw.rligamma(para_shape, xxp);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL gamma_rand(DBL para_shape):
   # Random Gamma Variable w/ shape PARA_SHAPE
   DBL i_shape;
   DBL f_shape;
   DBL rval;
   DBL jj;
   DBL ee;
   DBL gg;
   DBL yy;
   DBL ff;
   DBL xx;
   DBL vv;
   DBL qq;
   DBL pp;

   i_shape = FLOOR(para_shape);
   rval = 1.0;
   IF para_shape < 5:
      FOR jj FROM 1 TO i_shape:
         rval *= randd();
      FOR_END
      rval = -LN(rval);
      f_shape = para_shape - i_shape;
      IF 0.00001 < f_shape:
         # from "The Art of Computer Programming"
         # Volume 2 1997 by Donald Knuth, Page 587
         pp = Kw.E / (f_shape + Kw.E);
         AWAIT randd() < qq:
            vv = LN(randd());
            IF randd() < pp:
               xx = EXP(vv / f_shape);
               qq = EXP(-xx);
            ELSE:
               xx = 1.0 - vv;
               qq = EXP(LN(xx) * (f_shape - 1));
            IF_END
         AWAIT_END
         rval += xx;
      IF_END
   ELSE:
      # from "The Art of Computer Programming"
      # Volume 2 1997 by Donald Knuth, Page 134
      ee = para_shape - 1.0;
      gg = SQRT(para_shape + ee);
      yy = 0.0;
      ff = 0.0;
      WHILE rval <= 0.0 OR (1.0 + yy * yy) * EXP(ee * LN(rval / ee) - ff)
               < randd():
         xx = Kw.PI * randd();
         yy = SIN(xx) / COS(xx);
         ff = gg * yy;
         rval = ff + ee;
      WHILE_END
   IF_END
   RETURN rval;
FUNC_END

FUNC DBL chisqr_pdf(DBL df, DBL xxp):
   # PDF Chi-square distribution
   # Support: (0,Inf)
   # MEAN       DF
   # VARIANCE   2 * DF
   # MODE       MAX(DF - 2, 0)
   # MEDIAN     about DF * (1 - 2 / (9 * DF**2))
   DBL retvalu;

   IF xxp <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = EXP((LN(xxp / 2.0) * df - xxp) / 2.0)
               / (xxp * Kw.tgamma(df / 2.0));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL chisqr_cdf(DBL df, DBL xxp):
   # CDF Chi-square distribution
   # Support: (0,Inf)
   # MEAN       DF
   # VARIANCE   2 * DF
   # MODE       MAX(DF - 2, 0)
   # MEDIAN     about DF * (1 - 2 / (9 * DF**2))
   DBL retvalu;

   IF xxp <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = (1.0 - Kw.ruigamma(df / 2.0, xxp / 2.0));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL chisqr_rand(DBL df):
   # Random Chi-squared Variable w/ DF
   DBL sum;
   DBL vv;
   DBL jj;

   sum = 0.0;
   FOR jj FROM 1 TO df:
      vv = gau_rand();
      sum += vv * vv;
   FOR_END
   IF NOT Kw.isint(df):
      sum += gamma_rand(frac(df) / 2.0) * 2.0;
   IF_END
   RETURN sum;
FUNC_END

FUNC DBL binomial_pdf(DBL prob_a, INT success, INT trial):
   # PDF binomial distribution
   # Support: 0..SUCCESS
   DBL retvalu;
   IF success < 0 OR trial < success:
      retvalu = 0.0;
   ELSE:
      retvalu = comb(trial, success) * POW(prob_a, success)
               * POW(1.0 - prob_a, trial - success);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL binomial_cdf(DBL prob_a, INT success, INT trial):
   # CDF binomial distribution
   # Support: 0..SUCCESS
   # Must have  0 <= PROB_A <= 1 ; SUCCESS <= TRIAL
   #  == betainc(TRIAL - SUCCESS, SUCCESS + 1.0, 1.0 - PROB)
   DBL lsum;
   DBL sfactor;
   INT ss;
   DBL mu;
   DBL kk;

   IF prob_a <= 0.0 OR success < 0:
      lsum = 0.0;
   ELSIF 1.0 <= prob_a OR trial <= success:
      lsum = 1.0;
   ELSE:
      # Use binomial_cdf(PR,K,N) = binomial_cdf(1-PR,N-K-1,N)
      IF trial <= 2 * success:
         ss = trial - success - 1;
         prob_a = 1.0 - prob_a;
      ELSE:
         ss = success;
      IF_END

      sfactor = POW(1.0 - prob_a, trial);
      mu = prob_a / (1.0 - prob_a);
      lsum = 0.0;
      FOR kk FROM 0 TO ss:
         lsum += sfactor;
         sfactor *= (mu * (trial - kk)) / (kk + 1.0);
      FOR_END

      IF ss <> success:
         lsum = 1.0 - lsum;
      IF_END
   IF_END
   RETURN lsum;
FUNC_END

FUNC DBL binomial_rand(DBL prob_a, DBL rr):
   # Random Binomial Variable
   # count of successes with probability PROB_A in RR trials
   DBL successes;

   successes = 0.0;
   WHILE 0 < rr:
      IF randd() < prob_a:
         successes += 1;
      IF_END
      rr -= 1;
   WHILE_END
   RETURN successes;
FUNC_END

FUNC DBL benford_pdf(INT max_kk, INT kk):
   # PDF Benford distribution aka "First-digit law"
   # Support: 1..MAX_KK-1
   # == LN(1 + 1 / KK) / LN(MAX_KK)
   DBL retvalu;

   IF kk <= 0.0 OR max_kk <= kk:
      retvalu = 0.0;
   ELSE:
      retvalu = LN(1.0 + 1.0 / kk) / LN(max_kk);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL benford_cdf(INT max_kk, INT kk):
   # CDF Benford distribution aka "First-digit law"
   # Support: 1..MAX_KK-1
   # == LN(KK + 1) / LN(MAX_KK)
   DBL retvalu;

   IF kk <= 0.0:
      retvalu = 0.0;
   ELSIF max_kk <= kk:
      retvalu = 1.0;
   ELSE:
      retvalu = LN(kk + 1.0) / LN(max_kk);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT benford_rand(INT max_kk):
   # Random Benford Variable over [1,MAX_KK)
   # aka "First-digit law"
   INT ii;
   DBL summ;
   DBL target;

   target = randd();
   summ = 0.0;
   AWAIT target <= summ COUNT ii FROM 1:
      summ += LN(1.0 + 1.0 / ii) / LN(max_kk);
   AWAIT_END
   RETURN ii;
FUNC_END

FUNC DBL nbd_pdf(DBL prob_a, INT rsuccesses, INT kfailures):
   # PDF Negative Binomial Distribution with
   #    success probability PROB_A, RSUCCESSES successes,
   #    and KFAILURES failures.
   # Support: Z*,Z*
   # return probability that the RSUCCESESth success
   #    is on the (KFAILURES + RSUCCESSES)th trial
   #    given probability of success == PROB_A
   RETURN comb(rsuccesses + kfailures - 1, kfailures)
            * POW(prob_a, rsuccesses) * POW(1.0 - prob_a, kfailures);
FUNC_END

FUNC DBL nbd_cdf(DBL prob_a, INT rsuccesses, INT kfailures):
   # CDF Negative Binomial Distribution with
   #    success probability PROB_A, RSUCCESSES successes,
   #    and KFAILURES failures.
   # Support: 0..Inf
   # return probability that the RSUCCESESth success
   #    occurs before the (KFAILURES + RSUCCESSES + 1 )th trial
   #    given probability of success == PROB_A
   RETURN 1.0 - betainc(kfailures + 1, rsuccesses, 1.0 - prob_a);
FUNC_END

FUNC INT nbd_rand(DBL prob_a, INT rsuccesses):
   # Random Negative Binomial Variable
   # Return number of failures before the RSUCCESSESth
   #     success given probability of success == PROB_A
   # support is integers in [0,+Inf)
   INT failures;
   INT rr;

   rr = rsuccesses;
   failures = 0;
   WHILE 0 < rr:
      IF randd() <= prob_a:
         rr -= 1;   # success
      ELSE:
         failures += 1;   # failure
      IF_END
   WHILE_END

   RETURN failures;
FUNC_END

FUNC DBL polya_pdf(DBL prob_a, DBL rsuccesses, DBL kfailures):
   RETURN combx(rsuccesses + kfailures - 1, kfailures)
            * POW(1.0 - prob_a, kfailures) * POW(prob_a, rsuccesses);
FUNC_END

FUNC DBL polya_cdf(DBL prob_a, DBL rsuccesses, DBL kfailures):
   RETURN 1.0 - betainc(kfailures + 1, rsuccesses, 1.0 - prob_a);
FUNC_END

FUNC DBL polya_rand(DBL tt, DBL probx):
   # Random Polya Variable
   # a real extension of negative binomial distribution
   DBL nn;
   DBL ff;
   DBL rr;
   INT uu;
   DBL qq;

   nn = 0;
   ff = tt - 1;
   qq = EXP(tt * LN(probx));
   rr = qq;
   uu = randd();

   WHILE rr <= uu:
      nn += 1;
      ff += 1;
      qq *= (1.0 - probx) * ff / nn;
      rr += qq;
   WHILE_END

   RETURN nn;
FUNC_END

FUNC DBL zeta_pdf(DBL ss, INT ixxp):
   # PDF zeta distribution w/ parameter SS
   # Support: Z*
   DBL retvalu;

   IF ixxp <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / (Kw.zeta(ss) * POW(ixxp, ss));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL zeta_cdf(DBL ss, INT ixxp):
   # CDF zeta distribution w/ parameter SS
   # Support: Z*
   DBL retvalu;

   IF ixxp <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = Kw.hnm(ixxp, ss) / Kw.zeta(ss);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL ks_cdf(INT para_nn, DBL xx):
   # CDF Kolmogorov-Smirnov distribution
   # from "The Art of Computer Programming" by D. E. Knuth
   # Volume 2 3ed. Pg 58 and 561
   DBL retvalu;
   DBL two_tt_sqr;
   INT kk;
   DBL sum;
   DBL tt;

   IF para_nn <= 0 OR xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      IF 30 < para_nn:
         tt = xx;
         two_tt_sqr = 2.0 * tt * tt;
         sum = EXP(-two_tt_sqr) * (1.0 - 2.0 * tt / (3.0 * SQRT(para_nn))
                  - two_tt_sqr * (two_tt_sqr / 9.0 - 1.0 / 3.0) / para_nn);
         retvalu = 1.0 - sum;
      ELSE:
         tt = xx * SQRT(para_nn);
         sum = 0.0;
         kk = para_nn;
         WHILE tt < kk:
            sum += Kw.comb(para_nn, kk) * POW(kk - tt, kk)
                     * POW(tt + para_nn - kk, para_nn - kk - 1);
            kk -= 1;
         WHILE_END
         retvalu = 1.0 - sum * tt / POW(para_nn, para_nn);
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL ks_a_cdf(DBL xx):
   # from Wikipedia - Kolmogorov-Smirnov_test
   #      Pr(K <= XX) = ks_a_cdf(XX)
   # where K is a Kolmogorov Distribution
   DBL sum;
   DBL sum_prev;
   DBL vv;
   INT kk;
   DBL retvalu;

   IF xx < 0.0001:
      retvalu = 0.0;
   ELSE:
      sum = 0.0;
      vv = -Kw.square(Kw.PI / xx) / 8.0;

      AWAIT Kw.iseq(sum, sum_prev) COUNT kk FROM 1 BY 2:
         sum_prev = sum;
         sum += EXP(vv * kk * kk);
      AWAIT_END
      retvalu = sum * SQRT(Kw.TAU) / xx;
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL ks_b_cdf(INT para_nn, DBL xx):
   # from Wikipedia - Kolmogorov-Smirnov_test
   # Thin wrapper around ks_a_cdf where XX is replaced with
   #   XX + 1 / (6 * sqrt(PARA_NN)) + (XX - 1) / (4 * PARA_NN)
   DBL retvalu;
   DBL nxx;

   IF xx < 0.0001 OR para_nn <= 0:
      retvalu = 0.0;
   ELSE:
      nxx = xx + (2.0 * SQRT(para_nn) + 3.0 * xx - 3.0) / (12.0 * para_nn);
      retvalu = ks_a_cdf(nxx);
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL ks_quantile(DBL para_nn, DBL probx):
   # Quantile Kolmogorov-Smirnov distribution
   {SECANT_DECLARATIONS}
   IF NOT Kw.isbetween(probx, 0.0, 1.0):
      scvx_xx = 0.0;
   ELSE:
      {SECANT_LOOP 0.25 ; 0.5 ; probx - ks_cdf(para_nn, scvx_xx) }
   IF_END
   RETURN scvx_xx;
FUNC_END

FUNC DBL t_pdf(DBL dfn, DBL xx):
   # PDF Students T Distribution
   RETURN Kw.tgamma((dfn + 1.0) / 2.0)
            * POW((1.0 + Kw.square(xx) / dfn), (-(dfn + 1.0) / 2.0))
            / (SQRT(dfn * Kw.PI) * Kw.tgamma(dfn / 2.0));
FUNC_END

BLOCK: # define t_cdf
   BLOCK_DEF FUNC DBL lf_subtprob(DBL para_nnx, DBL xx):
      DBL aa;
      DBL bb;
      DBL ww;
      DBL zz;
      DBL yy;
      DBL ii;
      INT para_nn;
      DBL retvalu;

      para_nn = FLOORL(ABS(para_nnx));

      ww = ATAN2(xx, SQRT(para_nn));
      zz = Kw.square(COS(ww));
      yy = 1.0;

      ii = para_nn - 2.0;
      WHILE 2.0 <= ii:
         yy = 1.0 + (ii - 1.0) / ii * zz * yy;
         ii -= 2.0;
      WHILE_END

      IF Kw.iseven(para_nn):
         aa = SIN(ww) / 2.0;
         bb = 0.5;
      ELSE:
         IF para_nn == 1:
            aa = 0.0;
         ELSE:
            aa = SIN(ww) * COS(ww) / Kw.PI;
         IF_END

         bb = 0.5 + ww / Kw.PI;
      IF_END

      retvalu = bb + aa * yy;
      IF 1.0 < retvalu:
         retvalu = 1.0;
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC DBL t_cdf(DBL dfx, DBL xx):
      # CDF Students T distribution
      RETURN lf_subtprob(dfx, xx);
   FUNC_END
BLOCK_END # define t_cdf

BLOCK:
   BLOCK_DEF FUNC DBL lf_t_quantile(INT ndfx, DBL probx):
      # Quantile Students T distribution
      DBL ux;
      DBL uxsq;
      DBL aa_x;
      DBL bb_x;
      DBL cc_x;
      DBL dd_x;
      DBL ee_x;
      DBL retvalu;
      DBL delta;
      DBL pp_a;
      DBL nn_a;
      DBL out_sign;

      IF probx < 0.5:
         probx = 1.0 - probx;
         out_sign = -1;
      ELSE:
         out_sign = 1;
      IF_END
      ux = normal_quantile(probx);# 20121022 kdpw lf_subu(probx);
      uxsq = Kw.square(ux);

      aa_x = ((
               + 1.0) * uxsq
               + 1.0) / 4.0;
      bb_x = (((
               + 5.0) * uxsq
               + 16.0) * uxsq
               + 3.0) / 96.0;
      cc_x = ((((
               + 3.0) * uxsq
               + 19.0) * uxsq
               + 17.0) * uxsq
               - 15.0) / 384.0;
      dd_x = (((((
               + 79.0) * uxsq
               + 776.0) * uxsq
               + 1482.0) * uxsq
               - 1920.0) * uxsq
               - 945.0) / 92160.0;
      ee_x = ((((((
               + 27.0) * uxsq
               + 339.0) * uxsq
               + 930.0) * uxsq
               - 1782.0) * uxsq
               - 765.0) * uxsq
               - 17955.0) / 368640.0; # 20200407 kdw  changed sign

      retvalu = ux * (1.0 + (aa_x + (bb_x + (cc_x + (dd_x + ee_x / ndfx)
               / ndfx) / ndfx) / ndfx) / ndfx);

      IF ndfx <= Kw.square(Kw.log10(probx)) + 3.0:
         nn_a = ndfx + 1.0;
         AWAIT Kw.iszero(retvalu) OR aa_x < retvalu:
            pp_a = lf_subtprob(ndfx, retvalu);
            ee_x = (nn_a * LN(nn_a / (ndfx + Kw.square(retvalu)))
                     + LN(ndfx / nn_a / Kw.TAU) - 1.0
                     + (1.0 / nn_a - 1.0 / ndfx) / 6.0) / 2.0;
            IF Kw.DBLMAXLN / 2.0 < ee_x: # prevent exp overflow
               delta = 0.0;
            ELSE:
               delta = (pp_a - probx) / EXP(ee_x);
            IF_END
            retvalu -= delta;
            # reuse aa_x
            aa_x = ABS(delta) * 10000.0;
         AWAIT_END
      IF_END
      RETURN out_sign * retvalu;
   FUNC_END

   FUNC DBL t_quantile(DBL dfx, DBL probx):
      # Quantile Students T distribution
      INT ndfx;
      DBL retvalu;

      ndfx = FLOOR(ABS(dfx));

      IF Kw.iszero(probx - 0.5):
         retvalu = 0.0;
      ELSIF probx <= 0.0:
         retvalu = - Kw.DBLMAX;
      ELSIF 1.0 <= probx:
         retvalu = Kw.DBLMAX;
      ELSE:
         retvalu = lf_t_quantile(ndfx, probx);
      IF_END

      RETURN retvalu;
   FUNC_END
BLOCK_END # define t_quantile()

FUNC DBL t_cdf__1(DBL dfx, DBL xx):
   # CDF Students T distribution
   DBL zz;
   DBL yy;

   yy = SQRT(dfx + xx * xx);
   zz = (xx + yy) / (2.0 * yy);
   RETURN Kw.betainc__1(dfx / 2.0, dfx / 2.0, zz);
FUNC_END

FUNC DBL t_quantile__1(DBL dfx, DBL probx):
   # Quantile Students T distribution
   {SECANT_DECLARATIONS}
   IF NOT Kw.isbetween(probx, 0.0, 1.0):
      scvx_xx = 0.0;
   ELSE:
      {SECANT_LOOP 0.25 ; 0.5 ; probx - t_cdf(dfx, scvx_xx) }
   IF_END
   RETURN scvx_xx;
FUNC_END

FUNC DBL f_cdf(INT dfn_a, INT dfn_b, DBL xx):
   # CDF Fisher-Senecords Distribution
   DBL aa;
   DBL bb;
   DBL gg;

   aa = dfn_a / 2.0;
   bb = dfn_b / 2.0;
   gg = aa * xx;

   RETURN beta_cdf(aa, bb, gg / (bb + gg));
FUNC_END

BLOCK:
   BLOCK_DEF FUNC DBL lf_subfprob(INT dfn_a, INT dfn_b, DBL xx):
      DBL retvalu;
      DBL zx;
      DBL ax;
      DBL bx;
      DBL yx;
      DBL ix;
      DBL pp_a;

      IF xx <= 0.0:
         retvalu = 1.0;
      ELSIF Kw.iseven(dfn_b):
         zx = dfn_b / (dfn_b + dfn_a * xx);
         ax = 1.0;
         FOR ix FROM dfn_b - 2 TO 2 BY -2:
            ax = 1.0 + (dfn_a + ix - 2.0) / ix * zx * ax;
         FOR_END
         retvalu = 1.0 - (POW(1.0 - zx, dfn_a / 2.0) * ax);
      ELSIF Kw.iseven(dfn_a):
         zx = dfn_a * xx / (dfn_b + dfn_a * xx);
         ax = 1.0;
         FOR ix FROM dfn_a - 2 TO 2 BY -2:
            ax = 1.0 + (dfn_b + ix - 2.0) / ix * zx * ax;
         FOR_END
         retvalu = POW(1.0 - zx, dfn_b / 2.0) * ax;
      ELSE:
         yx = ATAN2(SQRT(dfn_a * xx / dfn_b), 1.0);
         zx = Kw.square(SIN(yx));
         IF dfn_a == 1:
            ax = 0.0;
         ELSE:
            ax = 1.0;
         IF_END
         FOR ix FROM dfn_a - 2 TO 3 BY -2:
            ax = 1.0 + (dfn_b + ix - 2.0) / ix * zx * ax;
         FOR_END
         bx = Kw.PI;
         FOR ix FROM 2 TO dfn_b - 1 BY 2:
            bx *= (ix - 1.0) / ix;
         FOR_END
         pp_a = 2.0 / bx * SIN(yx) * POW(COS(yx), dfn_b) * ax;

         zx = Kw.square(COS(yx));
         IF dfn_b == 1:
            ax = 0.0;
         ELSE:
            ax = 1.0;
         IF_END
         FOR ix FROM dfn_b - 2 TO 3 BY -2:
            ax = 1.0 + (ix - 1.0) / ix * zx * ax;
         FOR_END
         retvalu = pp_a + 1.0 - 4.0 * (yx + SIN(yx) * COS(yx) * ax) / Kw.TAU;
         IF retvalu < 0.0:
            retvalu = 0.0;
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END

   BLOCK_DEF FUNC DBL lf_subf_two(DBL nx, DBL qq, DBL pp):
      DBL uu;
      DBL nxs;
      DBL xx_prev;
      DBL xx;
      DBL zz;

      uu = chisqr_cdf(nx, pp);
      nxs = nx - 2.0;
      xx = (uu / nx * (1.0 + ((uu - nxs) / 2.0 + (((4.0 * uu - 11.0 * nxs)
               * uu + nxs * (7.0 * nx - 10.0)) / 24.0 + (((2.0 * uu
               - 10.0 * nxs) * uu + nxs * (17.0 * nx - 26.0)) * uu
               - nxs * nxs * (9.0 * nx - 6.0)) / 48.0 / qq) / qq) / qq));

      AWAIT Kw.iswithin(xx, xx_prev, 0.00001):
         IF xx <= 0.0:
            AWAIT_EXIT;
         IF_END
         zz = EXP(((nx + qq) * LN((nx + qq) / (nx * xx + qq))
                  + (nx - 2.0) * LN(xx) + LN(nx * qq / (nx + qq)) - Kw.TWOLN
                  - LN(Kw.TAU) - (1.0 / nx + 1.0 / qq - 1.0 / (nx + qq))
                  / 6.0) / 2.0);
         xx_prev = xx;
         xx += (lf_subfprob(nx, qq, xx) - pp) / zz;
      AWAIT_END
      RETURN xx;
   FUNC_END

   BLOCK_DEF FUNC DBL lf_subfx(INT nx, INT jj, DBL pp):
      DBL retvalu;
      DBL uu;
      DBL aa;

      IF Kw.iseq(pp, 1.0):
         retvalu = 0.0;
      ELSIF jj == 0:
         retvalu = 1.0 / Kw.square(t_quantile(nx
                  , 0.5 - pp / 2.0));
      ELSIF nx == 1:
         retvalu = Kw.square(t_quantile(jj, pp / 2.0));
      ELSIF jj == 2:
         uu = chisqr_cdf(jj, 1.0 - pp);
         aa = jj - 2.0;
         retvalu = 1.0 / (uu / jj * (1.0 + ((uu - aa) / 2.0
                  + (((4.0 * uu - 11.0 * aa) * uu
                  + aa * (7.0 * jj - 10)) / 24.0
                  + (((2.0 * uu - 10.0 * aa) * uu
                  + aa * (17.0 * jj - 26)) * uu
                  - aa * aa * (9.0 * jj - 6.0)) / 48.0 / nx) / nx) / nx));
      ELSIF jj < nx:
         retvalu = 1.0 / lf_subf_two(jj, nx, 1.0 - pp);
      ELSE:
         retvalu = lf_subf_two(nx, jj, pp);
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC DBL f_quantile(INT dfn_a, INT dfn_b, DBL probx):
      # Quantile Fisher-Senecords Distribution
      RETURN lf_subfx(dfn_a, dfn_b, 1.0 - probx);
   FUNC_END
BLOCK_END

FUNC DBL f_quantile__1(INT dfn_a, INT dfn_b, DBL probx):
   DBL retvalu;
   {SECANT_DECLARATIONS}

   IF probx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= probx:
      retvalu = 1.0;
   ELSE:
      {SECANT_LOOP 0.25 ; 0.50 ; probx - f_cdf(dfn_a, dfn_b, scvx_xx) }
      retvalu = scvx_xx;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL mb_pdf(DBL aa, DBL xx):
   # PDF Maxwell-Boltzmann distribution
   # distribution of particle speeds in an idealized gas
   RETURN SQRT(4 / Kw.TAU) * xx * xx
            * EXP(-xx * xx / (2 * aa * aa)) / (aa * aa * aa);
FUNC_END

FUNC DBL mb_cdf(DBL aa, DBL xx):
   # CDF Maxwell-Boltzmann distribution
   # MEAN = 2 * aa * SQRT(4 / TAU)
   # MODE = SQRT(2) * aa
   # VARIANCE = aa * aa * (3 - 16 / TAU)
   # Let aa = SQRT(BOLTZMANN * temperature / mass)
   # or     = SQRT(GAS * temperature / molar-mass)
   RETURN Kw.erf(xx / (Kw.TWOSQRT * aa)) - SQRT(4 / Kw.TAU) * xx
            * EXP(-xx * xx / (2 * aa * aa)) / aa;
FUNC_END

FUNC DBL maxwell_boltzmann_pdf(DBL temperature
         , DBL molecular_mass, DBL velocity):
   # PDF Maxwell-Boltzmann distribution
   # distribution of particle speeds in an idealized gas
   DBL aa;

   aa = SQRT(Kw.BOLTZMANN * temperature / molecular_mass);
   RETURN mb_pdf(aa, velocity);
FUNC_END

FUNC DBL maxwell_boltzmann_cdf(DBL temperature
         , DBL molecular_mass, DBL velocity):
   # CDF Maxwell-Boltzmann distribution
   # distribution of particle speeds in an idealized gas
   # Lat AA = sqrt(BOLTZMANN * TEMPERATURE / MASS)
   # MEAN     = 4 * AA / SQRT(TAU)
   # MODE     = AA * SQRT(2)
   # VARIANCE = AA**2 * (3 - 16 / TAU)
   DBL aa;

   aa = SQRT(Kw.BOLTZMANN * temperature / molecular_mass);
   RETURN mb_cdf(aa, velocity);
FUNC_END

FUNC DBL maxwell_juttner_pdf(DBL temperature
         , DBL molecular_mass, DBL velocity):
   # PDF Maxwell-Juttner distribution
   # distribution of speeds of particles in a hypothetical
   #    gas of relativistic particles.
   DBL gmm;
   DBL bt;
   DBL rtht;
   DBL dn;
   DBL retvalu;

   IF temperature <= 0.0 OR velocity <= 0.0 OR Kw.LIGHT <= velocity
            OR molecular_mass <= 0.0:
      retvalu = 0.0;
   ELSE:
      rtht = (molecular_mass * Kw.LIGHT * Kw.LIGHT)
               / (Kw.BOLTZMANN * temperature);
      bt = velocity / Kw.LIGHT;
      gmm = 1.0 / Kw.topyh1(bt);
      dn = Kw.bessKn(2, rtht);
      IF Kw.iszero(dn):
         retvalu = 0.0;
      ELSE:
         retvalu = gmm * gmm * bt * rtht * EXP(-gmm * rtht) / dn;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL blackbodyl_pdf(DBL wavelen):
   # PDF blackbody distribution over [0,Inf)
   # MODE   1 / (wp(-5 * exp(-5)) + 5) == 0.201405235272642
   DBL retvalu;

   IF wavelen <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = POW(wavelen, -5.0) / (EXP(1.0 / wavelen) - 1.0);
   IF_END

   RETURN retvalu * 15.0 / POW(Kw.PI, 4.0);
FUNC_END

FUNC DBL blackbodyf_pdf(DBL freq):
   # PDF blackbody distribution over [0,Inf)
   DBL retvalu;

   IF freq <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = POW(freq, 3.0) / (EXP(freq) - 1.0);
   IF_END

   RETURN retvalu * 15.0 / POW(Kw.PI, 4.0);
FUNC_END

FUNC INT ints_rand(INT para_nn, READONLY DBL prob_arr_pc[]):
   # random number in [0,PARA_NN) with
   #   p(MM) = PROB_ARR_PC[MM] / SUM(PROB_ARR_PC[])
   DBL sum;
   INT p_ind;
   DBL rndm;
   DBL hh;

   sum = 0.0;

   FOR p_ind FROM 0 TO para_nn - 1:
      sum += prob_arr_pc[p_ind];
   FOR_END
   rndm = randd();
   hh = 0.0;
   FOR p_ind FROM 0 TO para_nn - 1:
      hh += prob_arr_pc[p_ind] / sum;
      IF rndm < hh:
         FOR_EXIT;
      IF_END
   FOR_END
   RETURN p_ind;
FUNC_END

#TEST: normal_pdf(1) == 0.2419707245191433497978;
#TEST: normal_cdf(0) == 0.5;
#TEST: normal_cdf(1) == 0.84134474606854294858523254563203792248;
#TEST: normal_cdf(2) == 0.9772498680518207927997;
#TEST: normal_quantile(normal_cdf(1.34)) == 1.34;
#TEST: normal_quantile(0.5)-0.0;
#TEST: normal_quantile(0.8413447460685429485852) == 1.0;
#TEST: normal_quantile(0.9772498680518207927997) == 2.0;
#TEST: t_cdf(3,1) == 0.8044988905221146790445;
#TEST: t_quantile(3, 0.8044988905221146790445) == 1;
#TEST: t_quantile__1(3, 0.8044988905221146790445) == 1;
#TEST: f_cdf(2,3,1.4) == 0.6280026109165123031128;
#TEST: f_quantile(2, 3, 0.6280026109165123031128) == 1.4;
#TEST: pareto_quantile(1.3,2.4, pareto_cdf(1.3,2.4,3.5)) == 3.5;
#TEST: geo_pdf(0.2,3) == 0.1024;
#TEST: geo_cdf(0.2,7) == 0.83222784;
#TEST: nbd_pdf(0.6,5,5) == 0.1003290624;
#TEST: nbd_cdf(0.6,5,3) == 0.5940864;

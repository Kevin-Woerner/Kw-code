#    Copyright (C) 2015-2021 by Kevin D. Woerner
# 2021-05-11 kdw  recursion removal
# 2021-04-21 kdw  var name change
# 2021-04-20 kdw  var name change (mainly mm)
# 2021-04-15 kdw  indent work
# 2021-04-10 kdw  indent work
# 2021-03-25 kdw  upped line length
# 2021-03-14 kdw  const name renam
# 2021-02-26 kdw  fwip syntax debugging
# 2021-02-13 kdw  minor change
# 2021-02-04 kdw  add spaces to test lines
# 2021-02-01 kdw  bool syntax debugging
# 2021-01-15 kdw  const renamd
# 2020-12-08 kdw  explicit module on consts
# 2020-11-28 kdw  macro syntax overhaul
# 2020-11-10 kdw  n2[p]rimish II
# 2020-10-03 kdw  s/print_.*/.*_print/
# 2020-09-22 kdw  var renam
# 2020-09-10 kdw  kevy func III
# 2020-09-07 kdw  kevy func II
# 2020-09-06 kdw  kevy func
# 2020-08-20 kdw  boolean checks changed
# 2020-08-19 kdw  comment change
# 2020-08-17 kdw  macro syntax changed
# 2020-08-12 kdw  allow args <0 in znorder
# 2020-08-02 kdw  var renam g[d]
# 2020-07-29 kdw  block-def work
# 2020-07-27 kdw  block syntax
# 2020-07-25 kdw  s/BITWISE/BIT/
# 2020-07-24 kdw  s/LO[C]AL_/BL[O]CK_/
# 2020-07-10 kdw  prim[e]nth__1 func
# 2020-07-08 kdw  practical number check
# 2020-07-02 kdw  test modified
# 2020-07-01 kdw  tests modified
# 2020-06-30 kdw  tests changed
# 2020-06-29 kdw  BC:prim[e]nth problem
# 2020-06-22 kdw  local-use mved befroe var decls
# 2020-06-19 kdw  comments added
# 2020-06-18 kdw  rmed unused func
# 2020-06-17 kdw  modulo parens
# 2020-06-15 kdw  repete[n]dlen func
# 2020-06-08 kdw  integral function stuff
# 2020-06-06 kdw  comment change
# 2020-06-03 kdw  another test
# 2020-05-30 kdw  CONST syntax change
# 2020-05-18 kdw  while condition change
# 2020-05-16 kdw  comment change
# 2020-05-13 kdw  comment trivially changed
# 2020-05-11 kdw  REPL[A]CE replaced with LO[C]AL_CO[N]ST
# 2020-05-08 kdw  primitive root work
# 2020-05-07 kdw  func rearranged
# 2020-05-06 kdw  rmed boolean vars
# 2020-04-30 kdw  forever loop changed
# 2020-04-29 kdw  block work
# 2020-04-28 kdw  tweaks here and there
# 2020-04-26 kdw  bison work
# 2020-04-23 kdw  const format change
# 2020-04-17 kdw  gcd rework
# 2020-04-15 kdw  mertens rework
# 2020-04-14 kdw  tests added
# 2020-04-13 kdw  numeric inequality work
# 2020-04-12 kdw  comment change
# 2020-04-10 kdw  comment change
# 2020-04-09 kdw  MO[D]E syntax change
# 2020-04-08 kdw  preprocess sigil change
# 2020-04-04 kdw  n2pr[i]mish
# 2020-03-31 kdw  LA[B]S renam
# 2020-03-26 kdw  l[i]x tests
# 2020-03-25 kdw  tests
# 2020-03-09 kdw  LO[C]AL_.* keywords
# 2020-03-08 kdw  PR[I]NTVAL change
# 2020-03-06 kdw  L[A]NG.* names
# 2020-03-05 kdw  TRU[E]VAL into TR[U]E; FALS[E]VAL into FA[L]SE
# 2020-03-03 kdw  commment change; lang diff simplified
# 2020-03-02 kdw  rmed unused pfn_.* funcs
# 2020-03-01 kdw  rmed useless semicolons
# 2020-02-24 kdw  function comments
# 2020-02-11 kdw  lambda to carmichael for python
# 2020-02-03 kdw  car[m]ichael_lam[b]da to lam[b]da
# 2020-01-31 kdw  var renam; lambda improvemants
# 2020-01-28 kdw  work on funcs w/ array args
# 2020-01-27 kdw  primecount.* reorg
# 2020-01-24 kdw  func.* Woerner
# 2020-01-21 kdw  prim[e]nth fixed
# 2020-01-20 kdw  isprime work
# 2020-01-18 kdw  .*prim[e]nth() work
# 2020-01-14 kdw  dlog.* funcs
# 2020-01-09 kdw  bk(bn) funcs
# 2020-01-08 kdw  cantorial work II
# 2020-01-07 kdw  cantorial work
# 2020-01-04 kdw  cantorx ternary funciton
# 2020-01-02 kdw  cantor ternary funciton
# 2019-12-31 kdw  minkowski ?()
# 2019-12-27 kdw  eplicit K[w] module
# 2019-12-26 kdw  module name addded to funcs
# 2019-12-06 kdw  rmed some useless comments
# 2019-12-03 kdw  fixed comment in factorize
# 2019-12-02 kdw  is[s]quar[e]fr[e]e
# 2019-11-17 kdw  include Macros file
# 2019-11-05 kdw  l prefxd to some abs
# 2019-10-29 kdw  [OE]GF comments
# 2019-10-28 kdw  GF comments
# 2019-10-04 kdw  comment change
# 2019-09-19 kdw  rmed li function (still have lix)
# 2019-09-17 kdw  rmed c[n]v_dbl]2i32
# 2019-09-12 kdw  mod.* funcs; rmed pfn
# 2019-09-10 kdw  LAN[G]UAGE NOT to LAN[G]UAGE_N[O]T
# 2019-09-06 kdw  comments in chebyshev polys
# 2019-08-29 kdw  typo in func e[t]a
# 2019-08-24 kdw  for and count loops have from clause
# 2019-08-18 kdw  B[O]OL to B[O]L
# 2019-08-17 kdw  L[O]G to LN
# 2019-08-11 kdw  language comments
# 2019-08-06 kdw  rmed backshlashes, macro arg renam
# 2019-07-08 kdw  trii[n]v
# 2019-07-03 kdw  var renam "s/ind/_ind/;s/__ind/_ind/"
# 2019-06-26 kdw  eta function rewrite
# 2019-06-02 kdw  func desc added
# 2019-05-31 kdw  NR_DO to RAPHSON_LOOP; et al
# 2019-05-29 kdw  comment changed
# 2019-05-24 kdw  array var renam
# 2019-05-21 kdw  a to the n mod p func nn made dbl
# 2019-05-16 kdw  loop limit def mved
# 2019-05-01 kdw  consts explicit module name
# 2019-03-19 kdw  re[t]_val to re[t]valu
# 2019-03-18 kdw  macro syntax changed
# 2019-03-08 kdw  is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  loop limit changed
# 2019-03-01 kdw  writeable keyword
# 2019-01-12 kdw  lu[c]as.* funcs
# 2019-01-03 kdw  Await counter changed
# 2018-11-29 kdw  upper cased fwip defined funcs
# 2018-10-26 kdw  pfn; renam s/lpf/pfl/,s/gpf/pfg/
# 2018-10-08 kdw  vbdotnet stuff
# 2018-09-26 kdw  var renam
# 2018-09-16 kdw  func renam
# 2018-09-08 kdw  li[x]inv/SE[C]ANT work
# 2018-09-03 kdw  primeprev, primenext funcs
# 2018-07-28 kdw  l[c]antim func
# 2018-07-26 kdw  lc[a]ntim func
# 2018-07-17 kdw  private lf_.* funcs
# 2018-07-16 kdw  l[c]am funcfibo
# 2018-06-13 kdw  mved tests
# 2018-06-09 kdw  mved tests
# 2018-06-08 kdw  more test values
# 2018-06-04 kdw  test values
# 2018-05-31 kdw  factor var renam
# 2018-05-30 kdw  factor rework
# 2018-05-28 kdw  .*_() functions
# 2018-05-26 kdw  Mertens function
# 2018-05-22 kdw  trivial syntax error
# 2018-05-18 kdw  l[i] function loop limit
# 2018-05-14 kdw  BL[O]CK syntax change
# 2018-04-03 kdw  rm () from return
# 2018-04-01 kdw  LAN[G]UAGE_E[N]D
# 2018-03-26 kdw  macro redef
# 2018-02-19 kdw  secant and macro refactor
# 2018-02-16 kdw  e[t]a refactor
# 2017-11-26 kdw  FR[O]M and B[Y] keywords
# 2017-11-22 kdw  var renam
# 2017-11-21 kdw  FR[O]M
# 2017-10-23 kdw  lang is any fix
# 2017-10-21 kdw  macros start with "at""at"
# 2017-10-20 kdw  SEC[A]NT syntax change
# 2017-08-30 kdw  s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-27 kdw  comment change
# 2017-08-22 kdw  comment change
# 2017-08-20 kdw  rmed/renamd .*_P[E]R_.* vars
# 2017-06-21 kdw  LAN[G].* AND MA[S]TER.* change
# 2017-05-30 kdw  appro[x]pn
# 2017-05-15 kdw  polycnum, tetra[c]num
# 2017-05-13 kdw  polynum, tri
# 2017-04-21 kdw  func to function
# 2017-04-11 kdw  long lines
# 2017-04-10 kdw  partition memoized
# 2017-03-30 kdw  comment cleanup
# 2017-03-17 kdw  space after comma
# 2017-03-12 kdw  shorten long comments
# 2017-03-10 kdw  get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  INS[E]RT etal
# 2017-03-06 kdw  sigils rmed
# 2017-03-01 kdw  var[y]log-a[d]d space messup
# 2017-02-28 kdw  REQ[U]IRE function ()
# 2017-02-24 kdw  array var renam
# 2017-02-20 kdw  var renam
# 2017-02-19 kdw  Li redef
# 2017-02-14 kdw  FWIP Loop syntax changed
# 2017-02-13 kdw  FWIP language change
# 2017-02-12 kdw  FWIP language change
# 2017-02-08 kdw  SE[C]ANT stuff; syntax error in Li
# 2017-02-07 kdw  SE[C]ANT stuff
# 2017-02-06 kdw  SE[C]ANT / CO[U]NT syntax
# 2017-02-03 kdw  SE[C]ANT stuff
# 2017-01-06 kdw  ..LAN[G]_[U]AGE_[I]F deprecated
# 2016-12-30 kdw  ipow to powi
# 2016-12-28 kdw  handle uppercase funcs in fw[i]pp
# 2016-12-20 kdw  indent "?" lines
# 2016-12-01 kdw  rmed L[I]2
# 2016-11-27 kdw  long lines
# 2016-11-23 kdw  C[N]ST to REA[D]ONLY
# 2016-11-22 kdw  fixed [l]i
# 2016-11-21 kdw  D[F]to FU[N]C
# 2016-11-20 kdw  language change
# 2016-11-19 kdw  isp[r]ime
# 2016-11-15 kdw  M[O]D/B[I]T* syntax change
# 2016-11-14 kdw  comment cleanup
# 2016-11-11 kdw  sec[a]nt algorithm refactor
# 2016-11-09 kdw  more AW[A]IT loops
# 2016-10-31 kdw  AW[A]IT
# 2016-10-30 kdw  EX[I]TL[O]OP
# 2016-10-28 kdw  comment reorder
# 2016-10-14 kdw  _p
# 2016-10-03 kdw  isp[r]ime algorithm
# 2016-09-27 kdw  pcf new algorithm
# 2016-09-26 kdw  pcf debugged
# 2016-09-25 kdw  pcf
# 2016-09-22 kdw  eulerphi
# 2016-09-21 kdw  comment change
# 2016-09-15 kdw  comment change
# 2016-09-14 kdw  lang change
# 2016-09-08 kdw  eta tweak
# 2016-09-06 kdw  eta tweak
# 2016-09-02 kdw  tweak
# 2016-09-01 kdw  li, Lix
# 2016-04-27 kdw  _[_]BL[O]CK* change
# 2016-03-03 kdw  fixed problem in fa[c]tor; get_factor
# 2015-12-31 kdw  bounded (possible) infinite loops
# 2015-12-30 kdw  isdblequal renamed
# 2015-12-28 kdw  variable renamed; requires tweaked
# 2015-12-14 kdw  array sigils
# 2015-12-07 kdw  ism[u]ltl
# 2015-11-17 kdw  block comments
# 2015-11-12 kdw  change long line
# 2015-10-19 kdw  LA[B]S
# 2015-10-13 kdw  ato[t]henm[o]dx
# 2015-10-12 kdw  fi[b]ox
# 2015-10-11 kdw  fi[b]oinv ; fixed fi[b]o3
# 2015-09-30 kdw  use ip[o]w function
# 2015-09-29 kdw  layout tweak
# 2015-09-25 kdw  B[I]T*, M[O]D format change
# 2015-09-24 kdw  bit ops changed
# 2015-09-22 kdw  _[_]* format changed
# 2015-09-21 kdw  BC:modulus problem
# 2015-09-20 kdw  created

{INSERT_FILE "Macros.fwip" }

FUNC INT powi(INT xx, INT nn):
   # XX**NN (assumes 0 < nn)
   INT pp;
   INT xsq;

   pp = 1;
   xsq = xx;
   WHILE 0 < nn:
      IF Kw.isodd(nn):
         pp *= xsq;
      IF_END
      xsq *= xsq;
      nn = BITSHIFTR(nn, 1);
   WHILE_END
   RETURN pp;
FUNC_END
#TEST:powi(3,5) - 243;

FUNC INT atothenmodp(INT naa, INT nn, INT pp):
   # NAA to NN modulo PP
   INT retvalu;
   INT cc;

   MODE_INTEGER:
      IF pp == 0:
         retvalu = 0;
      ELSE:
         IF pp < 0:
            pp = -pp;
         IF_END
         IF nn < 0:
            nn = nn % pp;
            IF nn < 0:
               nn += pp;
            IF_END
         IF_END
         retvalu = 1;
         cc = naa % pp;
         WHILE 0 < nn:
            IF Kw.isodd(nn):
               retvalu = (retvalu * cc) % pp;
               nn = (nn - 1) / 2;
            ELSE:
               nn /= 2;
            IF_END
            cc = (cc * cc) % pp;
         WHILE_END
      IF_END
   MODE_INTEGER_END

   RETURN retvalu;
FUNC_END
#TEST:atothenmodp(2,10,100) - 24;

FUNC DBL atothenmodx(DBL xaa, DBL xnn, DBL xpp):
   # xAA**xNN mod xPP
   RETURN Kw.frac(EXP(xnn * LN(xaa) - LN(xpp))) * xpp;
FUNC_END
#TEST:atothenmodx(3.14,10,10) == 4.37338664347031806976;
#TEST:atothenmodx(TAU,10,10) == 0.61550901347708589074935740993;

FUNC INT ctz(INT nn):
   # Number of trailing 0s in binary expansion of NN
   #    OR number of 2s in factorization of NN
   INT zero_count;
   zero_count = 0;
   WHILE 0 == BITAND(nn, 1):
      zero_count += 1;
      nn = BITSHIFTR(nn, 1);
   WHILE_END
   RETURN zero_count;
FUNC_END
#TEST:ctz(24) - 3;

FUNC INT gcd(INT naa, INT nbb):
   # GCD of NAA and NBB
   INT cc;

   MODE_INTEGER:
      naa = ABSL(naa);
      nbb = ABSL(nbb);
      IF nbb <= 0:
         nbb = naa;
      ELSE:
         WHILE 0 < naa:
            cc = naa;
            naa = nbb % naa;
            nbb = cc;
         WHILE_END
      IF_END
   MODE_INTEGER_END
   RETURN nbb;
FUNC_END
#TEST:gcd(70,168) - 14;

FUNC INT gcda(INT array_count, READONLY INT num_arr_pc[]):
   # GCD of all numbers in NUM_ARR_PC
   INT ind;
   INT gc;

   gc = num_arr_pc[0];
   FOR ind FROM 1 TO array_count - 1:
      gc = gcd(gc, num_arr_pc[ind]);
   FOR_END
   RETURN gc;
FUNC_END

FUNC INT lcm(INT naa, INT nbb):
   # LCM of NAA and NBB
   RETURN naa * nbb / gcd(naa, nbb);
FUNC_END
#TEST:lcm(20,24) - 120;

FUNC INT lcam(INT naa, INT nbb):
   # LC Almost M of NAA and NBB I.E. minimal integer JJ > 1 such that
   #    JJ mod NAA = -1, 0, or 1 AND
   #    JJ mod NBB = -1, 0, or 1.
   INT ii;
   INT jj;

   IF nbb < naa:
      ii = naa;
      naa = nbb;
      nbb = ii;
   IF_END

   AWAIT -2 <= jj AND jj <= 2 COUNT ii FROM nbb BY nbb:
      jj = mods(ii, naa);
   AWAIT_END

   IF jj == -2:
      ii += 1;
   ELSIF 0 <= jj:
      ii -= 1;
   IF_END

   RETURN ii;
FUNC_END

FUNC INT lcams(INT naa, INT nbb):
   # strict LC Almost M of NAA and NBB I.E. minimal integer JJ such that
   #    MAX(NAA,NBB) < JJ
   #    JJ mod NAA = -1, 0, or 1 AND
   #    JJ mod NBB = -1, 0, or 1
   INT ii;
   INT jj;

   IF nbb < naa:
      ii = naa;
      naa = nbb;
      nbb = ii;
   IF_END

   AWAIT -2 <= jj AND jj <= 2 COUNT ii FROM 2 * nbb BY nbb:
      jj = mods(ii, naa);
   AWAIT_END

   IF jj == -2:
      ii += 1;
   ELSIF 0 <= jj:
      ii -= 1;
   IF_END

   RETURN ii;
FUNC_END

FUNC INT lcantim(INT naa, INT nbb):
   # LC Anti M of odd numbers NAA and NBB
   INT hnaa;
   INT hnbb;
   INT ii;
   INT rema;
   INT odd_mask;

   IF Kw.isposint(naa) AND Kw.isposint(nbb):
      odd_mask = 0;
      IF Kw.isodd(naa):
         odd_mask = 1;
      IF_END
      IF Kw.isodd(nbb):
         odd_mask += 2;
      IF_END

      IF 2 == odd_mask OR (nbb < naa AND odd_mask <> 1):
         ii = nbb;
         nbb = naa;
         naa = ii;
      IF_END

      hnaa = FLOORL(naa / 2);
      hnbb = FLOORL(nbb / 2);
      ii = hnbb;
      AWAIT naa * nbb <= ii:
         rema = Kw.dist(ii, naa);
         IF rema == hnaa:
            AWAIT_EXIT;
         ELSIF odd_mask == 3 AND rema == hnaa + 1:
            AWAIT_EXIT;
         IF_END

         ii += nbb;
      AWAIT_END

      IF naa * nbb <= ii:
         ii = 0;
      IF_END
   ELSE:
      ii = 0;
   IF_END
   RETURN ii;
FUNC_END

FUNC INT factor(INT number_to_factor, WRITEONLY INT ret_fctr_arr_p[]):
   # factorize NUMBER_TO_FACTOR into RET_FCTR_ARR_P[]
   # return NPF, number of prime factors
   # places 0 into RET_FCTR_ARR_P[NPF]
   INT pp;
   INT fctr_ind;
   INT inc;

   MODE_INTEGER:
      fctr_ind = 0;
      number_to_factor = ABSL(number_to_factor);
      IF number_to_factor <= 3:
         ret_fctr_arr_p[fctr_ind] = number_to_factor;
         fctr_ind = 1;
      ELSE:
         FOR pp FROM 2 TO 3:
            WHILE 0 == number_to_factor % pp:
               ret_fctr_arr_p[fctr_ind] = pp;
               fctr_ind += 1;
               number_to_factor /= pp;
            WHILE_END
         FOR_END

         pp = 1;
         inc = 4;
         AWAIT number_to_factor < pp * pp:
            pp += inc;
            inc = 6 - inc;
            WHILE 0 == number_to_factor % pp:
               ret_fctr_arr_p[fctr_ind] = pp;
               fctr_ind += 1;
               number_to_factor /= pp;
            WHILE_END
         AWAIT_END
         IF 1 < number_to_factor:
            ret_fctr_arr_p[fctr_ind] = number_to_factor;
            fctr_ind += 1;
         IF_END
      IF_END
   MODE_INTEGER_END
   ret_fctr_arr_p[fctr_ind] = 0;

   RETURN fctr_ind;
FUNC_END

FUNC INT modulo(INT nxx, INT modyy):
   # return ZZ in [0,ABS(MODYY)) such that ZZ = NXX mod MODYY
   INT retvalu;

   MODE_INTEGER:
      retvalu = nxx % modyy;
      IF retvalu < 0:
         retvalu += ABSL(modyy);
      IF_END
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END

FUNC INT mods(INT nxx, INT modyy):
   # return ZZ in [-ABS(MODYY)/2,ABS(MODYY)/2] such that ZZ = NXX mod MODYY
   INT retvalu;
   INT amodyy;
   INT anxx;

   MODE_INTEGER:
      amodyy = FLOORL(ABSL(modyy));
      anxx = ABSL(nxx);

      retvalu = anxx % amodyy;

      IF 0 < retvalu:
         WHILE amodyy < 2 * retvalu:
            retvalu -= amodyy;
         WHILE_END
      ELSIF retvalu < 0:
         WHILE 2 * retvalu < -amodyy:
            retvalu += amodyy;
         WHILE_END
      IF_END
   MODE_INTEGER_END

   RETURN retvalu;
FUNC_END

FUNC INT pfl(INT nn):
   # Least Prime Factor of NN
   INT small_factor;
   INT lim;
   INT divid;
   MODE_INTEGER:
      IF nn < 2:
         small_factor = 1;
      ELSIF nn % 2 == 0:
         small_factor = 2;
      ELSIF nn % 3 == 0:
         small_factor = 3;
      ELSIF nn % 5 == 0:
         small_factor = 5;
      ELSIF nn % 7 == 0:
         small_factor = 7;
      ELSE:  # NN has no factors < 11
         lim = FLOORL(SQRT(nn));
         divid = 11;
         small_factor = nn;
         WHILE divid <= lim:
            IF nn % divid == 0:
               small_factor = divid;
               WHILE_EXIT;
            IF_END
            divid += 2;
            IF nn % divid == 0:
               small_factor = divid;
               WHILE_EXIT;
            IF_END
            divid += 4;
         WHILE_END
      IF_END
   MODE_INTEGER_END
   RETURN small_factor;
FUNC_END
#TEST:pfl(11 * 17 * 23) - 11;

FUNC INT pfg(INT nn):
   # Greatest prime factor
   INT jj;
   INT ii;

   jj = nn;
   AWAIT jj == 1:
      ii = pfl(jj);
      jj /= ii;
   AWAIT_END
   RETURN ii;
FUNC_END
#TEST:pfg(11 * 17 * 23) - 23;

FUNC BOL isprime(INT nn):
   # True iff ABS(NN) is prime
   BOL retvalu_bol;
   INT ann;

   ann = ABSL(nn);

   IF ann == 2 OR ann == 3 OR ann == 5 OR ann == 7:
      retvalu_bol = TRUE; # NN is 2,3,5,7
   ELSIF ann < 11:
      retvalu_bol = FALSE; # NN is 1,4,6,8,9,10
   ELSIF pfl(ann) == ann:
      retvalu_bol = TRUE; # 11 <= NN and prime
   ELSE:
      retvalu_bol = FALSE; # 11 <= NN and not prime
   IF_END
   RETURN retvalu_bol;
FUNC_END

BLOCK:   # Prime next / prev funcs
   BLOCK_DEF FUNC INT lf_primeprev(INT pp):
      # largest prime less than PP for non-negative PP
      INT retvalu;
      INT rema;
      INT inc;
      INT qq;

      MODE_INTEGER:
         IF pp <= 7:
            IF 5 < pp:
               retvalu = 5;
            ELSIF 3 < pp:
               retvalu = 3;
            ELSIF 2 < pp:
               retvalu = 2;
            ELSE:
               retvalu = -2;
            IF_END
         ELSE:
            rema = pp % 6;
            qq = pp - rema; # qq <= pp
            IF rema <= 1:
               qq -= 1; # now qq == 5 mod 6
               inc = 4;
            ELSE:
               qq += 1; # now qq == 1 mod 6
               inc = 2;
            IF_END
            WHILE NOT Kw.isprime(qq):
               qq -= inc;
               inc = 6 - inc;
            WHILE_END
            retvalu = qq;
         IF_END
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END

   BLOCK_DEF FUNC INT lf_primenext(INT pp):
      # smallest prime more than PP for non-negative PP
      INT retvalu;
      INT rema;
      INT inc;
      INT qq;

      MODE_INTEGER:
         IF pp < 7:
            IF pp < 2:
               retvalu = 2;
            ELSIF pp < 3:
               retvalu = 3;
            ELSIF pp < 5:
               retvalu = 5;
            ELSE:
               retvalu = 7;
            IF_END
         ELSE:
            rema = (pp + 1) % 6;
            qq = (pp + 1) - rema;
            IF rema <= 1:
               qq += 1; # Now qq == 1 mod 6
               inc = 4;
            ELSE:
               qq += 5; # Now qq == 5 mod 6
               inc = 2;
            IF_END
            WHILE NOT Kw.isprime(qq):
               qq += inc;
               inc = 6 - inc;
            WHILE_END
            retvalu = qq;
         IF_END
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END

   FUNC INT primeprev(INT pp):
      # largest prime less than PP
      INT retvalu;

      IF 0 <= pp:
         retvalu = lf_primeprev(pp);
      ELSE:
         retvalu = -lf_primenext(-pp);
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC INT primenext(INT pp):
      # smallest prime greater than PP
      INT retvalu;

      IF 0 <= pp:
         retvalu = lf_primenext(pp);
      ELSE:
         retvalu = -lf_primeprev(-pp);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END   # Prime next / prev funcs
#TEST:primeprev(37) - 31;
#TEST:primenext(24) - 29;

BLOCK: # Prime count
   BLOCK_DEF INT lv_pcf_end = 0;
   BLOCK_DEF DBL lv_pcf_arr[0];
   FUNC INT primecount(DBL xx):
      # Prime Counting Function == number of primes <= XX using memoization
      BLOCK_USE lv_pcf_arr[];
      BLOCK_USE lv_pcf_end;
      INT retvalu;
      INT poss_prime;
      INT s_ind;
      INT ps_ind;
      INT pcf_val;

      MODE_INTEGER:
         IF xx < 7:
            IF xx < 3:
               IF xx < 2:
                  retvalu = 0;
               ELSE:
                  retvalu = 1;
               IF_END
            ELSE:
               IF xx < 5:
                  retvalu = 2;
               ELSE:
                  retvalu = 3;
               IF_END
            IF_END
         ELSE:  # 7 <= xx
            s_ind = FLOORL((xx - 5) / 2) - FLOORL((xx - 3) / 6);
            # 5 <= XX forces 0 <= S_IND
            IF lv_pcf_end <= s_ind:
               # LV_PCF_END should be even, but lets be safe
               ps_ind = lv_pcf_end;
               IF lv_pcf_end <= 0:
                  pcf_val = 2;
               ELSE:
                  pcf_val = lv_pcf_arr[lv_pcf_end - 1];
               IF_END
               lv_pcf_end = Kw.ceil2(s_ind + 1, 2);
               REDIM lv_pcf_arr[], lv_pcf_end;
               # LV_PCF_END should be even, hence so will PS_IND,
               # but lets be safe
               poss_prime = 3 * ps_ind - (ps_ind % 2) + 5;
               WHILE ps_ind <= s_ind:
                  IF Kw.isprime(poss_prime): # 5 mod 6
                     pcf_val += 1;
                  IF_END
                  lv_pcf_arr[ps_ind] = pcf_val;
                  poss_prime += 2;
                  ps_ind += 1;
                  # PS_IND is now odd
                  IF Kw.isprime(poss_prime): # 1 mod 6
                     pcf_val += 1;
                  IF_END
                  lv_pcf_arr[ps_ind] = pcf_val;
                  poss_prime += 4;
                  ps_ind += 1;
                  # PS_IND is now even
               WHILE_END
            IF_END
            retvalu = lv_pcf_arr[s_ind];
         IF_END
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
BLOCK_END # Prime count
#TEST:primecount(10000) - 1229;

FUNC INT pcf(DBL xx):
   # another name for prime counting function
   RETURN primecount(xx);
FUNC_END
#TEST:pcf(1000) - 168;

FUNC INT primecountx(DBL xx):
   # Prime Counting Function == number of primes <= XX
   INT retvalu;
   INT poss_prime;
   INT inc;
   INT pcf_val;

   IF xx < 7:
      IF xx < 3:
         IF xx < 2:
            retvalu = 0;
         ELSE:
            retvalu = 1;
         IF_END
      ELSE:
         IF xx < 5:
            retvalu = 2;
         ELSE:
            retvalu = 3;
         IF_END
      IF_END
   ELSE:  # 7 <= xx
      pcf_val = 4;
      poss_prime = 11;
      inc = 2;
      WHILE poss_prime <= xx:
         IF Kw.isprime(poss_prime):
            pcf_val += 1;
         IF_END
         poss_prime += inc;
         inc = 6 - inc;
      WHILE_END
      retvalu = pcf_val;
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL eta(DBL xx):
   # Dirichlets eta function (alternating zeta) for real args
   #    1/1**XX - 1/2**XX + 1/3**XX - 1/4**XX + 1/5**XX ...
   DBL sum;
   DBL sump;
   INT tt;
   INT nn;
   INT kk;
   INT s_ind;
   DBL retvalu;
   DBL pm_one;
   DBL ps_arr[];
   DBL temp_arr[];
   DBL term;

   IF 0 < xx:
      tt = 0;
      term = -LN(Kw.DBLEPS) / xx;
      IF term < LN(4000):
         kk = CEILL(EXP(term));
         sum = 0;
         pm_one = -1.0;
         AWAIT Kw.iseq(sump, sum) COUNT nn FROM 1 TO kk:
            pm_one = -pm_one;
            term = pm_one * POW(nn, -xx);
            tt += 1;
            sump = sum;
            sum += term;
         AWAIT_END
         retvalu = sum - 0.5 * term;
      ELSE:
         # use Eulers transformation of alternating series
         sum = 0;
         pm_one = -1.0;
         REDIM ps_arr[], 402;
         REDIM temp_arr[], 402;
         ps_arr[0] = -POW(2, -xx);
         tt += 1;
         temp_arr[0] = ps_arr[0];
         AWAIT Kw.iseq(sump, sum) COUNT nn FROM 1 TO 400:
            pm_one = -pm_one;
            ps_arr[nn] = ps_arr[nn - 1] + pm_one * POW(nn + 2, -xx);
            tt += 1;
            temp_arr[nn] = ps_arr[nn];
            FOR kk FROM nn - 1 TO 0 BY -1:
               temp_arr[kk] = (temp_arr[kk] + temp_arr[kk + 1]) / 2.0;
            FOR_END
            sump = sum;
            sum = temp_arr[0];
         AWAIT_END
         s_ind = FLOORL(nn / 3);
         sum = (4 * temp_arr[s_ind] + 3 * temp_arr[s_ind + 1]) / 7;
         REDIM temp_arr[];
         REDIM ps_arr[];
         retvalu = sum + 1.0;
      IF_END
   ELSIF xx < 0:
      retvalu = 0.0;
   ELSE:
      retvalu = 0.5;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:eta(2)    == PI*PI/12;
#TEST:eta(4)    == pow(PI,4)*7/720;
#TEST:eta(6)    == pow(PI,6)*31/30240;
#TEST:eta(8)    == pow(PI,8)*127/1209600;
#TEST:eta(10)   == pow(PI,10)*73/6842880;
#TEST:eta(12)   == pow(PI,12)*1414477/1307674368000;
#TEST:eta(1)    == ln(2);

FUNC DBL zeta(DBL xx):
   # Reimanns zeta function for real args
   #    1/1**XX + 1/2**XX + 1/3**XX + 1/4**XX + 1/5**XX ...
   DBL retvalu;

   IF 1 < xx:
      retvalu = eta(xx) / (1.0 - POW(2.0, 1.0 - xx));
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:zeta(2)      == PI*PI/6;
#TEST:zeta(3)      == APERY;
#TEST:zeta(4)      == PI*PI*PI*PI/90;

FUNC DBL fibo3(INT nn, DBL fib_a, DBL fib_b):
   # NNth Fibonacci-like number starting with FIB_A and FIB_B
   # OGF(fibo3(,a,b);x) = (x * (a - b) - a) / (x * x - x + 1)
   INT ii;
   DBL tt;
   DBL retvalu;

   IF nn == 0:
      retvalu = fib_a;
   ELSE:
      FOR ii FROM 2 TO nn:
         tt = fib_b;
         fib_b += fib_a;
         fib_a = tt;
      FOR_END
      retvalu = fib_b;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:fibo3(10, 2, 1) - 123;

FUNC DBL fibo(INT nn):
   # NNth Fibonacci number
   # OGF(fibo();x) = -x / (x * x + x - 1)
   RETURN fibo3(nn, 0, 1);
FUNC_END
#TEST:fibo(10) - 55;

FUNC DBL fibox(DBL xx):
   # NNth Fibonacci-like number, interpolated
   DBL zz;
   DBL retvalu;

   IF LN(Kw.DBLMAX) / LN(Kw.PHI) < ABS(xx):
      retvalu = 0.0;
   ELSE:
      zz = POW(Kw.PHI, xx);
      retvalu = (zz - COS(Kw.PI * xx) / zz) / SQRT(5.0);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL fiboxinv(DBL yy):
   # inverse of Fibonacci numbers
   # following points are on curve (x, fibox(x))
   #    (0.791621807914573, 0.896946387424606)
   #    (1.094576105145116, 1.009824331847821) local MAX
   #    (1.676688372662104, 0.896946387424606) local MIN
   #    (2.014889804296742, 1.009824331847821)
   # SO, between 0.896946387424606 and 1.009824331847821 fiboxinv is not
   #    uniquely defined.  This function tries to deliver smallest positive
   #    value; i.e
   #       fiboxinv(X) < 1.094576105145116
   #          for all X < 1.009824331847821
   {SECANT_DECLARATIONS}
   DBL x_init;

   IF yy <= 0:
      scvx_xx = 0.0;
   ELSE:
      IF yy <= 0.2:
         x_init = 0.075;
      ELSIF yy <= 0.896946387424606:
         x_init = 0.8 * yy - 0.15;
      ELSIF yy <= 1.009824331847821:
         x_init = 0.92;
      ELSE:
         x_init = LN(yy * SQRT(5.0)) / LN(Kw.PHI);
      IF_END

      {SECANT_LOOP x_init ; 0.05 ; yy - fibox(scvx_xx) }
   IF_END
   RETURN scvx_xx;
FUNC_END

FUNC DBL lucas(INT nn):
   # NNth Lucas number
   # OGF(lucas();x) = (x - 2) / (x * x + x - 1)
   RETURN fibo3(nn, 2, 1);
FUNC_END

FUNC DBL lucasx(DBL xx):
   # NNth Lucas-like number, interpolated
   DBL zz;
   DBL retvalu;

   IF LN(Kw.DBLMAX) / LN(Kw.PHI) < ABS(xx):
      retvalu = 0.0;
   ELSE:
      zz = POW(Kw.PHI, xx);
      retvalu = (zz + COS(Kw.PI * xx) / zz);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT fusc(INT nn):
   # Stern-Brocot sequence, defined recursively by
   #    fusc(1) = 1,
   #    fusc(2 * n) = fusc(n), and
   #    fusc(2 * n + 1) = fusc(n) + fusc(n + 1)
   INT naa;
   INT nbb;

   naa = 1;
   nbb = 0;
   WHILE 0 < nn:
      IF Kw.isodd(nn):
         nbb += naa;
      ELSE:
         naa += nbb;
      IF_END
      nn = BITSHIFTR(nn, 1);
   WHILE_END
   RETURN nbb;
FUNC_END
#TEST:fusc(10000) - 43;

FUNC DBL Tn(INT nn, DBL xx):
   # evaluate NNth Chebyshev polynomial at XX
   #    Tn(0,XX) = 1
   #    Tn(1,XX) = XX
   #    Tn(NN,XX) = 2 * XX * Tn(NN - 1, XX) - Tn(NN - 2, XX)
   # Tn(NN, COS(YY)) = COS(NN * YY)
   DBL retvalu;
   DBL tnm_a;
   DBL tnm_b;
   DBL tnn;
   INT kk;

   IF nn == 0:
      retvalu = 1.0;
   ELSIF nn == 1:
      retvalu = xx;
   ELSIF nn == 2:
      retvalu = 2.0 * xx * xx - 1.0;
   ELSE:
      tnm_a = 2.0 * xx * xx - 1.0;
      tnm_b = xx;
      tnn = tnm_a;
      FOR kk FROM 3 TO nn:
         tnn = (2.0 * xx * tnm_a) - tnm_b;
         tnm_b = tnm_a;
         tnm_a = tnn;
      FOR_END
      retvalu = tnn;
   IF_END

   RETURN retvalu;
FUNC_END
#TEST:Tn(6,0.4) == 0.782272;

FUNC DBL Un(INT nn, DBL xx):
   # evaluate NNth Chebyshev polynomial of type 2 at XX
   #    Un(0,XX) = 1
   #    Un(1,XX) = 2 * XX
   #    Un(NN,XX) = 2 * XX * Un(NN - 1, XX) - Un(NN - 2, XX)
   # Un(NN, COS(YY)) = SIN((NN + 1) * YY) / SIN(YY)
   DBL retvalu;
   DBL tnm_a;
   DBL tnm_b;
   DBL tnn;
   INT kk;

   IF nn == 0:
      retvalu = 1.0;
   ELSIF nn == 1:
      retvalu = 2.0 * xx;
   ELSE:
      tnm_a = 2.0 * xx;
      tnm_b = 1.0;
      tnn = tnm_a;
      FOR kk FROM 2 TO nn:
         tnn = (2.0 * xx * tnm_a) - tnm_b;
         tnm_b = tnm_a;
         tnm_a = tnn;
      FOR_END
      retvalu = tnn;
   IF_END

   RETURN retvalu;
FUNC_END
#TEST:Un(6,0.4) == 1.054144;

FUNC DBL tri(DBL nn):
   # NNth triangular number
   # OGF(tri();x) = x / (1 - x)**3
   RETURN nn * (nn + 1) / 2;
FUNC_END
#TEST:tri(10) - 55;

FUNC DBL triinv(DBL nn):
   # NNth triangular number inverse
   DBL retvalu;

   IF -0.125 < nn:
      retvalu = (SQRT(8.0 * nn + 1.0) - 1.0) / 2.0;
   ELSE:
      retvalu = -0.5;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:triinv(55) - 10;

FUNC DBL polynum(DBL ss, DBL nn):
   # NNth polygonal number with SS sides;
   RETURN (ss - 2) * nn * (nn - 1) / 2 + nn;
FUNC_END
#TEST:polynum(7,5) - 55;

FUNC DBL polycnum(DBL ss, DBL nn):
   # NNth central polygonal number with SS sides
   RETURN ss * nn * (nn - 1) / 2 + 1;
FUNC_END
#TEST:polycnum(7,5) - 71;

FUNC DBL tetranum(DBL ss, DBL nn):
   # NNth tetrahedral number
   RETURN nn * (nn + 1) * ((ss - 2) * nn + 5 - ss) / 6;
FUNC_END

FUNC DBL tetracnum(DBL ss, DBL nn):
   # NNth central tetrahedral number
   RETURN nn * (ss * nn * nn + 6 - ss) / 6;
FUNC_END

FUNC DBL minkowski(DBL xx):
   # Minkowski question-mark function ?(XX)
   # d?(XX)/dXX == 0 at rationals
   # If pp/qq and rr/ss are rational with ABS(pp*ss-rr*qq) == 1 Then
   #   ?((pp + rr) / (qq + ss)) = (?(pp/qq) + ?(rr/ss)) / 2
   # ?(0) = 0 and ?(1) = 1
   DBL pp;
   DBL qq;
   DBL rr;
   DBL ss;
   DBL ff;
   DBL gg;
   DBL dd;
   DBL yy;

   pp = FLOOR(xx);
   qq = 1;
   rr = pp + 1;
   ss = 1;
   dd = 1.0;
   yy = pp;
   AWAIT Kw.iseq(yy + dd, yy):
      dd /= 2.0;
      ff = pp + rr;
      gg = qq + ss;

      IF xx < ff / gg:
         rr = ff;
         ss = gg;
      ELSE:
         yy += dd;
         pp = ff;
         qq = gg;
      IF_END
   AWAIT_END
   RETURN yy;
FUNC_END

FUNC DBL cantorxx(DBL nbb, DBL ee, DBL xx):
   # Cantor ternary function / Devil Staircase
   DBL yy;
   DBL rest;
   DBL dd;
   DBL ulmt;

   IF ee < 0.0 OR nbb < 0.0 OR 1.0 < ee + nbb:
      yy = xx;
   ELSE:
      ulmt = 1.0 - ee;       # in (0,1]
      # point (NBB**N,0.5**N) and (NBB**N*(1-EE),0.5**N)
      #    are on the devil staircase for N = 0,1,2,3,4...
      yy = FLOOR(xx);
      rest = (xx - yy);
      dd = 0.5;
      AWAIT Kw.iseq(yy + dd, yy) OR Kw.iszero(rest):
         IF ulmt <= rest:
            yy += dd;
            rest = Kw.frac((rest - ulmt) / ee);
         ELSIF nbb <= rest:
            yy += dd;
            AWAIT_EXIT;
         ELSE:
            rest = Kw.frac(rest / nbb);
         IF_END
         dd /= 2.0;
      AWAIT_END
   IF_END

   RETURN yy;
FUNC_END

FUNC DBL cantor(DBL xx):
   # Cantor ternary function / Devil Staircase
   # cantor(XX) == cantorxx(1/3, 1/3, XX)
   RETURN cantorxx(1.0 / 3.0, 1.0 / 3.0, xx);
FUNC_END
#TEST:cantor(0.5) - 0.5;

FUNC DBL cantorul(DBL bb, DBL ee, DBL xx):
   # upper limit for Devil staircase
   # cantorxx(a,b,x)       <= cantorul(a,b,x) for x in [0,1]
   # 1 - cantorul(b,a,1-x) <= cantorxx(a,b,x) for x in [0,1]
   RETURN POW(0.5, LN(xx) / LN(bb) + 0.0 * ee);
FUNC_END

FUNC DBL cantorll(DBL bb, DBL ee, DBL xx):
   # lower limit for Devil staircase
   # cantorll(a,b,x) <= cantorxx(a,b,x)       for x in [0,1]
   # cantorxx(a,b,x) <= 1 - cantorll(b,a,1-x) for x in [0,1]
   RETURN POW(0.5, LN(xx / (1.0 - ee)) / LN(bb) + 1.0);
FUNC_END

FUNC INT dlogx(INT naa, INT nbb, INT nn):
   # Brute-force discrete logarithm
   # return 0 < KK where NAA**KK = NBB mod NN
   # return -1 if none found
   INT ii;
   INT pp;
   INT retvalu;

   MODE_INTEGER:
      pp = naa;
      retvalu = -1;
      FOR ii FROM 1 TO nn:
         IF pp == nbb:
            retvalu = ii;
            FOR_EXIT;
         IF_END
         pp = (pp * naa) % nn;
      FOR_END
   MODE_INTEGER_END

   RETURN retvalu;
FUNC_END

FUNC INT dlog(INT naa, INT nbb, INT nn):
   # find KK such that NAA**KK=NBB mod NN
   # THIS ASSUMES NAA IS A GENERATOR OF THE MULTIPLICATIVE GROUP OF INTEGER
   #    MODULO MM
   INT sqnn;
   INT cur;
   INT atothesqnn;
   INT atothens;
   INT ii;
   INT log_arr[];
   INT retvalu;

   MODE_INTEGER:
      IF naa == nbb:
         retvalu = 1;
      ELSIF naa <= 0 OR nbb <= 0 OR nn <= 0:
         retvalu = -1;
      ELSIF 1 < gcd(naa, nn):
         retvalu = dlogx(naa, nbb, nn);
      ELSIF NOT isprimitiveroot(naa, nn):
         retvalu = dlogx(naa, nbb, nn);
      ELSE:
         sqnn = CEILL(SQRT(nn));

         REDIM log_arr[], nn;
         FOR ii FROM 0 TO nn - 1:
            log_arr[ii] = 0;
         FOR_END

         atothesqnn = atothenmodp(naa, sqnn, nn);

         # Store all values of naa**(sqnn*ii) of LHS
         cur = atothesqnn;
         FOR ii FROM 1 TO sqnn:
            IF log_arr[cur] == 0:
               log_arr[cur] = ii;
            IF_END
            cur = (cur * atothesqnn) % nn;
         FOR_END

         cur = nbb % nn;
         retvalu = -1;
         FOR ii FROM 0 TO sqnn:
            # Calculate (naa ** ii) * nbb and check for collision
            IF 0 < log_arr[cur]:
               atothens = log_arr[cur] * sqnn - ii;
               IF atothens < nn:
                  retvalu = atothens;
                  FOR_EXIT;
               IF_END
            IF_END
            cur = (cur * naa) % nn;
         FOR_END
         REDIM log_arr[];
      IF_END
   MODE_INTEGER_END

   RETURN retvalu;
FUNC_END
#TEST:dlog(6, 2, 11) - 9;
#TEST:dlog(5, 2, 11) + 1;

FUNC INT dlog1(INT naa, INT nn):
   # return KK such that NAA**KK = 1 mod NN
   RETURN dlog(naa, 1, nn);
FUNC_END

BLOCK: # Mertens function
   BLOCK_DEF INT lv_mertens_end = 0;
   BLOCK_DEF INT lv_mertens_arr[0];
   FUNC INT mertens(INT nn):
      # sum of mobius function from 0 to NN
      # I.E. count of square-free integers up to NN that have an even number
      #    of prime factors minus count of those that have an odd number
      BLOCK_USE lv_mertens_arr[];
      BLOCK_USE lv_mertens_end;
      INT retvalu;
      INT kk;

      IF nn < 0:
         retvalu = 0;
      ELSE:
         IF lv_mertens_end <= 0:
            lv_mertens_end = 4;
            REDIM lv_mertens_arr[], lv_mertens_end;
            lv_mertens_arr[0] = 0;
            lv_mertens_arr[1] = 1;
            lv_mertens_arr[2] = 0;
            lv_mertens_arr[3] = -1;
         IF_END
         IF lv_mertens_end <= nn:
            kk = lv_mertens_end;
            lv_mertens_end = nn + 1;
            REDIM lv_mertens_arr[], lv_mertens_end;
            WHILE kk < lv_mertens_end:
               lv_mertens_arr[kk] = lv_mertens_arr[kk - 1] + mobius(kk);
               kk += 1;
            WHILE_END
         IF_END
         retvalu = lv_mertens_arr[nn];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END
#TEST:mertens(114) + 6;

FUNC BOL has_primitiveroot_f(INT array_size, READONLY INT fac_arr_pc[]):
   # factorization FAC_ARR_P[0..(ARRAY_SIZE - 1)] has a primitive root iff
   #          it is a power of a odd prime
   #       or twice a power of a odd prime
   INT ind;

   ind = 0;
   IF 1 < array_size:
      IF fac_arr_pc[0] == 2:
         ind += 1;
      IF_END
      IF 2 < fac_arr_pc[ind]:
         WHILE ind < array_size - 1:
            IF fac_arr_pc[ind] < fac_arr_pc[ind + 1]:
               WHILE_EXIT;
            IF_END
            ind += 1;
         WHILE_END
      IF_END
   IF_END
   RETURN ind == (array_size - 1);
FUNC_END
#TEST:has_primitiveroot(4) - iseven(4)
#TEST:has_primitiveroot(8) - isodd(8)

FUNC INT sigma0_f(INT array_size, READONLY INT fac_arr_pc[]):
   # count of divisors of factorization FAC_ARR_P[0..(ARRAY_SIZE - 1)]
   INT ind;
   INT retvalu;
   INT exp_i;

   retvalu = 1;
   exp_i = 2;
   FOR ind FROM 0 TO array_size - 2:
      IF fac_arr_pc[ind] == fac_arr_pc[ind + 1]:
         exp_i += 1;
      ELSE:
         retvalu *= exp_i;
         exp_i = 2;
      IF_END
   FOR_END
   RETURN retvalu * exp_i;
FUNC_END

FUNC INT sigma1_f(INT array_size, READONLY INT fac_arr_pc[]):
   # sum of divisors of factorization FAC_ARR_P[0..(ARRAY_SIZE - 1)]
   INT ind;
   INT retvalu;
   INT exp_i;
   INT prm_prev;
   INT prm_curr;

   retvalu = 1;
   exp_i = 2;
   prm_prev = fac_arr_pc[0];
   FOR ind FROM 1 TO array_size - 1:
      prm_curr = fac_arr_pc[ind];
      IF prm_prev == prm_curr:
         exp_i += 1;
      ELSE:
         retvalu *= (powi(prm_prev, exp_i) - 1) / (prm_prev - 1);
         exp_i = 2;
         prm_prev = prm_curr;
      IF_END
   FOR_END
   RETURN retvalu * (powi(prm_prev, exp_i) - 1) / (prm_prev - 1);
FUNC_END

FUNC INT sigma_f(INT powy, INT array_size, READONLY INT fac_arr_pc[]):
   # sum of POWYth power of factorization FAC_ARR_P[0..(ARRAY_SIZE - 1)]
   INT ind;
   INT retvalu;
   INT exp_i;
   INT prm_curr;
   INT prm_prev;
   INT pw;

   IF powy == 0:
      retvalu = sigma0_f(array_size, fac_arr_pc[]);
   ELSIF powy == 1:
      retvalu = sigma1_f(array_size, fac_arr_pc[]);
   ELSE:
      retvalu = 1;
      exp_i = 2;
      prm_prev = fac_arr_pc[0];
      FOR ind FROM 1 TO array_size - 1:
         prm_curr = fac_arr_pc[ind];
         IF prm_prev == prm_curr:
            exp_i += 1;
         ELSE:
            pw = powi(prm_prev, powy);
            retvalu *= ((powi(pw, exp_i) - 1) / (pw - 1));
            exp_i = 2;
            prm_prev = prm_curr;
         IF_END
      FOR_END
      pw = powi(prm_prev, powy);
      retvalu *= ((powi(pw, exp_i) - 1) / (pw - 1));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC BOL ispractical_f(INT array_size, READONLY INT fac_arr_pc[]):
   # test if factorization FAC_ARR_P[0..(ARRAY_SIZE - 1)] is practical
   #    I.E. all positive integers <= NN can be represented
   #       as sums of distinct factors of NN
   INT ind;
   INT sgma;
   INT exp_i;
   INT prm_curr;
   INT prm_prev;
   BOL retvalu_bol;

   IF 2 < fac_arr_pc[0]:
      retvalu_bol = FALSE;
   ELSE:
      retvalu_bol = TRUE;
      sgma = 1;
      exp_i = 2;
      prm_prev = fac_arr_pc[0];
      FOR ind FROM 1 TO array_size - 1:
         prm_curr = fac_arr_pc[ind];
         IF prm_prev == prm_curr:
            exp_i += 1;
         ELSE:
            sgma *= (powi(prm_prev, exp_i) - 1) / (prm_prev - 1);
            IF 1 + sgma < prm_curr:
               retvalu_bol = FALSE;
               FOR_EXIT;
            IF_END
            exp_i = 2;
            prm_prev = prm_curr;
         IF_END
      FOR_END
   IF_END
   RETURN retvalu_bol;
FUNC_END

FUNC BOL issquarefree_f(INT array_size, READONLY INT fac_arr_pc[]):
   # test if factorization FAC_ARR_P[0..(ARRAY_SIZE - 1)] is squarefree
   INT ind;
   BOL retvalu_bol;

   retvalu_bol = TRUE;
   FOR ind FROM 1 TO array_size - 1:
      IF fac_arr_pc[ind - 1] == fac_arr_pc[ind]:
         retvalu_bol = FALSE;
         FOR_EXIT;
      IF_END
   FOR_END
   RETURN retvalu_bol;
FUNC_END

FUNC INT totient_f(INT array_size, READONLY INT fac_arr_pc[]):
   # count of numbers < NN and relatively prime to NN
   #    where NN is number previously factored
   #    into FAC_ARR_P[0..(ARRAY_SIZE - 1)]
   INT ind;
   INT retvalu;

   MODE_INTEGER:
      retvalu = 1;
      FOR ind FROM 0 TO array_size - 2:
         IF fac_arr_pc[ind] == fac_arr_pc[ind + 1]:
            retvalu *= fac_arr_pc[ind];
         ELSE:
            retvalu *= (fac_arr_pc[ind] - 1);
         IF_END
      FOR_END
      retvalu *= (fac_arr_pc[array_size - 1] - 1);
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END

FUNC INT mobius_f(INT array_size, READONLY INT fac_arr_pc[]):
   # MOBIUS function of  factorization FAC_ARR_P[0..(ARRAY_SIZE - 1)]
   # if  factorization has a squared prime factor, 0;
   # else if  factorization has an even number of factors, 1
   # else -1
   INT retvalu;
   INT ind;

   IF Kw.iseven(array_size):
      retvalu = 1;
   ELSE:
      retvalu = -1;
   IF_END
   FOR ind FROM 1 TO array_size - 1:
      IF fac_arr_pc[ind - 1] == fac_arr_pc[ind]:
         retvalu = 0;
         FOR_EXIT;
      IF_END
   FOR_END
   RETURN retvalu;
FUNC_END

FUNC INT prime0_f(INT array_size, READONLY INT fac_arr_pc[]):
   # count of distinct prime factors of factorization
   #      FAC_ARR_P[0..(ARRAY_SIZE - 1)]
   INT ind;
   INT prm_curr;
   INT prm_prev;
   INT retvalu;

   retvalu = 1;
   prm_prev = fac_arr_pc[0];
   FOR ind FROM 1 TO array_size - 1:
      prm_curr = fac_arr_pc[ind];
      IF prm_prev < prm_curr:
         retvalu += 1;
      IF_END
      prm_prev = prm_curr;
   FOR_END
   RETURN retvalu;
FUNC_END

BLOCK: # Prime factors
   BLOCK_DEF CONST LC_FACTORS_CNT 65; # 1

   FUNC INT factor_print(INT nn):
      # Print out all prime factors of number NN
      INT ind;
      INT fac_arr[LC_FACTORS_CNT];
      INT array_size;

      array_size = factor(nn, fac_arr[]);
      PRINTVAL(nn);
      PRINTSTR(" :");
      FOR ind FROM 0 TO array_size - 1:
         PRINTSTR(" ");
         PRINTVAL(fac_arr[ind]);
      FOR_END
      PRINTSTR(STRING_NL);
      RETURN array_size;
   FUNC_END

   FUNC INT mobius(INT nn):
      # MOBIUS function
      #    if NN has a squared prime factor, 0;
      #    else if NN has an even number of factors, 1
      #    else -1
      INT array_size;
      INT fac_arr[LC_FACTORS_CNT];

      array_size = factor(nn, fac_arr[]);
      RETURN mobius_f(array_size, fac_arr[]);
   FUNC_END
   #TEST:mobius(19) + 1;
   #TEST:mobius(20) - 0;
   #TEST:mobius(21) - 1;

   FUNC BOL isprimitiveroot(INT naa, INT nn):
      # test if NAA is a primitive root of NN
      INT toti;
      INT array_size_toti;
      INT ind;
      INT prm;
      BOL retvalu_bol;
      INT fac_arr[LC_FACTORS_CNT];

      IF naa <= 1 OR 1 < gcd(naa, nn):
         retvalu_bol = FALSE;
      ELSIF naa == 2:
         retvalu_bol = Kw.isodd(nn);
      ELSE:
         toti = totient(nn);
         array_size_toti = factor(toti, fac_arr[]);
         IF atothenmodp(naa, toti / fac_arr[0], nn) == 1:
            retvalu_bol = FALSE;
         ELSE:
            retvalu_bol = TRUE;
            FOR ind FROM 1 TO array_size_toti - 1:
               IF fac_arr[ind - 1] <> fac_arr[ind]:
                  prm = fac_arr[ind];
                  IF atothenmodp(naa, toti / prm, nn) == 1:
                     retvalu_bol = FALSE;
                     FOR_EXIT;
                  IF_END
               IF_END
            FOR_END
         IF_END
      IF_END
      RETURN retvalu_bol;
   FUNC_END
   #TEST:isprimitiveroot(5,11) - isodd(4);
   #TEST:isprimitiveroot(6,11) - iseven(4);

   FUNC INT prime0(INT nn):
      # count of distinct prime factors of NN
      INT array_size;
      INT fac_arr[LC_FACTORS_CNT];

      array_size = factor(nn, fac_arr[]);
      RETURN prime0_f(array_size, fac_arr[]);
   FUNC_END
   #TEST:prime0(240) - 3;
   #TEST:prime0(241) - 1;
   #TEST:prime0(243) - 1;

   FUNC INT prime1(INT nn):
      # count prime factors of NN, including multiplicities
      INT fac_arr[LC_FACTORS_CNT];
      RETURN factor(nn, fac_arr[]);
   FUNC_END
   #TEST:prime1(240) - 6;
   #TEST:prime1(241) - 1;
   #TEST:prime1(243) - 5;

   FUNC INT sigma0(INT nn):
      # count of divisors of NN
      INT array_size;
      INT fac_arr[LC_FACTORS_CNT];

      array_size = factor(nn, fac_arr[]);
      RETURN sigma0_f(array_size, fac_arr[]);
   FUNC_END
   #TEST:sigma0(12) - 6;

   FUNC INT sigma1(INT nn):
      # sum of divisors of NN
      INT array_size;
      INT fac_arr[LC_FACTORS_CNT];

      array_size = factor(nn, fac_arr[]);
      RETURN sigma1_f(array_size, fac_arr[]);
   FUNC_END
   #TEST:sigma1(28) - 56;
   #TEST:sigma1(29) - 30;
   #TEST:sigma1(30) - 72;

   FUNC INT sigma(INT powy, INT nn):
      # sum of POWYth power of divisors of NN
      INT array_size;
      INT fac_arr[LC_FACTORS_CNT];
      INT retvalu;

      IF nn <= 1:
         retvalu = nn;
      ELSIF powy == 0:
         retvalu = sigma0(nn);
      ELSIF powy == 1:
         retvalu = sigma1(nn);
      ELSE:
         array_size = factor(nn, fac_arr[]);
         retvalu = sigma_f(powy, array_size, fac_arr[]);
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC INT totient(INT nn):
      # count of numbers < NN and relatively prime to NN
      INT fac_arr[LC_FACTORS_CNT];
      INT array_size;

      array_size = factor(nn, fac_arr[]);
      RETURN totient_f(array_size, fac_arr[]);
   FUNC_END
   #TEST:totient(141) - 92;
   #TEST:totient(142) - 70;
   #TEST:totient(143) - 120;

   FUNC BOL has_primitiveroot(INT nn):
      # number has a primitive root iff
      #    it is a power of a odd prime
      #    or twice a power of a odd prime
      INT array_size;
      INT fac_arr[LC_FACTORS_CNT];
      BOL retvalu_bol;

      IF nn < 2:
         retvalu_bol = FALSE;
      ELSE:
         array_size = factor(nn, fac_arr[]);
         retvalu_bol = has_primitiveroot_f(array_size, fac_arr[]);
      IF_END
      RETURN retvalu_bol;
   FUNC_END
   #TEST:has_primitiveroot(191) - isprime(191);
   #TEST:has_primitiveroot(250) - iseven(250);
   #TEST:has_primitiveroot(8);

   FUNC BOL issquarefree(INT nn):
      # test if NN is squarefree
      INT array_size;
      INT fac_arr[LC_FACTORS_CNT];
      BOL retvalu_bol;

      IF nn < 1:
         retvalu_bol = FALSE;
      ELSIF nn < 3:
         retvalu_bol = TRUE;
      ELSE:
         array_size = factor(nn, fac_arr[]);
         retvalu_bol = issquarefree_f(array_size, fac_arr[]);
      IF_END
      RETURN retvalu_bol;
   FUNC_END

   FUNC BOL ispractical(INT nn):
      # test if NN is practical I.E. all positive integers <= NN can be
      #    represented as sums of distinct factors of NN
      INT array_size;
      INT fac_arr[LC_FACTORS_CNT];
      BOL retvalu_bol;

      IF nn < 1:
         retvalu_bol = FALSE;
      ELSIF nn < 3:
         retvalu_bol = TRUE;
      ELSE:
         array_size = factor(nn, fac_arr[]);
         retvalu_bol = ispractical_f(array_size, fac_arr[]);
      IF_END
      RETURN retvalu_bol;
   FUNC_END

   FUNC INT primitiveroot(INT nn):
      # smallest primitive root of multiplicative group modulo NN, if it
      #    exists. 0 otherwise.
      INT ind;
      INT array_size_toti;
      INT toti;
      INT ii;
      INT fac_arr[LC_FACTORS_CNT];
      INT prm;
      INT retvalu;

      MODE_INTEGER:
         IF nn < 2:
            retvalu = 0;
         ELSIF nn < 5:
            retvalu = nn - 1;
         ELSIF NOT has_primitiveroot(nn):
            retvalu = 0;
         ELSE:
            toti = totient(nn);
            array_size_toti = factor(toti, fac_arr[]);
            ii = 2;
            retvalu = 0;
            WHILE ii < nn AND retvalu <= 0:
               IF gcd(ii, nn) == 1:
                  retvalu = ii;
                  prm = 0;
                  FOR ind FROM 0 TO array_size_toti - 1:
                     IF prm <> fac_arr[ind]:
                        prm = fac_arr[ind];
                        IF atothenmodp(ii, toti / prm, nn) == 1:
                           retvalu = 0;
                           FOR_EXIT;
                        IF_END
                     IF_END
                  FOR_END
               IF_END
               ii += 1;
            WHILE_END
         IF_END
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
   #TEST:primitiveroot(191) - 19;
   #TEST:primitiveroot(8);

   FUNC INT carmichael(INT nn):
      # Carmichael lambda function: smallest MM such that NAA**MM = 1 mod NN
      #      for all NAA coprime to NN
      INT ind;
      INT array_size;
      INT lmbd;
      INT prm;
      INT pk;
      INT fac_arr[LC_FACTORS_CNT];

      MODE_INTEGER:
         IF nn < 8:
            lmbd = totient(nn);
         ELSE:
            array_size = factor(nn, fac_arr[]);
            ind = 0;
            WHILE ind < array_size AND fac_arr[ind] == 2:
               ind += 1;
            WHILE_END
            IF 2 < ind:
               lmbd = BITSHIFTL(1, ind - 2);
            ELSE:
               lmbd = 1;
            IF_END
            WHILE ind < array_size:
               prm = fac_arr[ind];
               pk = prm - 1;
               WHILE ind < array_size - 1 AND prm == fac_arr[ind + 1]:
                  ind += 1;
                  pk *= prm;
               WHILE_END
               lmbd = lcm(lmbd, pk);
               ind += 1;
            WHILE_END
         IF_END
      MODE_INTEGER_END
      RETURN lmbd;
   FUNC_END
   #TEST:carmichael(35) - 12;
   #TEST:carmichael(24) - 2;

   FUNC INT znorder(INT naa, INT nn):
      # smallest positive integer PP such that NAA ** PP == 1 mod NN
      # 0 if none exist
      INT ind;
      INT fac_arr[LC_FACTORS_CNT];
      INT array_sizekk;
      INT kk;
      INT ab;
      INT ek;
      INT prm_i;
      INT exp_i;

      MODE_INTEGER:
         IF nn == 0 OR naa == 0:
            kk = 0;
         ELSE:
            IF nn < 0:
               nn = -nn;
            IF_END
            WHILE naa < 0:
               naa += nn;
            WHILE_END
            IF nn <= 1:
               # znorder(naa,0) = 0, znorder(naa,1) = 1
               kk = nn;
            ELSIF naa <= 1:
               # znorder(0,nn) = 0, znorder(1,nn) = 1  (nn > 1)
               kk = naa;
            ELSIF 1 < gcd(naa, nn):
               kk = 0;
            ELSE:   # Cohen 1.4.3 using Carmichael Lambda function
               kk = carmichael(nn);
               array_sizekk = factor(kk, fac_arr[]);
               exp_i = 1;
               FOR ind FROM 0 TO array_sizekk - 1:
                  prm_i = fac_arr[ind];
                  kk /= prm_i;
                  IF ind + 1 < array_sizekk AND prm_i == fac_arr[ind + 1]:
                     exp_i += 1;
                  ELSE:
                     ab = atothenmodp(naa, kk, nn);
                     FOR ek FROM 0 TO exp_i:
                        IF ab == 1:
                           FOR_EXIT;
                        IF_END
                        kk *= prm_i;
                        ab = atothenmodp(ab, prm_i, nn);
                     FOR_END
                     IF exp_i < ek:
                        kk = 0;
                        FOR_EXIT;
                     IF_END
                     exp_i = 1;
                  IF_END
               FOR_END
            IF_END
         IF_END
      MODE_INTEGER_END
      RETURN kk;
   FUNC_END
   #TEST:znorder(37,1000) - 100;
BLOCK_END

FUNC INT repetendlen(INT denm, INT basee):
   # return the repetend length of 1 / DENM in base BASEE
   INT gdn;
   INT retvalu;

   AWAIT 1 == gdn:
      gdn = gcd(denm, basee);
      denm /= gdn;
   AWAIT_END

   IF denm == 1:
      retvalu = 0;
   ELSE:
      retvalu = znorder(basee, denm);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT kevy_print(INT den, INT start, INT basee):
   # print out number in base BASEE, starting with START such that to divide
   #    number by DEN move START from the beginning of the number to the end
   # I.E. Given DEN, START, and BASEE:
   #    Let KK = CEIL((LN(START) + 0.01) / LN(BASE)), and
   #        NN = dlog(BASEE, DEN, BASEE**KK * DEN - 1)
   #   Then print (in base BASEE):
   #   DEN * START * (BASEE ** NN - DEN) / (BASEE**KK * DEN - 1)
   # Return number of digits printed
   INT numer;
   INT valu;
   INT leny;
   INT rema;
   INT overall_len;
   INT baseek;
   INT log_start;

   log_start = FLOORL(LN(start) / LN(basee) + 1);
   baseek = POW(basee, log_start);
   overall_len = (Kw.dlog(basee, den, den * baseek - 1) + 3) * log_start;
   MODE_INTEGER:
      leny = 0;
      numer = start;
      valu = start;
      AWAIT 2 * overall_len < leny:
         CALL base_out_fix_print(valu, basee, log_start);
         leny += log_start;
         valu = FLOORL(numer / den);
         rema = numer % den;
         numer = rema * baseek + valu;
         IF numer == start:
            AWAIT_EXIT;
         IF_END
      AWAIT_END
   MODE_INTEGER_END
   RETURN leny;
FUNC_END

FUNC INT eulerphi(INT nn):
   # count of numbers < NN and relatively prime to NN
   RETURN totient(nn);
FUNC_END

FUNC INT znorder__1(INT nbb, INT mdls):
   # return NN where NBB**NN = 1 mod MDLS
   INT nn;
   INT pp;

   MODE_INTEGER:
      IF 1 < gcd(nbb, mdls):
         nn = 0;
      ELSE:
         pp = 1;
         AWAIT pp == 1 COUNT nn FROM 1 TO mdls:
            pp = (pp * nbb) % mdls;
         AWAIT_END
      IF_END
   MODE_INTEGER_END
   RETURN nn;
FUNC_END

FUNC INT bkn(INT nbb, INT kk):
   # return NN where NBB**NN - 1 = 0 mod (KK * NBB - 1)
   RETURN znorder(nbb, kk * nbb - 1);
FUNC_END

FUNC INT bkbn(INT nbb, INT kk, INT cc):
   # return NN where KK*CC*(NBB**NN - 1) = 0 mod (KK * NBB - 1)
   INT mdls;

   MODE_INTEGER:
      mdls = kk * nbb - 1;
      IF mdls % cc == 0:
         mdls /= cc;
      IF_END
   MODE_INTEGER_END
   RETURN znorder(nbb, mdls);
FUNC_END

BLOCK: # Li, Lix variables
   BLOCK_DEF DBL lv_li_two = 0;

   FUNC DBL lix(DBL xx):
      # logintegral(XX) - logintegral(2)
      BLOCK_USE lv_li_two;
      # if LV_LI_TWO is not defd, def it
      IF lv_li_two <= 0:
         lv_li_two = Kw.logintegral(2.0);
      IF_END
      RETURN Kw.logintegral(xx) - lv_li_two;
   FUNC_END

   FUNC DBL lixinv(DBL yy):
      # return XX such that YY = lix(XX)
      {SECANT_DECLARATIONS}
      DBL x_init;

      x_init = yy / LN(yy);
      {SECANT_LOOP x_init ; 0.05 ; yy - lix(scvx_xx) }
      RETURN scvx_xx;
   FUNC_END
BLOCK_END
#TEST:lix(0) == -1.045163780117492784844588889194613136522615578;
#TEST:lix(3) == 1.1184248145496991880323334781531082300195006343;
#TEST:lix(0) == lix(1.45136923488338105028396848589202744949303);
BLOCK:  # Primish
   BLOCK_DEF FUNC INT lf_n2primish(INT nn):
      # primish for non-negative nn
      INT retvalu;

      IF nn == 0:
         retvalu = 0;
      ELSIF nn < 3:
         retvalu = nn + 1;
      ELSIF Kw.isodd(nn):
         retvalu = 3 * nn - 4;
      ELSE:
         retvalu = 3 * nn - 5;
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC INT n2primish(INT nn):
      INT retvalu;

      IF 0 < nn:
         retvalu = lf_n2primish(nn);
      ELSE:
         retvalu = -lf_n2primish(-nn);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END  # Primish

FUNC DBL primenth__1(DBL nn):
   # an approximation of NNth prime
   DBL logn;
   DBL loglogn;
   DBL retvalu;

   IF nn < 0:
      retvalu = 0;
   ELSIF nn < 4.25:
      retvalu = 1.6 * nn + 0.1;
   ELSE:
      logn = LN(nn);
      loglogn = LN(logn);
      retvalu = nn * (logn + loglogn - 1.0 + (loglogn - 2.0) / logn
               - ((loglogn - 6.0) * loglogn + 11.0) / (2.0 * logn * logn))
               + 3.5 * SQRT(nn) + 10;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL reimann(DBL nn):
   # approxmation of prime counting function
   DBL retvalu;
   DBL sum;
   DBL sum_prev;
   DBL ii;
   DBL lim;

   IF nn < 2:
      retvalu = 0;
   ELSE:
      sum = lix(nn);
      lim = 10 * Kw.lg(nn);
      AWAIT Kw.iseq(sum, sum_prev) COUNT ii FROM 2 TO lim:
         sum_prev = sum;
         sum += mobius(ii) * lix(POW(nn, 1.0 / ii)) / ii;
      AWAIT_END

      retvalu = sum;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT primenth(INT nn):
   # Nth Prime
   INT ii;
   INT pp;
   DBL rmndr;
   INT inc;
   DBL prime_arr[30]; # Nth prime

   IF nn < 5:
      IF nn < 1:
         pp = 0;
      ELSIF nn < 2:
         pp = 2;
      ELSIF nn < 3:
         pp = 3;
      ELSIF nn < 4:
         pp = 5;
      ELSE:
         pp = 7;
      IF_END
   ELSE:
      IF 1024 <= nn:
         ARRAY prime_arr[]: # 2**(n+10)th prime
            8161;  # 2**10th prime
            17863;
            38873;
            84017;
            180503;
            386093;  # 2**15th prime
            821641;
            1742537;
            3681131;
            7754077;
            16290047;  # 2**20th prime
            34136029;
            71378569;
            148948139;
            310248241;
            645155197;  # 2**25th prime
            1339484197;
            2777105129;
            5750079047;
            11891268401;
            24563311309;  # 2**30th prime
            50685770167;
            104484802057;
         ARRAY_END
         ii = FLOORL(Kw.lg(nn + 1) - 10);
         IF ARRAYLAST(prime_arr[]) <= ii:
            ii = ARRAYLAST(prime_arr[]);
         IF_END
         pp = prime_arr[ii];
         ii = Kw.round(POW(2, ii + 10));
         rmndr = Kw.fmodu(pp, 6);
         IF Kw.iseq(rmndr, 5):
            inc = 2;
         ELSIF Kw.iseq(rmndr, 1):
            inc = 4;
         ELSE:
            DIE "PRIME_ISNT_PM_1_MOD_6";
         IF_END
      ELSE:
         pp = 11;
         ii = 5; # 11 is 5th prime
         inc = 2;
      IF_END
      # Now PP is IIth prime number
      # find the NNth prime
      WHILE ii < nn:
         AWAIT Kw.isprime(pp):
            pp += inc;
            inc = 6 - inc;
         AWAIT_END
         ii += 1;
      WHILE_END
   IF_END

   RETURN pp;
FUNC_END

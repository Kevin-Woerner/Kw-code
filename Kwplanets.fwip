#    Copyright (C) 2017-2021 by Kevin D. Woerner
# 2021-04-15 kdw  indent work
# 2021-04-14 kdw  earth obliq and ecc formulas changed
# 2021-04-13 kdw  indent work
# 2021-04-11 kdw  indent work
# 2021-04-09 kdw  indent work
# 2021-04-06 kdw  orbit(gm)?_v funcs
# 2021-03-20 kdw  sidereal and stellar const renam
# 2021-03-18 kdw  const work
# 2021-03-16 kdw  major rework
# 2021-03-15 kdw  lx_.* const names
# 2021-03-14 kdw  const name renam
# 2021-03-13 kdw  line length upped to 77 II
# 2021-03-05 kdw  line length upped to 77
# 2021-02-13 kdw  various
# 2021-02-05 kdw  spacing
# 2021-02-03 kdw  no real net change
# 2021-01-11 kdw  isa index problem
# 2021-01-10 kdw  isa extensions
# 2020-12-08 kdw  synodic constant work
# 2020-12-03 kdw  float explicit const work
# 2020-11-28 kdw  macro syntax overhaul
# 2020-11-23 kdw  number reformat
# 2020-11-22 kdw  language comments changed
# 2020-10-01 kdw  water-boiling func
# 2020-09-29 kdw  comments changed
# 2020-09-27 kdw  PREM model
# 2020-09-25 kdw  surface area
# 2020-08-29 kdw  _a[r]r changed to _mt[r]x
# 2020-08-20 kdw  boolean checks changed
# 2020-08-19 kdw  comment change
# 2020-08-17 kdw  macro syntax changed
# 2020-07-27 kdw  block syntax
# 2020-07-24 kdw  comment cleanup
# 2020-07-18 kdw  rmed some imports
# 2020-06-22 kdw  local-use mved before var decls
# 2020-06-12 kdw  stern-levison and margot rework
# 2020-06-03 kdw  writeonly keyword
# 2020-06-01 kdw  replace "_D" with "_DT"
# 2020-05-30 kdw  CONST syntax change
# 2020-05-27 kdw  pl_val func renamd to lf_val
# 2020-05-18 kdw  block added
# 2020-05-17 kdw  pl_val func
# 2020-05-13 kdw  .*_LA[S]T changed to .*_COU[N]T
# 2020-05-12 kdw  nul rets changed
# 2020-05-11 kdw  REPL[A]CE replaced with LO[C]AL_CO[N]ST
# 2020-05-05 kdw  magic check func changed
# 2020-05-04 kdw  comments added
# 2020-04-28 kdw  tweaks here and there
# 2020-04-23 kdw  const format change
# 2020-04-12 kdw  comment change
# 2020-04-11 kdw  macro arg format
# 2020-04-08 kdw  preprocess sigil change
# 2020-04-03 kdw  uniqify returns
# 2020-03-23 kdw  added _[a]rr suffix to arrays
# 2020-03-11 kdw  RE[P]LACE work
# 2020-03-09 kdw  LO[C]AL_.* keywords
# 2020-03-08 kdw  PR[I]NTVAL change
# 2020-03-06 kdw  L[A]NG.* names
# 2020-03-03 kdw  macro arg name change
# 2020-03-02 kdw  s/_NE[X]T/_E[N]D/g
# 2020-02-28 kdw  poly eval work
# 2020-02-27 kdw  ho[r]ner work
# 2020-02-26 kdw  comment change
# 2020-02-03 kdw  .*_LOOP changed
# 2020-01-28 kdw  updated w/ new ellips.* funcs
# 2020-01-08 kdw  comment location chagned
# 2019-12-26 kdw  module name addded to funcs
# 2019-12-18 kdw  error checking III
# 2019-12-17 kdw  error checking fixed
# 2019-12-15 kdw  error checking
# 2019-12-11 kdw  debugging -- no net change
# 2019-11-17 kdw  include Macros file
# 2019-10-10 kdw  replace AIR with AIR_MASS
# 2019-10-08 kdw  comment change
# 2019-10-04 kdw  comment removal
# 2019-10-02 kdw  macro arg format change
# 2019-09-21 kdw  diff const renam
# 2019-09-10 kdw  earth-gravity major refactor
# 2019-08-30 kdw  lv_isa_.* vars; ISA block
# 2019-08-26 kdw  PRI[N]TS to PR[I]NTSTR
# 2019-08-22 kdw  comment changed
# 2019-08-17 kdw  L[O]G to L[N]
# 2019-08-15 kdw  tweak in pl_helio.*
# 2019-08-14 kdw  comment change
# 2019-08-13 kdw  comment shortened
# 2019-08-11 kdw  comment cleanup
# 2019-08-06 kdw  added "+" to array values
# 2019-07-05 kdw  added extra planet defs; pls[e]ttime
# 2019-07-04 kdw  rmed extra planet defs
# 2019-07-03 kdw  var renm:"s/ind/_ind/;s/__ind/_ind/"
# 2019-07-02 kdw  macro renam
# 2019-06-26 kdw  ".*D" to ".*_DT"
# 2019-06-04 kdw  tur2deg funcs
# 2019-06-02 kdw  NR_ to RAPHSON_
# 2019-05-31 kdw  NR_DO to RAPHSON_LOOP; et al
# 2019-05-29 kdw  comment changed
# 2019-05-28 kdw  comment changed
# 2019-05-24 kdw  s/PL_/LC_/g;
# 2019-05-22 kdw  added "get_" to several vin_.* funcs
# 2019-05-20 kdw  explicit module for consts
# 2019-05-17 kdw  pl.* rmed
# 2019-05-14 kdw  lf_isa_calc, isa_dens funcs; rework
# 2019-05-08 kdw  func descripts
# 2019-05-07 kdw  isa_.* funcs
# 2019-04-30 kdw  failed experiment
# 2019-04-23 kdw  e.*_air_[p]ressure() function rework
# 2019-04-22 kdw  e.*_air_[p]ressure() function
# 2019-03-19 kdw  re[t]_val to re[t]valu
# 2019-03-18 kdw  macro syntax changed
# 2019-03-15 kdw  use to[p]yh1
# 2019-03-08 kdw  is[e]qual to is[e]q, et al.
# 2019-03-04 kdw  loop-limit work
# 2019-02-28 kdw  REP[L]ACE/DE[F]INE work
# 2019-02-19 kdw  macro syntax
# 2019-02-04 kdw  pmo macro, et al
# 2019-01-30 kdw  lv_p[l]_ey var
# 2019-01-27 kdw  pl-helioc[e]ntric func
# 2019-01-23 kdw  probs with powers
# 2018-12-12 kdw  macros.fwip
# 2018-12-10 kdw  module specific refs
# 2018-11-29 kdw  upper cased fwip defined funcs
# 2018-11-26 kdw  PL_ prfxs
# 2018-11-03 kdw  comment
# 2018-10-27 kdw  comment change
# 2018-10-04 kdw  uppercased fwip trig funcs
# 2018-07-19 kdw  comments; array reformat
# 2018-07-17 kdw  private lf_.* funcs
# 2018-07-13 kdw  float number reformt
# 2018-07-10 kdw  added "+" to exponents
# 2018-05-24 kdw  eccentric anomaly refactor
# 2018-05-23 kdw  orbital elements
# 2018-05-23 kdw  eccentric anomaly func
# 2018-05-22 kdw  comment change
# 2018-05-17 kdw  AR[R]AY.* and HOR[N]ER syntax
# 2018-05-16 kdw  AR[R]AY syntax
# 2018-04-19 kdw  consts rework
# 2018-04-09 kdw  [tdr]2[rdt] func renam
# 2018-04-03 kdw  rm () from return
# 2018-03-26 kdw  macro redef
# 2018-03-20 kdw  replaced index w/ "at"replace
# 2018-03-16 kdw  constant and index format
# 2018-03-12 kdw  made PP statements not need ";"
# 2018-02-27 kdw  mass function refactor
# 2018-02-19 kdw  secant and macro refactor
# 2018-02-17 kdw  expandnow changed
# 2018-02-14 kdw  IN[D]EX stuff
# 2018-02-12 kdw  stern-levison
# 2018-02-10 kdw  *_B calcd from _A and FLAT
# 2018-02-08 kdw  *_[ABC] radii
# 2018-01-15 kdw  margot comments
# 2017-11-24 kdw  print string changed
# 2017-11-23 kdw  rm digits from var names
# 2017-11-22 kdw  var renam
# 2017-11-07 kdw  perihelion, aphelion spelled out
# 2017-10-23 kdw  COM[M]ENT syntax
# 2017-10-22 kdw  peri and ap
# 2017-10-21 kdw  in[s]ert syntax
# 2017-10-17 kdw  GM redo; several earth redefd
# 2017-10-15 kdw  sun mass
# 2017-10-10 kdw  __B <= __C <= __A
# 2017-10-09 kdw  suppress units warning with "+-"
# 2017-10-07 kdw  __C; __RADIUS calc changed
# 2017-10-06 kdw  mucho refactor (lots of consts)
# 2017-10-04 kdw  NUS
# 2017-10-03 kdw  margot  simplified
# 2017-10-02 kdw  pl* funcs
# 2017-10-02 kdw  only names
# 2017-10-01 kdw  _planet_.* reorg
# 2017-09-29 kdw  _planet_.* created
# 2017-09-29 kdw  EA[R]THFLAT
# 2017-09-28 kdw  tropical year
# 2017-09-27 kdw  EA[R]THGRA[V]ITY[AB]
# 2017-09-26 kdw  created

{INSERT_FILE "Macros.fwip" }

# basic, usefull things
IMPORT "Kw";
IMPORT "Kwelements";
# need molecular mass of air for ISA calculation

{MACRO PLANET_ONE <NAM> ; <GM> ; <YEAR> ; <DAY> {
   CONST <NAM>_GM    <GM> * Kw.UNITGM;  #L3T-2
   CONST <NAM>_YEAR  <YEAR> * Kw.DAY; #T
   CONST <NAM>_DAY   <DAY> * Kw.DAY; #T
}}

#           NAME     ; GM                ; YEAR (DAYS) ; DAY (DAYS)
{PLANET_ONE SUN      ; 1.32712440018E+20 ; 0.0         ; 24.47 }
{PLANET_ONE MERCURY  ; 2.2032E+13        ; 87.9691     ; 58.6462 }
{PLANET_ONE VENUS    ; 3.24859E+14       ; 224.701     ; -243.018 }
{PLANET_ONE MARS     ; 4.282837E+13      ; 686.971     ; 1.02595676 }
{PLANET_ONE EARTH    ; 3.986004418E+14   ; 365.256363004
         ; 1.0 / 1.00273781191135448 }
{PLANET_ONE JUPITER  ; 1.26686534E+17    ; 4332.59     ; 0.41354 }
{PLANET_ONE SATURN   ; 3.7931187E+16     ; 10759.22    ; 0.44401 }
{PLANET_ONE URANUS   ; 5.793939E+15      ; 30688.5     ; -0.71833 }
{PLANET_ONE NEPTUNE  ; 6.836529E+15      ; 6.0182E+4   ; 0.67125 }
{PLANET_ONE PLUTO    ; 8.71E+11          ; 9.056E+4    ; 6.38723 }
{PLANET_ONE MOON     ; 4.9048695E+12     ; 27.32166155 ; 27.321661 }
{PLANET_ONE CERES    ; 6.26325E+10       ; 1681.63     ; 0.378090 }
{PLANET_ONE ERIS     ; 1.108E+12         ; 2.0383E+5   ; 1.0792 }
{PLANET_ONE MAKEMAKE ; 2.9366E+11        ; 1.12897E+5  ; 0.32379 }
{PLANET_ONE HAUMEA   ; 2.674E+11         ; 1.03774E+5  ; 0.16314585 }

LANGUAGE_NOT LANG_VB6 LANG_VBDOTNET:                      # DAY is a function
   CONST EARTH_SOLARDAY      Kw.DAY;                  #T
LANGUAGE_END                                              # DAY is a function
# http://hpiers.obspm.fr/eop-pc /models/constants.html
# See also Wikipedia::Sidereal_time
# Earths rotational period relative to vernal equinox
CONST EARTH_SIDEREALDAY Kw.DAY / 1.002737909350795;#T
# Earths rotational period relative to stars (IERS)
CONST EARTH_STELLARDAY EARTH_DAY;

CONST EARTH_TROPICALYEAR 365.242190402 * Kw.DAY;   #T
CONST EARTH_SIDEREALYEAR EARTH_YEAR;   #T
CONST EARTH_ANOMALISTICYEAR 365.259636 * Kw.DAY;   #T

CONST SIDEREALYEAR EARTH_SIDEREALYEAR;        #T
CONST ANOMALISTICYEAR EARTH_ANOMALISTICYEAR;  #T
CONST TROPICALYEAR EARTH_TROPICALYEAR;        #T

{MACRO PLANET_A <NAM> ; <FLT> ; <AA> {
   CONST <NAM>_FLATNESS   <FLT>;  #1
   CONST <NAM>_A    <AA> * Kw.METER; #L
   CONST <NAM>_C    <NAM>_A; #L
}}
{MACRO PLANET_AC <NAM> ; <FLT> ; <AA> ; <CC> {
   CONST <NAM>_FLATNESS   <FLT>;  #1
   CONST <NAM>_A    <AA> * Kw.METER; #L
   CONST <NAM>_C    <CC> * Kw.METER; #L
}}
{PLANET_A  SUN      ; 9.0E-6              ; 6.957E+8; }
{PLANET_A  MERCURY  ; 0.0                 ; 2.4397E+6 }
{PLANET_A  VENUS    ; 0.0                 ; 6.0518E+6 }
{PLANET_A  EARTH    ; 1.0 / 298.257223563 ; 6.378137E+6 } # WGS84
{PLANET_A  MARS     ; 1.0 / 169.81        ; 3.3962E+6 }
{PLANET_A  JUPITER  ; 1.0 / 15.4144028    ; 7.1492E+7 }
{PLANET_A  SATURN   ; 1.0 / 10.208        ; 6.0268E+7 }
{PLANET_A  URANUS   ; 1.0 / 43.61604      ; 2.5559E+7 }
{PLANET_A  NEPTUNE  ; 1.0 / 58.54373      ; 2.4764E+7 }
{PLANET_A  PLUTO    ; 0.0                 ; 1.1899E+6 }
{PLANET_A  MOON     ; 1.0 / 827.667       ; 1.7381E+6 }
{PLANET_AC CERES    ; 1.0 / 13.0432       ; 4.826E+5  ; 4.806E+5 }
{PLANET_A  ERIS     ; 0.0                 ; 1.163E+6 }
{PLANET_A  MAKEMAKE ; 1.0 / 30.7917       ; 7.39E+5 }
{PLANET_AC HAUMEA   ; 1.0 / 1.96115       ; 1.161E+6  ; 8.52E+5 }

{MACRO PLANET_OTHER <BODY> {
   # Calculated consts for <BODY>
   CONST <BODY>_B         <BODY>_A * (1.0 - <BODY>_FLATNESS);#L
   CONST <BODY>_RADIUS    (<BODY>_A + <BODY>_B + <BODY>_C) / 3.0;#L
   LANGUAGE_NOT LANG_VB6 LANG_VBDOTNET:                # VB no sqrt in consts
      CONST <BODY>_ESCAPE SQRT(2.0 * <BODY>_GM / <BODY>_RADIUS); #L/T
      CONST <BODY>_OBLATENESS SQRT(<BODY>_FLATNESS
               * (2.0 + -<BODY>_FLATNESS));#1
   LANGUAGE_END                                        # VB no sqrt in consts
   CONST <BODY>_GRAVITY   <BODY>_GM / (<BODY>_RADIUS * <BODY>_RADIUS); #LT-2
   CONST <BODY>_MASS      <BODY>_GM / Kw.GRAVITATION;#M
   CONST <BODY>_VOLUME    2.0 * Kw.TAU / 3.0 * <BODY>_RADIUS
            * <BODY>_RADIUS * <BODY>_RADIUS; #L3
   CONST <BODY>_SURFACE   2.0 * Kw.TAU * <BODY>_RADIUS * <BODY>_RADIUS; #L2
   CONST <BODY>_DENSITY   <BODY>_MASS / <BODY>_VOLUME; #ML-3
}}

{PLANET_OTHER SUN }
{PLANET_OTHER EARTH }

{MACRO PLANET_SYNODIC <BODY> {
   {PLANET_OTHER <BODY> }
   CONST <BODY>_SYNODIC  EARTH_SIDEREALYEAR * <BODY>_YEAR
            / (<BODY>_YEAR + -EARTH_SIDEREALYEAR); #T
}}
{PLANET_SYNODIC MERCURY }
{PLANET_SYNODIC VENUS }
{PLANET_SYNODIC MARS }
{PLANET_SYNODIC JUPITER }
{PLANET_SYNODIC SATURN }
{PLANET_SYNODIC URANUS }
{PLANET_SYNODIC NEPTUNE }
{PLANET_SYNODIC PLUTO }
{PLANET_SYNODIC MOON }
{PLANET_SYNODIC CERES }
{PLANET_SYNODIC ERIS }
{PLANET_SYNODIC MAKEMAKE }
{PLANET_SYNODIC HAUMEA }

CONST SUN_GMIERS   1.32712442099E+20 * Kw.UNITGM;  #L3T-2
CONST SUN_GMNASA   SUN_GM;  #L3T-2
CONST EARTH_THETA_0 0.7790572732640 * Kw.TURN; #A
##    ORBITAL INFORMATION --- ----- ----- ----- ----- ----- ----- ----- -----
CONST MOON_ORBIT 3.843999E+8 * Kw.METER;  #L
CONST MOON_ECCENTRICITY 0.0549;                  #1
CONST MOON_INCLINATION 5.415 * Kw.ARCDEG;       #A
{MACRO PLANET_DORBITAL_ELEMENTS <BODY>
         ; <DISV> ; <ECCV> ; <INCV> ; <LONV> ; <PERV> ; <ASCV>
         ; <DISD> ; <ECCD> ; <INCD> ; <LOND> ; <PERD> ; <ASCD> {
   # Orbital Elements for <BODY>
   CONST <BODY>_ORBIT          <DISV> * Kw.AU;     #L
   CONST <BODY>_ECCENTRICITY   <ECCV>;             #1
   CONST <BODY>_INCLINATION    <INCV> * Kw.ARCDEG; #A
   CONST <BODY>_LONGITUDE      <LONV> * Kw.ARCDEG; #A
   CONST <BODY>_PERIAPSIS      <PERV> * Kw.ARCDEG; #A
   CONST <BODY>_ASCENDING      <ASCV> * Kw.ARCDEG; #A
   CONST <BODY>_ORBIT_DT        <DISD> * Kw.AU / Kw.JCENTURY; #LT-1
   CONST <BODY>_ECCENTRICITY_DT <ECCD> / Kw.JCENTURY;    #T-1
   CONST <BODY>_INCLINATION_DT  <INCD> * Kw.ARCDEG / Kw.JCENTURY; #AT-1
   CONST <BODY>_LONGITUDE_DT    <LOND> * Kw.ARCDEG / Kw.JCENTURY; #AT-1
   CONST <BODY>_PERIAPSIS_DT    <PERD> * Kw.ARCDEG / Kw.JCENTURY; #AT-1
   CONST <BODY>_ASCENDING_DT    <ASCD> * Kw.ARCDEG / Kw.JCENTURY; #AT-1
}}

# from website https://ssd.jpl.nasa.gov /txt/p_elem_t1.txt
# AU; Eccentricity; Inclination; Longitude; Periapsis; Ascending
{PLANET_DORBITAL_ELEMENTS SUN
         ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0
         ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0 }
{PLANET_DORBITAL_ELEMENTS EARTH
         ; 1.00000261 ; 0.01671123
         ; 359.99998469 ; 100.46457166 ; 102.93768193 ; 0.0
         ; 0.00000562 ; -0.00004392
         ; -0.01294668 ; 35999.37244981 ; 0.32327364 ; 0.0 }
{PLANET_DORBITAL_ELEMENTS MERCURY
         ; 0.38709927 ; 0.20563593
         ; 7.00497902 ; 252.25032350 ; 77.45779628 ; 48.33076593
         ; 0.00000037 ; 0.00001906
         ; -0.00594749 ; 149472.67411175 ; 0.16047689 ; -0.12534081 }
{PLANET_DORBITAL_ELEMENTS VENUS
         ; 0.72333566 ; 0.00677672
         ; 3.39467605 ; 181.97909950 ; 131.60246718 ; 76.67984255
         ; 0.00000390 ; -0.00004107
         ; -0.00078890 ; 58517.81538729 ; 0.00268329 ; -0.27769418 }
{PLANET_DORBITAL_ELEMENTS MARS
         ; 1.52371034 ; 0.09339410
         ; 1.84969142 ; 355.44656795 ; 336.05637041 ; 49.55953891
         ; 0.00001847 ; 0.00007882
         ; -0.00813131 ; 19140.30268499 ; 0.44441088 ; -0.29257343 }
{PLANET_DORBITAL_ELEMENTS JUPITER
         ; 5.20288700 ; 0.04838624
         ; 1.30439695 ; 34.39644051 ; 14.72847983 ; 100.47390909
         ; -0.00011607 ; -0.00013253
         ; -0.00183714 ; 3034.74612775 ; 0.21252668 ; 0.20469106 }
{PLANET_DORBITAL_ELEMENTS SATURN
         ; 9.53667594 ; 0.05386179
         ; 2.48599187 ; 49.95424423 ; 92.59887831 ; 113.66242448
         ; -0.00125060 ; -0.00050991
         ; 0.00193609 ; 1222.49362201 ; -0.41897216 ; -0.28867794 }
{PLANET_DORBITAL_ELEMENTS  URANUS
         ; 19.18916464 ; 0.04725744
         ; 0.77263783 ; 313.23810451 ; 170.95427630 ; 74.01692503
         ; -0.00196176 ; -0.00004397
         ; -0.00242939 ; 428.48202785 ; 0.40805281 ; 0.04240589 }
{PLANET_DORBITAL_ELEMENTS  NEPTUNE
         ; 30.06992276 ; 0.00859048
         ; 1.77004347 ; 304.87997031 ; 44.96476227 ; 131.78422574
         ; 0.00026291 ; 0.00005105
         ; 0.00035372 ; 218.45945325 ; -0.32241464 ; -0.00508664 }
{PLANET_DORBITAL_ELEMENTS  PLUTO
         ; 39.48211675 ; 0.24882730
         ; 17.14001206 ; 238.92903833 ; 224.06891629 ; 110.30393684
         ; -0.00031596 ; 0.00005170
         ; 0.00004818 ; 145.20780515 ; -0.04062942 ; -0.01183482 }
{PLANET_DORBITAL_ELEMENTS CERES
         ; 2.76740933 ; 0.07560729
         ; 10.59321706 ; 102.82668 ; 73.023742647 ; 80.308882612359
         ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0 }
{PLANET_DORBITAL_ELEMENTS ERIS
         ; 67.781 ; 0.44068
         ; 44.0445 ; 32.4926663 ; 151.60371236817 ; 35.87992471211
         ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0 }
{PLANET_DORBITAL_ELEMENTS MAKEMAKE
         ; 45.715 ; 0.15586
         ; 29.00685 ; 177.2966805 ; 295.642772002 ; 79.616805978978
         ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0 }
{PLANET_DORBITAL_ELEMENTS HAUMEA
         ; 43.218 ; 0.19126
         ; 28.19 ; 215.687315 ; 238.69440821915 ; 122.01840302632
         ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0 ; 0.0 }

FUNC DBL orbitgm_v(DBL gm_gm, DBL orbit_m):
   # orbital velocity around a mass with gravitational parameter GM_GM at a
   #    distance of ORBIT_M meters from center
   RETURN SQRT(gm_gm / orbit_m);
FUNC_END

FUNC DBL orbit_v(DBL mass_kg, DBL orbit_m):
   # orbital velocity around a mass MASS_KG at a distance of ORBIT_M meters
   #    from center
   RETURN orbitgm_v(Kw.GRAVITATION * mass_kg, orbit_m);
FUNC_END

FUNC DBL margot(DBL pmass, DBL porbit):
   # the const, k, in the following routine equals
   #   k = sqrt(3) * (100 * Tsun)**0.75 * AU**1.125
   #         / (SUNMASS * C**1.5)
   #   k = T**0.75*L**1.125/(M*L**1.5)
   #   where:
   #      C = 2*sqrt(3) HillRadius
   #      HillRadius = _ORBIT * cbrt(_MASS / (3 * SUNMASS))
   #      Tsun = 1E+10 year = lifetime of sun
   #      T_star = (2.5E+108 s kg**3) / starMASS**3
   #   planets have a value much greater than 1, and
   #   dwarf planets have a value much less than 1
   DBL retvalu;

   IF pmass <= 0.0 OR porbit <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 5.0401742E-10 * pmass / EXP(LN(porbit) * 1.125);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL sternlevison(DBL pmass, DBL porbit):
   # the const, k, in the following routine equals
   #   k=1.53E+5 * AU**1.5 / EARTH_MASS**2
   #   planets have a value much larger than 1, and
   #   dwarf planets have a value much less than 1
   DBL retvalu;
   DBL xx;

   IF pmass <= 0.0 OR porbit <= 0.0:
      retvalu = 0.0;
   ELSE:
      xx = 2.0 * LN(pmass) - 1.5 * LN(porbit);
      retvalu = 2.482E-28 * EXP(xx);
   IF_END
   RETURN retvalu;
FUNC_END

BLOCK:
   # SUN must be < 2**15 for VB6 VBDOTNET
   BLOCK_DEF CONST LC_P1_ERR -1; # 1
   BLOCK_DEF CONST LC_P1_PREV_PL -1; # 1
   BLOCK_DEF CONST LC_P1_SUN 0; # 1
   BLOCK_DEF CONST LC_P1_MERCURY 1; # 1
   BLOCK_DEF CONST LC_P1_VENUS 2; # 1
   BLOCK_DEF CONST LC_P1_EARTH 3; # 1
   BLOCK_DEF CONST LC_P1_MARS 4; # 1
   BLOCK_DEF CONST LC_P1_JUPITER 5; # 1
   BLOCK_DEF CONST LC_P1_SATURN 6; # 1
   BLOCK_DEF CONST LC_P1_URANUS 7; # 1
   BLOCK_DEF CONST LC_P1_NEPTUNE 8; # 1
   BLOCK_DEF CONST LC_P1_PLUTO 9; # 1
   BLOCK_DEF CONST LC_P1_CERES 10; # 1
   BLOCK_DEF CONST LC_P1_ERIS 11; # 1
   BLOCK_DEF CONST LC_P1_MAKEMAKE 12; # 1
   BLOCK_DEF CONST LC_P1_HAUMEA 13; # 1
   BLOCK_DEF CONST LC_P1_CNT 14; # 1

   BLOCK_DEF CONST LC_P2_GM 0;
   BLOCK_DEF CONST LC_P2_DAY 1;
   BLOCK_DEF CONST LC_P2_FLATNESS 2;
   BLOCK_DEF CONST LC_P2_A 3;
   BLOCK_DEF CONST LC_P2_C 4;
   BLOCK_DEF CONST LC_P2_YEAR 5;
   BLOCK_DEF CONST LC_P2_ORB 6;
   BLOCK_DEF CONST LC_P2_ECC 7;
   BLOCK_DEF CONST LC_P2_INC 8;
   BLOCK_DEF CONST LC_P2_LON 9;
   BLOCK_DEF CONST LC_P2_PER 10;
   BLOCK_DEF CONST LC_P2_ASC 11;
   BLOCK_DEF CONST LC_P2_ORB_DT 12;
   BLOCK_DEF CONST LC_P2_ECC_DT 13;
   BLOCK_DEF CONST LC_P2_INC_DT 14;
   BLOCK_DEF CONST LC_P2_LON_DT 15;
   BLOCK_DEF CONST LC_P2_PER_DT 16;
   BLOCK_DEF CONST LC_P2_ASC_DT 17;
   BLOCK_DEF CONST LC_P2_CNT 18;

   BLOCK_DEF DBL lv_plsun_arr[3];
   BLOCK_DEF DBL lv_plgeo_arr[3];
   BLOCK_DEF INT lv_pl_ind = LC_P1_PREV_PL;
   BLOCK_DEF DBL lv_pl_mtrx[LC_P1_CNT][LC_P2_CNT];
   BLOCK_DEF DBL lv_pl_earth_year = EARTH_YEAR;
   BLOCK_DEF DBL lv_pl_jtwoktime = 1.0 / 64.0;

   # setup macro
   {MACRO PLNT_SETUP_VALUES <PP> {
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_GM]      = <PP>_GM;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_DAY]     = <PP>_DAY;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_FLATNESS] = <PP>_FLATNESS;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_A]       = <PP>_A;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_C]       = <PP>_C;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_YEAR]    = <PP>_YEAR;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_ORB]     = <PP>_ORBIT;

      lv_pl_mtrx[LC_P1_<PP>][LC_P2_ECC]    = <PP>_ECCENTRICITY;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_INC]    = <PP>_INCLINATION;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_LON]    = <PP>_LONGITUDE;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_PER]    = <PP>_PERIAPSIS;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_ASC]    = <PP>_ASCENDING;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_ORB_DT] = <PP>_ORBIT_DT;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_ECC_DT] = <PP>_ECCENTRICITY_DT;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_INC_DT] = <PP>_INCLINATION_DT;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_LON_DT] = <PP>_LONGITUDE_DT;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_PER_DT] = <PP>_PERIAPSIS_DT;
      lv_pl_mtrx[LC_P1_<PP>][LC_P2_ASC_DT] = <PP>_ASCENDING_DT;
   }}

   BLOCK_DEF FUNC INT lf_pl_init(INT plnt):
      BLOCK_USE lv_pl_ind;
      BLOCK_USE lv_pl_mtrx[];

      IF lv_pl_ind < 0:
         {PLNT_SETUP_VALUES SUN }
         {PLNT_SETUP_VALUES MERCURY }
         {PLNT_SETUP_VALUES VENUS }
         {PLNT_SETUP_VALUES EARTH }
         {PLNT_SETUP_VALUES MARS }
         {PLNT_SETUP_VALUES JUPITER }
         {PLNT_SETUP_VALUES SATURN }
         {PLNT_SETUP_VALUES URANUS }
         {PLNT_SETUP_VALUES NEPTUNE }
         {PLNT_SETUP_VALUES PLUTO }
         {PLNT_SETUP_VALUES CERES }
         {PLNT_SETUP_VALUES ERIS }
         {PLNT_SETUP_VALUES MAKEMAKE }
         {PLNT_SETUP_VALUES HAUMEA }
         IF 0 < lv_pl_jtwoktime AND lv_pl_jtwoktime < 1.0 / 32.0:
            CALL plsettime(Kw.uet2j2k(Kw.timee()));
         IF_END
         lv_pl_earth_year = EARTH_YEAR;
      IF_END

      IF LC_P1_SUN <= plnt AND plnt < LC_P1_CNT:
         lv_pl_ind = plnt;
      ELSIF plnt == LC_P1_PREV_PL:
         IF lv_pl_ind < 0:
            lv_pl_ind = LC_P1_EARTH;
         IF_END
      ELSE:
         lv_pl_ind = LC_P1_PREV_PL;
      IF_END
      RETURN lv_pl_ind;
   FUNC_END

   BLOCK_DEF FUNC DBL lf_val(INT pa_ind
            , INT pb_bb
            , INT pb_bbd):
      INT pl_ind;
      DBL retvalu;

      IF pa_ind < LC_P1_PREV_PL OR LC_P1_CNT <= pa_ind:
         retvalu = LC_P1_ERR;
      ELSE:
         pl_ind = pl(pa_ind);
         retvalu = (lv_pl_mtrx[pl_ind][pb_bb]
                  + lv_pl_jtwoktime * lv_pl_mtrx[pl_ind][pb_bbd]);
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC INT pl(INT plnt):
      # set selected planet to PLNT
      RETURN lf_pl_init(plnt);
   FUNC_END

   FUNC DBL plsettime(DBL jtwokdate):
      # set planet-time to JTWOKDATE
      lv_pl_jtwoktime = jtwokdate * Kw.JDAY;
      RETURN lv_pl_jtwoktime;
   FUNC_END

   {MACRO PLNT_FUNC <AA> {
      FUNC DBL pl<AA>(NUL):
         # <AA> of previous selected planet
         BLOCK_USE lv_pl_ind;
         RETURN pl_<AA>(LC_P1_PREV_PL);
      FUNC_END
   }}

   {MACRO PLNT_PHYSICAL <AA> ; <BB> {
      FUNC DBL pl_<AA>(INT plnt):
         # <AA> of planet PLNT
         BLOCK_USE lv_pl_mtrx[];
         BLOCK_USE lv_pl_ind;
         DBL retvalu;

         CALL lf_pl_init(plnt);
         IF LC_P1_SUN <= plnt AND plnt < LC_P1_CNT:
            retvalu = lv_pl_mtrx[plnt][LC_P2_<BB>];
         ELSIF plnt == LC_P1_PREV_PL:
            retvalu = lv_pl_mtrx[lv_pl_ind][LC_P2_<BB>];
         ELSE:
            retvalu = LC_P1_ERR;
         IF_END
         RETURN retvalu;
      FUNC_END
      {PLNT_FUNC <AA> }
   }}

   {PLNT_PHYSICAL gm            ; GM }
   {PLNT_PHYSICAL year          ; YEAR }
   {PLNT_PHYSICAL day           ; DAY }
   {PLNT_PHYSICAL flatness      ; FLATNESS }
   {PLNT_PHYSICAL a             ; A }
   {PLNT_PHYSICAL c             ; C }

   {MACRO PLNT_ORBITAL <AA> ; <BB> {
      FUNC DBL pl_<AA>(INT plnt):
         # compute orbital <AA> of planet PLNT
         RETURN lf_val(plnt, LC_P2_<BB>, LC_P2_<BB>_DT);
      FUNC_END
      {PLNT_FUNC <AA> }
   }}

   {PLNT_ORBITAL orbit         ; ORB }
   {PLNT_ORBITAL eccentricity  ; ECC }
   {PLNT_ORBITAL inclination   ; INC }
   {PLNT_ORBITAL longitude     ; LON }
   {PLNT_ORBITAL periapsis     ; PER }
   {PLNT_ORBITAL ascending     ; ASC }

   {MACRO PLNT_VAL <PP> ; <VAL> {
      DBL retvalu;
      IF <PP> < LC_P1_PREV_PL OR LC_P1_CNT <= <PP>:
         retvalu = LC_P1_ERR;
      ELSE:
         retvalu = <VAL>;
      IF_END
      RETURN retvalu;
   }}

   FUNC DBL pl_mass(INT plnt):
      # Mass (kg) of planet PLNT
      {PLNT_VAL plnt ; pl_gm(plnt) / Kw.GRAVITATION }
   FUNC_END
   {PLNT_FUNC mass }

   FUNC DBL pl_b(INT plnt):
      # polar radius (m) of planet PLNT
      {PLNT_VAL plnt ; (1.0 - pl_flatness(plnt)) * pl_a(plnt) }
   FUNC_END
   {PLNT_FUNC b }

   FUNC DBL pl_radius(INT plnt):
      # average radius (m) of planet PLNT
      {PLNT_VAL plnt ; (pl_a(plnt) + pl_b(plnt) + pl_c(plnt)) / 3.0 }
   FUNC_END
   {PLNT_FUNC radius }

   FUNC DBL pl_gravity(INT plnt):
      # mean surface gravity (m/s**2) of planet PLNT
      #   GM / RADIUS**2
      {PLNT_VAL plnt ; pl_gm(plnt) / Kw.square(pl_radius(plnt)) }
   FUNC_END
   {PLNT_FUNC gravity }

   FUNC DBL pl_meananomaly(INT plnt):
      # mean anomaly of planet PLNT
      {PLNT_VAL plnt ; Kw.fmodu(pl_longitude(plnt) - pl_periapsis(plnt)
               , Kw.TAU) }
   FUNC_END
   {PLNT_FUNC meananomaly }

   FUNC DBL pl_escape(INT plnt):
      # mean escape velocity (m/s) of planet PLNT
      #    SQRT(2.0 * GM / RADIUS);
      {PLNT_VAL plnt; SQRT(2.0 * pl_gm(plnt) / pl_radius(plnt)) }
   FUNC_END
   {PLNT_FUNC escape }

   FUNC DBL pl_synodic(INT plnt):
      # synodic period (s) of planet PLNT
      #    PL_YEAR * EARTH_YEAR / (PL_YEAR - EARTH_YEAR)
      BLOCK_USE lv_pl_earth_year;
      DBL yra;
      DBL retvalu;

      IF plnt < LC_P1_PREV_PL OR LC_P1_CNT <= plnt:
         retvalu = LC_P1_ERR;
      ELSE:
         yra = pl_year(plnt);
         retvalu = Kw.divi(yra * lv_pl_earth_year
                  , ABS(yra - lv_pl_earth_year), 0.0);
      IF_END
      RETURN retvalu;
   FUNC_END
   {PLNT_FUNC synodic }

   FUNC DBL pl_volume(INT plnt):
      # volume (m**3) of planet PLNT
      {PLNT_VAL plnt ; 2.0 * Kw.TAU * pl_a(plnt) * pl_b(plnt) * pl_c(plnt)
               / 3.0 }
   FUNC_END
   {PLNT_FUNC volume }

   FUNC DBL pl_surface(INT plnt):
      # surface area (m**2) of planet PLNT
      DBL retvalu;

      IF plnt < LC_P1_PREV_PL OR LC_P1_CNT <= plnt:
         retvalu = LC_P1_ERR;
      ELSE:
         retvalu = Kw.ellipsoid_surface(pl_a(plnt), pl_b(plnt), pl_c(plnt));
      IF_END
      RETURN retvalu;
   FUNC_END
   {PLNT_FUNC surface }

   FUNC DBL pl_density(INT plnt):
      # density (kg/m**3) of planet PLNT
      {PLNT_VAL plnt ; pl_mass(plnt) / pl_volume(plnt) }
   FUNC_END
   {PLNT_FUNC density }

   FUNC DBL pl_argument(INT plnt):
      # argument of perihelion of planet PLNT
      {PLNT_VAL plnt ; pl_periapsis(plnt) - pl_ascending(plnt) }
   FUNC_END
   {PLNT_FUNC argument }

   FUNC DBL pl_margot(INT plnt):
      # Margot parameter for given planet
      DBL retvalu;

      IF plnt < LC_P1_PREV_PL OR LC_P1_CNT <= plnt:
         retvalu = LC_P1_ERR;
      ELSE:
         retvalu = margot(pl_mass(plnt), pl_orbit(plnt));
      IF_END
      RETURN retvalu;
   FUNC_END
   {PLNT_FUNC margot }

   FUNC DBL pl_sternlevison(INT plnt):
      # Stern-Levison parameter for given planet
      DBL retvalu;

      IF plnt < LC_P1_PREV_PL OR LC_P1_CNT <= plnt:
         retvalu = LC_P1_ERR;
      ELSE:
         retvalu = sternlevison(pl_mass(plnt), pl_orbit(plnt));
      IF_END
      RETURN retvalu;
   FUNC_END
   {PLNT_FUNC sternlevison }

   FUNC DBL pl_perihelion(INT plnt):
      # perihelion distance (m) of planet PLNT
      {PLNT_VAL plnt ; pl_orbit(plnt) * (1.0 - pl_eccentricity(plnt)) }
   FUNC_END
   {PLNT_FUNC perihelion }

   FUNC DBL pl_aphelion(INT plnt):
      # aphelion distance (m) of planet PLNT
      {PLNT_VAL plnt ; pl_orbit(plnt) * (1.0 + pl_eccentricity(plnt)) }
   FUNC_END
   {PLNT_FUNC aphelion }

   FUNC DBL eccentric_anomaly(DBL mean_ano_rad
            , DBL eccen):
      # solve 0 = EA - ECCEN * sin(EA) - MEAN_ANO_RAD for EA
      #   using Newton-Raphson method
      DBL mrad;
      DBL xrad;
      {RAPHSON_DECLARATIONS}

      mrad = Kw.fmodu(mean_ano_rad, Kw.tur2rad(1.0));
      xrad = mrad + eccen * SIN(mrad); # init guess

      {RAPHSON_LOOP xrad ; nrvx_xx - eccen * SIN(nrvx_xx) - mean_ano_rad
               ; 1.0 - eccen * COS(nrvx_xx) }
      RETURN nrvx_xx;
   FUNC_END

   FUNC DBL pl_eccentricanomaly(INT plnt):
      # eccentric anomaly of planet PLNT
      {PLNT_VAL plnt ; eccentric_anomaly(pl_meananomaly(plnt)
               , pl_eccentricity(plnt)) }
   FUNC_END
   {PLNT_FUNC eccentricanomaly }

   FUNC DBL pl_heliocentric(INT plnt, DBL jtwok):
      # compute heliocentric (and geocentric) coordinates
      # for planet PLNT at given J2K time.
      # use with functions plgeo, plhelio
      BLOCK_USE lv_plsun_arr[];
      BLOCK_USE lv_plgeo_arr[];
      DBL orb_m;
      DBL eccen;
      DBL inc_rad;
      DBL lon_rad;
      DBL per_rad;
      DBL asc_rad;
      DBL arg_rad;
      DBL mean_anomaly_rad;
      DBL eano_rad;
      DBL dxx_m;
      DBL dyy_m;
      DBL ci;
      DBL co;
      DBL cw;
      DBL si;
      DBL so;
      DBL sw;
      DBL swci;
      DBL cwci;
      DBL obl_rad;
      DBL retvalu;

      IF lf_pl_init(plnt) < 0.0:
         retvalu = LC_P1_ERR;
      ELSE:
         CALL plsettime(jtwok);

         orb_m = plorbit();
         eccen = pleccentricity();
         inc_rad = plinclination();
         lon_rad = pllongitude();
         per_rad = plperiapsis();
         asc_rad = plascending();
         # step 2: compute argument of perihelion, mean anomaly
         arg_rad = per_rad - asc_rad;
         mean_anomaly_rad = Kw.fmod(lon_rad - per_rad, Kw.tur2rad(1.0));

         # step 3: calculate eccentric anomaly
         eano_rad = eccentric_anomaly(mean_anomaly_rad, eccen);

         # step 4: compute planets heliocentric coordinates
         dxx_m = orb_m * (COS(eano_rad) - eccen);
         dyy_m = orb_m * Kw.topyh1(eccen) * SIN(eano_rad);

         # step 5: compute J2000 eliptic plane, x axis = equinox
         cw = COS(arg_rad);
         sw = SIN(arg_rad);
         co = COS(asc_rad);
         so = SIN(asc_rad);
         ci = COS(inc_rad);
         si = SIN(inc_rad);
         swci = sw * ci;
         cwci = cw * ci;

         lv_plsun_arr[0] = (dxx_m * (cw * co - swci * so)
                  - dyy_m * (sw * co + cwci * so));
         lv_plsun_arr[1] = (dxx_m * (cw * so + swci * co)
                  - dyy_m * (sw * so - cwci * co));
         lv_plsun_arr[2] = (dxx_m * (sw * si)
                  + dyy_m * (cw * si));

         # step 6 -- convert to ICRF frame or J2000 frame
         obl_rad = earthobliquity(jtwok);
         co = COS(obl_rad);
         so = SIN(obl_rad);
         lv_plgeo_arr[0] = lv_plsun_arr[0];
         lv_plgeo_arr[1] = co * lv_plsun_arr[1] - so * lv_plsun_arr[2];
         lv_plgeo_arr[2] = so * lv_plsun_arr[1] + co * lv_plsun_arr[2];

         retvalu = Kw.hypot3(lv_plsun_arr[0], lv_plsun_arr[1]
                  , lv_plsun_arr[2]);
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC DBL plhelio(INT indd):
      # heliocentric distance, in m, computed by
      #    previous call to pl_heliocentric
      BLOCK_USE lv_plsun_arr[];
      DBL retvalu;

      IF 0 <= indd AND indd < 3:
         retvalu = lv_plsun_arr[indd];
      ELSE:
         retvalu = 0.0;
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC DBL plgeo(INT indd):
      # geocentric distance, in m, computed by
      #    previous call to pl_heliocentric
      BLOCK_USE lv_plgeo_arr[];
      DBL retvalu;

      IF 0 <= indd AND indd < 3:
         retvalu = lv_plgeo_arr[indd];
      ELSE:
         retvalu = 0.0;
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC INT pl_name(INT plnt):
      # print name of planet PLNT
      INT plnt_ind;

      plnt_ind = lf_pl_init(plnt);

      IF plnt_ind == LC_P1_SUN:
         PRINTSTR("SUN      ");
      ELSIF plnt_ind == LC_P1_MERCURY:
         PRINTSTR("MERCURY  ");
      ELSIF plnt_ind == LC_P1_VENUS:
         PRINTSTR("VENUS    ");
      ELSIF plnt_ind == LC_P1_EARTH:
         PRINTSTR("EARTH    ");
      ELSIF plnt_ind == LC_P1_MARS:
         PRINTSTR("MARS     ");
      ELSIF plnt_ind == LC_P1_JUPITER:
         PRINTSTR("JUPITER  ");
      ELSIF plnt_ind == LC_P1_SATURN:
         PRINTSTR("SATURN   ");
      ELSIF plnt_ind == LC_P1_URANUS:
         PRINTSTR("URANUS   ");
      ELSIF plnt_ind == LC_P1_NEPTUNE:
         PRINTSTR("NEPTUNE  ");
      ELSIF plnt_ind == LC_P1_PLUTO:
         PRINTSTR("PLUTO    ");
      ELSIF plnt_ind == LC_P1_CERES:
         PRINTSTR("CERES    ");
      ELSIF plnt_ind == LC_P1_ERIS:
         PRINTSTR("ERIS     ");
      ELSIF plnt_ind == LC_P1_MAKEMAKE:
         PRINTSTR("MAKEMAKE ");
      ELSIF plnt_ind == LC_P1_HAUMEA:
         PRINTSTR("HAUMEA   ");
      ELSE:
         PRINTSTR("UNKNOWN");
         PRINTVAL(plnt_ind);
      IF_END
      RETURN plnt_ind;
   FUNC_END
   {PLNT_FUNC name }

   FUNC DBL earthradius(DBL lat_deg):
      # earth radius, in meters, at geoditic latitiude lat_deg
      RETURN pl_aradius(LC_P1_EARTH, lat_deg);
   FUNC_END
BLOCK_END

FUNC DBL earthtropicalyear(DBL jtwokdate):
   # tropical year length (in days) for given JTWOK date
   DBL jy;

   jy = jtwokdate * Kw.DAY / Kw.JYEAR;
   RETURN ((((
            + 2.64E-16) * jy
            - 7.29E-14) * jy
            - 6.15359E-8) * jy
            + 365.2421896698);
FUNC_END

FUNC DBL earthdistance(DBL lata_deg, DBL lona_deg
         , DBL latb_deg, DBL lonb_deg):
   # compute great circle distance on earth
   # between two sets of latitude and longitude
   RETURN EARTH_A * Kw.great_circle_distance(Kw.deg2rad(lata_deg)
            , Kw.deg2rad(lona_deg), Kw.deg2rad(latb_deg)
            , Kw.deg2rad(lonb_deg));
FUNC_END

FUNC DBL plaradius(DBL lat_deg):
   # radius, in meters, at geoditic latitiude lat_deg
   DBL calat;
   DBL sblat;
   DBL aa;
   DBL bb;

   aa = Kw.square(pla());
   bb = Kw.square(plb());
   calat = Kw.square(pla() * Kw.cosd(lat_deg));
   sblat = Kw.square(plb() * Kw.sind(lat_deg));

   RETURN SQRT((aa * calat + bb * sblat) / (calat + sblat));
FUNC_END

FUNC DBL pl_aradius(INT plnt, DBL lat_deg):
   # radius, in meters, at geoditic latitiude lat_deg
   CALL pl(plnt);

   RETURN plaradius(lat_deg);
FUNC_END

FUNC DBL earthobliquity(DBL jtwok):
   # earths obliquity at J2000 day JTWOK
   DBL tmill;
   DBL ob_arcsec;

   tmill = jtwok * Kw.DAY / (1.0E+4 * Kw.JYEAR);
   # Based on J. Laskar "Astronomy and Astrophysics", Vol 157, p68 (1986),
   # "New Formulas for the Precession, Valid Over 10000 years"
   ob_arcsec = (((((((((((
            + 2.45     ) * tmill
            + 5.79     ) * tmill
            + 27.8     ) * tmill
            + 7.12     ) * tmill
            - 39.05    ) * tmill
            - 249.67   ) * tmill
            - 51.38    ) * tmill
            + 1999.25  ) * tmill
            - 1.55     ) * tmill
            - 4680.93  ) * tmill
            + 84381.448);

   RETURN Kw.sec2rad(ob_arcsec);
FUNC_END

FUNC DBL earthprecession(DBL jtwok):
   # earths precession at J2000 day JTWOK
   DBL tmill;
   DBL ob_arcsec;

   tmill = jtwok * Kw.DAY / (1.0E+4 * Kw.JYEAR);
   # Based on J. Laskar "Astronomy and Astrophysics", Vol 157, p68 (1986),
   # "New Formulas for the Precession, Valid Over 10000 years"
   ob_arcsec = ((((((((((
            - 8.66      ) * tmill
            - 47.59     ) * tmill
            + 24.24     ) * tmill
            + 130.95    ) * tmill
            + 174.51    ) * tmill
            - 180.55    ) * tmill
            - 2353.16   ) * tmill
            + 77.32     ) * tmill
            + 11119.71  ) * tmill
            + 502909.66 ) * tmill
            + 0.0;

   RETURN Kw.sec2rad(ob_arcsec);
FUNC_END

# See Wikipedia::Theoretical_gravity and Wikipedia::Clairauts_theorem
CONST EARTH_GRAVITYA 9.7803253359 * Kw.MPSS;  #LT-2
CONST EARTH_GRAVITYB 9.8321849378 * Kw.MPSS;  #LT-2

FUNC DBL earthgravity(DBL lat_deg):
   # earth gravity, in m/s**2, at geoditic latitiude LAT_DEG
   # using Somigliana formula with WGS-84 parameters
   # See Wikipedia::Normal_gravity_formula
   DBL slatsq;
   DBL obltsq;
   DBL kk;

   slatsq = Kw.square(Kw.sind(lat_deg));

   # following two variables are actually constants given
   #    earth flatness, gravitya, and gravityb
   # oblateness is calculated as
   #    oblateness = sqrt(flatness * (2 - flatness))
   obltsq = EARTH_FLATNESS * (2.0 - EARTH_FLATNESS);
   kk = (((1.0 - EARTH_FLATNESS) * EARTH_GRAVITYB) - EARTH_GRAVITYA);

   RETURN (EARTH_GRAVITYA + kk * slatsq) / SQRT(1.0 - obltsq * slatsq);
FUNC_END

FUNC DBL earthgravity_height(DBL lat_deg, DBL height_m):
   # earth gravity, in m/s**2, at geoditic latititude LAT_DEG
   # at an elevation of HEIGHT_M meters
   RETURN (earthgravity(lat_deg)
            - height_m * 2.0 * EARTH_GM / Kw.cube(EARTH_A));
FUNC_END

BLOCK:   # ISA atmosphere
   BLOCK_DEF CONST LC_ISA_CNT 12;
   BLOCK_DEF CONST LC_ISA_TEMP 0;
   BLOCK_DEF CONST LC_ISA_PRES 1;
   BLOCK_DEF CONST LC_ISA_DENS 2;
   BLOCK_DEF CONST LC_ISA_HEIGHT 3;
   BLOCK_DEF CONST LC_ISA_KEY_CNT 4;
   BLOCK_DEF DBL lv_isa_mtrx[LC_ISA_CNT][LC_ISA_KEY_CNT];
   BLOCK_DEF DBL lv_isa_magic = 0.0;

   {MACRO ISA_INIT <IND> ; <HEI> ; <TEMP> ; <PRES> ; <DENS> {
      lv_isa_mtrx[<IND>][LC_ISA_HEIGHT] = <HEI>;
      lv_isa_mtrx[<IND>][LC_ISA_TEMP] = <TEMP>;
      lv_isa_mtrx[<IND>][LC_ISA_PRES] = <PRES>;
      lv_isa_mtrx[<IND>][LC_ISA_DENS] = <DENS>;
   }}

   BLOCK_DEF FUNC DBL lf_isa_calc(DBL height_m, INT state_x):
      BLOCK_USE lv_isa_mtrx[];
      BLOCK_USE lv_isa_magic;
      INT h_ind;
      DBL air_k_per_m;
      DBL expon;
      DBL this_temp;
      DBL delta_h;
      DBL retvalu;
      DBL tdiff;
      DBL hdiff;
      DBL lapse_kpm;

      IF NOT Kw.ismagic(lv_isa_magic):
         # from Wikipedia::Barometric_formula
         {ISA_INIT 0;     0.0; 288.15;   Kw.ATM; 1.2250 }
         {ISA_INIT 1;  1.1E+4; 216.65; 22632.10; 0.36391 }
         {ISA_INIT 2;  2.0E+4; 216.65;  5474.89; 0.08803 }
         {ISA_INIT 3;  3.2E+4; 228.65;   868.02; 0.01322 }
         {ISA_INIT 4;  4.7E+4; 270.65;   110.91; 0.00143 }
         {ISA_INIT 5;  5.1E+4; 270.65;    66.94; 8.6E-4 }
         {ISA_INIT 6;  7.1E+4; 214.65;     3.96; 6.4E-5 }
         {ISA_INIT 7;   84852; 186.87;   0.3734; 7.0E-6 }
         {ISA_INIT 8;   89700; 186.87;     0.15; 3.0E-6 }
         {ISA_INIT 9;  100400; 199.55;     0.02; 5.0E-7 }
         {ISA_INIT 10; 105000; 217.65;     0.01; 2.0E-7 }
         {ISA_INIT 11; 110000; 263.95;     0.01; 1.0E-7 }
         #                  m;      K;       Pa; kg/m**3
         lv_isa_magic = Kw.magicset();
      IF_END

      h_ind = LC_ISA_CNT - 1;
      WHILE height_m < lv_isa_mtrx[h_ind][LC_ISA_HEIGHT] AND 0 < h_ind:
         h_ind -= 1;
      WHILE_END

      delta_h = height_m - lv_isa_mtrx[h_ind][LC_ISA_HEIGHT];

      IF h_ind < LC_ISA_CNT - 1:
         tdiff = lv_isa_mtrx[h_ind + 1][LC_ISA_TEMP]
                  - lv_isa_mtrx[h_ind][LC_ISA_TEMP];
         hdiff = lv_isa_mtrx[h_ind + 1][LC_ISA_HEIGHT]
                  - lv_isa_mtrx[h_ind][LC_ISA_HEIGHT];
         lapse_kpm = tdiff / hdiff;
      ELSE:
         lapse_kpm = 0.003;
      IF_END
      this_temp = lv_isa_mtrx[h_ind][LC_ISA_TEMP] + lapse_kpm * delta_h;

      IF state_x == LC_ISA_TEMP:
         retvalu = this_temp;
      ELSE:
         air_k_per_m = Kw.GRAVITY * Kwelements.AIR_MASS / Kw.GAS;
         IF Kw.iszero(lapse_kpm):
            retvalu = EXP(-air_k_per_m * delta_h
                     / lv_isa_mtrx[h_ind][LC_ISA_TEMP]);
         ELSE:
            expon = air_k_per_m / lapse_kpm;
            IF state_x == LC_ISA_DENS:
               expon += 1;
            IF_END
            retvalu = POW(lv_isa_mtrx[h_ind][LC_ISA_TEMP] / this_temp
                     , expon);
         IF_END

         IF state_x == LC_ISA_PRES:
            retvalu *= lv_isa_mtrx[h_ind][LC_ISA_PRES];
         ELSE:
            retvalu *= lv_isa_mtrx[h_ind][LC_ISA_DENS];
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC DBL isa_temp(DBL height_m):
      # temperature (in K) at a height HEIGHT_M
      # of International Standard Atmosphere
      RETURN lf_isa_calc(height_m, LC_ISA_TEMP);
   FUNC_END

   FUNC DBL isa_pres(DBL height_m):
      # pressure (in pascals) at a height HEIGHT_M
      # of International Standard Atmosphere
      RETURN lf_isa_calc(height_m, LC_ISA_PRES);
   FUNC_END

   FUNC DBL isa_dens(DBL height_m):
      # density (in kg/m**3) at a height HEIGHT_M
      # of International Standard Atmosphere
      RETURN lf_isa_calc(height_m, LC_ISA_DENS);
   FUNC_END
BLOCK_END   # ISA atmosphere

# Thinly veiled wrappers around several ellipsoid_.* functions
# with args in familiar degrees
FUNC DBL vin_distance(DBL lata_deg
         , DBL lona_deg
         , DBL latb_deg
         , DBL lonb_deg
         , WRITEONLY DBL ret_bearings_arr_p[]):
   # distance (meters) from (LATA, LONA) to (LATB, LONB)
   # RET_BEARINGS_ARR_P[0] = bearing from A to B (degrees)
   # RET_BEARINGS_ARR_P[1] = bearing from B to A (degrees)
   DBL retvalu;
   DBL rad_arr[2];

   retvalu = EARTH_A * Kw.ellipsoid_distance(EARTH_FLATNESS
            , Kw.deg2rad(lata_deg), Kw.deg2rad(lona_deg)
            , Kw.deg2rad(latb_deg), Kw.deg2rad(lonb_deg), rad_arr[]);
   ret_bearings_arr_p[0] = Kw.rad2deg(rad_arr[0]);
   ret_bearings_arr_p[1] = Kw.rad2deg(rad_arr[1]);
   RETURN retvalu;
FUNC_END

FUNC DBL vin_destination(DBL lata_deg
         , DBL lona_deg
         , DBL heading_deg
         , DBL dist_m
         , WRITEONLY DBL ret_dest_arr_p[]):
   # bearing (degree CCW from North)
   # from (LATA, LONA) to point (LATB, LONB)
   # RET_DEST_ARR_P[0] = Latitude of destination (degrees)
   # RET_DEST_ARR_P[1] = Longitude of destination (degrees)
   DBL fltnss;
   DBL retvalu;
   DBL rad_arr[2];

   fltnss = EARTH_FLATNESS;
   retvalu = Kw.ellipsoid_destination(fltnss, Kw.deg2rad(lata_deg)
            , Kw.deg2rad(lona_deg), Kw.deg2rad(heading_deg)
            , dist_m / EARTH_A, rad_arr[]);
   ret_dest_arr_p[0] = Kw.rad2deg(rad_arr[0]);
   ret_dest_arr_p[1] = Kw.rad2deg(rad_arr[1]);
   RETURN Kw.rad2deg(retvalu);
FUNC_END

BLOCK:   # PREM
   BLOCK_DEF CONST LC_PREM_DENS 0;
   BLOCK_DEF CONST LC_PREM_MASS 1;
   BLOCK_DEF CONST LC_PREM_XHEIGHT 0;
   BLOCK_DEF CONST LC_PREM_XCOEA 1;
   BLOCK_DEF CONST LC_PREM_XCOEB 2;
   BLOCK_DEF CONST LC_PREM_XCOEC 3;
   BLOCK_DEF CONST LC_PREM_XMASSD 4;
   BLOCK_DEF DBL lv_prem_mtrx[12][6];
   BLOCK_DEF DBL lv_prem_magic = 0.0;

   {MACRO PREM_INIT <IND> ; <HEI> ; <COEA> ; <COEB> ; <COEC> {
      lv_prem_mtrx[<IND>][LC_PREM_XHEIGHT] = <HEI>;
      lv_prem_mtrx[<IND>][LC_PREM_XCOEA] = <COEA>;
      lv_prem_mtrx[<IND>][LC_PREM_XCOEB] = <COEB>;
      lv_prem_mtrx[<IND>][LC_PREM_XCOEC] = <COEC>;
   }}

   BLOCK_DEF FUNC DBL lf_prem(DBL height_m, INT state_x):
      # density at of height meters, HEIGHT_M
      # from center of earth
      DBL coec;
      DBL coeb;
      DBL coea;
      DBL hght_i;
      DBL hght_j;
      DBL retvalu;
      DBL mass_a;
      DBL mass_b;
      DBL mass_i;
      DBL mass_ip;
      INT ii;

      IF NOT Kw.ismagic(lv_prem_magic):
         {PREM_INIT 0;      0.0;       0.0;       0.0; 0.0 }
         {PREM_INIT 1;1.2215E+6; 1.3088E+4;  1.911E-8;-2.1773E-10}
         {PREM_INIT 2; 3.480E+6; 1.2346E+4; 1.3976E-4;-2.4123E-10}
         {PREM_INIT 3; 3.630E+6; 7.3067E+3;-5.0007E-4; 0.0 }
         {PREM_INIT 4; 5.701E+6; 6.7823E+3;-2.4441E-4;-3.0922E-11}
         {PREM_INIT 5; 5.771E+6; 5.3197E+3;-2.3286E-4; 0.0 }
         {PREM_INIT 6; 5.971E+6; 1.1249E+4;-1.2603E-3; 0.0 }
         {PREM_INIT 7; 6.151E+6; 7.1083E+3;-5.9706E-4; 0.0 }
         {PREM_INIT 8;6.3466E+6;  2.691E+3; 1.0869E-4; 0.0 }
         {PREM_INIT 9; 6.356E+6;    2.9E+3;       0.0; 0.0 }
         {PREM_INIT 10;6.368E+6;    2.6E+3;       0.0; 0.0 }
         {PREM_INIT 11;6.371E+6;   1.02E+3;       0.0; 0.0 }
         # Init mass difference
         lv_prem_mtrx[0][LC_PREM_XMASSD] = 0.0;
         mass_i = 0.0;
         FOR ii FROM 1 TO 11:
            hght_i = lv_prem_mtrx[ii - 1][LC_PREM_XHEIGHT];
            mass_b = 2.0 * Kw.TAU * hght_i * hght_i * hght_i
                     * ((lv_prem_mtrx[ii][LC_PREM_XCOEC] / 5.0 * hght_i
                     + lv_prem_mtrx[ii][LC_PREM_XCOEB] / 4.0) * hght_i
                     + lv_prem_mtrx[ii][LC_PREM_XCOEA] / 3.0);

            hght_j = lv_prem_mtrx[ii][LC_PREM_XHEIGHT];
            mass_a = 2.0 * Kw.TAU * hght_j * hght_j * hght_j
                     * ((lv_prem_mtrx[ii][LC_PREM_XCOEC] / 5.0 * hght_j
                     + lv_prem_mtrx[ii][LC_PREM_XCOEB] / 4.0) * hght_j
                     + lv_prem_mtrx[ii][LC_PREM_XCOEA] / 3.0);

            mass_ip = mass_i;
            mass_i += (mass_a - mass_b);
            lv_prem_mtrx[ii][LC_PREM_XMASSD] = mass_ip - mass_b;
         FOR_END
         lv_prem_magic = Kw.magicset();
      IF_END

      IF height_m <= 0.0:
         retvalu = 0.0;
      ELSIF EARTH_RADIUS < height_m:
         IF state_x == 0:
            retvalu = 0.0;
         ELSE:
            retvalu = EARTH_MASS;
         IF_END
      ELSE:
         ii = 0;
         WHILE lv_prem_mtrx[ii][LC_PREM_XHEIGHT] < height_m:
            ii += 1;
         WHILE_END
         coea = lv_prem_mtrx[ii][LC_PREM_XCOEA];
         coeb = lv_prem_mtrx[ii][LC_PREM_XCOEB];
         coec = lv_prem_mtrx[ii][LC_PREM_XCOEC];

         IF state_x == 0:
            retvalu = (coec * height_m + coeb) * height_m + coea;
         ELSIF state_x == 1:
            hght_i = lv_prem_mtrx[ii][LC_PREM_XHEIGHT];
            coec /= 5.0;
            coeb /= 4.0;
            coea /= 3.0;

            mass_a = 2.0 * Kw.TAU * height_m * height_m * height_m
                     * ((coec * height_m + coeb ) * height_m + coea);
            retvalu = mass_a + lv_prem_mtrx[ii][LC_PREM_XMASSD];
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC DBL prem_density(DBL height_m):
      # Density (kg/m**3) of earth at a HEIGHT_M m from center
      RETURN lf_prem(height_m, LC_PREM_DENS);
   FUNC_END

   FUNC DBL prem_mass(DBL height_m):
      # Mass (kg) of a sphere, radius HEIGHT_M (m),
      # from center of earth
      RETURN lf_prem(height_m, LC_PREM_MASS);
   FUNC_END

   FUNC DBL prem_g(DBL height_m):
      # Acceleration due to gravity (m/s**2) at a
      # distance HEIGHT_M m from center of earth
      DBL retvalu;
      IF height_m <= 0.0:
         retvalu = 0.0;
      ELSE:
         retvalu = Kw.GRAVITATION * prem_mass(height_m)
                  / (height_m * height_m);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END

#    Copyright (C) 2015-2021 by Kevin D. Woerner
# 2021-05-10 kdw  temp conversion work
# 2021-04-25 kdw  music cent funcs
# 2021-04-20 kdw  var name change (mainly mm)
# 2021-04-15 kdw  indent work
# 2021-04-13 kdw  temp func work
# 2021-04-11 kdw  indent work
# 2021-04-06 kdw  func sqr[t]xp1m1
# 2021-04-04 kdw  time-[gv] mas[s]-v funcs
# 2021-04-03 kdw  comment change
# 2021-03-28 kdw  upped line length work
# 2021-03-15 kdw  lx_.* const names
# 2021-03-13 kdw  line len upped to 77
# 2021-03-07 kdw  print.fwip
# 2021-03-06 kdw  financial stuff
# 2021-03-05 kdw  long lines
# 2021-02-05 kdw  test lines
# 2021-02-04 kdw  add spaces to test lines
# 2021-02-02 kdw  var renam (temperature vars)
# 2021-01-29 kdw  loan.* comments
# 2021-01-20 kdw  loan payment
# 2020-12-27 kdw  black hole work
# 2020-12-26 kdw  black-hole stuff
# 2020-12-15 kdw  comment cleanup
# 2020-12-08 kdw  explicit module on constants
# 2020-12-06 kdw  comment changed
# 2020-12-03 kdw  float explicit const work
# 2020-11-28 kdw  macro syntax overhaul
# 2020-11-27 kdw  Celsius spelling error
# 2020-11-25 kdw  cbrt redo
# 2020-11-22 kdw  language comments changed
# 2020-10-03 kdw  s/print_.*/.*_print/
# 2020-10-01 kdw  no net change
# 2020-09-22 kdw  comment change
# 2020-09-20 kdw  blackbody dist work
# 2020-09-19 kdw  blackbody[lf] funcs
# 2020-09-09 kdw  print_base_out_fix sz arg is min size
# 2020-09-08 kdw  l[o]gx
# 2020-09-07 kdw  print_base_out_fix func
# 2020-08-20 kdw  boolean checks changed
# 2020-08-19 kdw  comment change
# 2020-08-17 kdw  macro syntax changed
# 2020-07-29 kdw  block-def work
# 2020-07-27 kdw  block syntax
# 2020-07-24 kdw  comment cleanup
# 2020-07-14 kdw  c[o]sm1 func
# 2020-07-07 kdw  sq[r]tx func
# 2020-07-02 kdw  pend[u]lum func
# 2020-07-01 kdw  tests modified
# 2020-06-30 kdw  tests changed
# 2020-06-23 kdw  func ranam
# 2020-06-18 kdw  Modulo operator II
# 2020-06-17 kdw  Modulo operator
# 2020-06-15 kdw  add prfx to con[t]fra.* funcs
# 2020-06-08 kdw  integral file
# 2020-06-03 kdw  writeonly keyword
# 2020-05-30 kdw  CONST syntax change
# 2020-05-20 kdw  rmed pr[i]nt_nu[m]2char2
# 2020-05-14 kdw  block for cbrt
# 2020-05-13 kdw  lang_.* vars
# 2020-05-12 kdw  language syntax
# 2020-05-11 kdw  REPL[A]CE replaced with LO[C]AL_CO[N]ST
# 2020-05-08 kdw  blocks added
# 2020-05-06 kdw  rmed boolean vars
# 2020-05-05 kdw  magic check func changed
# 2020-04-28 kdw  tweaks here and there
# 2020-04-26 kdw  BL[O]CK indentation work
# 2020-04-24 kdw  rem[q]uou func
# 2020-04-23 kdw  const format change
# 2020-04-19 kdw  pri[n]t_nu[m]2char rework
# 2020-04-15 kdw  tests added
# 2020-04-14 kdw  tests added
# 2020-04-12 kdw  comment change
# 2020-04-11 kdw  macro arg format
# 2020-04-10 kdw  comment change
# 2020-04-08 kdw  preprocess sigil change
# 2020-04-02 kdw  no m[o]d func
# 2020-04-01 kdw  t[a]n to TA[N]
# 2020-03-30 kdw  bla[c]kbo[d]y work
# 2020-03-29 kdw  comment change
# 2020-03-16 kdw  sigm[o]id3d
# 2020-03-09 kdw  LO[C]AL_.* keywords
# 2020-03-08 kdw  PR[I]NTVAL change
# 2020-03-06 kdw  L[A]NG.* names
# 2020-03-03 kdw  comment change
# 2020-03-01 kdw  .*_NE[X]T deprecated, et al.
# 2020-02-26 kdw  comment change
# 2020-02-21 kdw  ellipse file
# 2020-02-14 kdw  incomplete beta work
# 2020-02-03 kdw  .*_LOOP changed
# 2020-01-24 kdw  func rearrangement
# 2020-01-22 kdw  kevy func; num2char rework
# 2020-01-21 kdw  num2char2 experiment
# 2020-01-16 kdw  func fm[o]ds
# 2020-01-08 kdw  rmed ran[d]cdf file
# 2019-12-26 kdw  module name addded to funcs
# 2019-12-11 kdw  bas[e]_outf func
# 2019-12-06 kdw  binary search in nu[m]2char
# 2019-11-18 kdw  black-body work
# 2019-11-17 kdw  blackbody stuff
# 2019-10-23 kdw  temperature conversions
# 2019-10-17 kdw  dont print nl in contfra
# 2019-10-15 kdw  neg arg for contfrac
# 2019-10-08 kdw  D[B]LS[I]G rmed
# 2019-10-04 kdw  comment change
# 2019-09-21 kdw  several const renamd
# 2019-09-10 kdw  LAN[G]UAGE NOT to LAN[G]UAGE_N[O]T
# 2019-09-07 kdw  log1m rmed
# 2019-08-26 kdw  PRI[N]TS changed to PR[I]NTSTR
# 2019-08-22 kdw  comment changed
# 2019-08-18 kdw  B[O]OL changed to B[O]L
# 2019-08-17 kdw  L[O]G changed to LN
# 2019-08-12 kdw  insert file cdf
# 2019-08-11 kdw  language comments
# 2019-08-07 kdw  language comments
# 2019-08-06 kdw  rmed backshlashes, macro arg renam
# 2019-06-27 kdw  float equality work
# 2019-06-26 kdw  pow work
# 2019-06-12 kdw  tempf tofrom tempc work
# 2019-06-07 kdw  die string change
# 2019-06-02 kdw  NR_ changed to RAPHSON_
# 2019-05-31 kdw  NR_DO changed to RAPHSON_LOOP; et al
# 2019-05-29 kdw  comment changed
# 2019-05-28 kdw  temp_[fc] vars
# 2019-05-26 kdw  temp[fc] funcs
# 2019-05-24 kdw  array var renam
# 2019-05-20 kdw  explicit constants
# 2019-05-08 kdw  func descripts
# 2019-05-07 kdw  smooth func [0,1] changed to [-1,1]
# 2019-05-01 kdw  consts explicit module name
# 2019-04-22 kdw  F[U]NC keyword
# 2019-04-16 kdw  THEN, loop_DO keywords experiment
# 2019-03-19 kdw  re[t]_val changed to re[t]valu
# 2019-03-18 kdw  macro syntax changed
# 2019-03-09 kdw  .*mean() func renam
# 2019-03-08 kdw  is[e]qual changed to is[e]q, et al.
# 2019-03-04 kdw  loop-limit work
# 2019-02-28 kdw  REP[L]ACE/DE[F]INE work
# 2019-02-04 kdw  topy[h] abs changed to ABS
# 2019-01-31 kdw  topy[h]; iime.hires
# 2019-01-27 kdw  topy[h]1
# 2019-01-23 kdw  added call keyword to base-out
# 2019-01-13 kdw  var rena; reorg
# 2018-12-18 kdw  kwelements separated
# 2018-12-17 kdw  base_.* funcs
# 2018-12-12 kdw  macros.fwip
# 2018-12-10 kdw  module specific refs
# 2018-12-09 kdw  cbrt rework using NR
# 2018-12-03 kdw  newton-raphson method
# 2018-11-29 kdw  upper cased fwip defined funcs
# 2018-11-28 kdw  funcs pow2, pow10, log2
# 2018-11-26 kdw  PL_ prfxs
# 2018-11-06 kdw  topyh differentiable
# 2018-11-05 kdw  topyh
# 2018-10-27 kdw  experiment with other Kw.*.fwip
# 2018-10-08 kdw  vbdotnet stuff
# 2018-10-05 kdw  pow rework
# 2018-10-03 kdw  loop lim now replaced
# 2018-09-27 kdw  SE[C]ANT comments
# 2018-09-25 kdw  dot net work
# 2018-09-08 kdw  SE[C]ANT_DO redef
# 2018-07-23 kdw  private func renam
# 2018-07-19 kdw  comments; array reformat
# 2018-07-17 kdw  private lf_.* funcs
# 2018-07-13 kdw  float number reformt
# 2018-06-27 kdw  pow func redefd
# 2018-06-19 kdw  mved several funcs to simple
# 2018-06-14 kdw  temp conversion changed
# 2018-06-09 kdw  mved tests
# 2018-06-07 kdw  more tests
# 2018-05-22 kdw  comment change
# 2018-05-20 kdw  const work
# 2018-05-18 kdw  LAN[G]UAGE syntax change
# 2018-05-17 kdw  ARRAY.* and HOR[N]ER syntax
# 2018-05-14 kdw  BL[O]CK syntax
# 2018-05-13 kdw  MODE.* syntax change
# 2018-04-24 kdw  comments
# 2018-04-19 kdw  consts rework
# 2018-04-03 kdw  rm () from return
# 2018-04-02 kdw  Prototype, et al.
# 2018-04-01 kdw  LAN[G]UAGE_E[N]D
# 2018-03-26 kdw  macro redef
# 2018-03-17 kdw  comment change
# 2018-03-12 kdw  made PP statements not need semicolon
# 2018-02-21 kdw  temperature conversion work
# 2018-02-19 kdw  secant and macro refactor
# 2018-02-16 kdw  iseq, isgt, islt funcs
# 2018-02-10 kdw  c[o]nstants.f[w]ip
# 2018-02-01 kdw  temperature stuff
# 2018-01-29 kdw  julian consts renamd
# 2018-01-04 kdw  added elliptic.fwip
# 2017-12-13 kdw  added shc.fwip
# 2017-11-27 kdw  converted an AW[A]IT loop to a F[O]R loop
# 2017-11-26 kdw  FR[O]M/B[Y] keywords
# 2017-11-24 kdw  FR[O]M
# 2017-11-22 kdw  var renam
# 2017-11-14 kdw  fm[o]du added
# 2017-11-03 kdw  fixed f2c (upsidedown conversion factor)
# 2017-10-28 kdw  horner rework
# 2017-10-22 kdw  no net change
# 2017-10-21 kdw  LAN[G]UAGE syntax changed
# 2017-10-06 kdw  rm astro and earth stuff
# 2017-10-02 kdw  astro work
# 2017-09-29 kdw  added squareroot, cuberoot functions
# 2017-09-28 kdw  const-astro.fwip
# 2017-09-26 kdw  mved some func to earth
# 2017-09-22 kdw  comment change
# 2017-09-20 kdw  number format change
# 2017-09-13 kdw  vincenty work
# 2017-09-12 kdw  mved day2[h]ms to julian
# 2017-09-06 kdw  UNITS support
# 2017-08-31 kdw  ...LAN[G]UAGE
# 2017-08-30 kdw  s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-22 kdw  INS[E]RT_F[I]LE syntax changed
# 2017-08-21 kdw  .*_P[E]R_.* rmed
# 2017-08-20 kdw  rmed/renamd .*_P[E]R_.* vars
# 2017-08-18 kdw  lower case constants
# 2017-08-11 kdw  var renam
# 2017-07-06 kdw  minor comment change
# 2017-06-23 kdw  REPLACE redo
# 2017-06-21 kdw  LANG_.* AND MASTER.* change
# 2017-06-13 kdw  comment update
# 2017-06-08 kdw  magic stuff
# 2017-06-03 kdw  PRINT.* changed
# 2017-06-01 kdw  line.fwip added and deleted
# 2017-05-03 kdw  PROTOTYPE format changed
# 2017-05-02 kdw  var renam app changed to appr
# 2017-04-20 kdw  func changed to function
# 2017-04-18 kdw  bessel
# 2017-04-11 kdw  partition
# 2017-03-31 kdw  "NE" changed to "<>", etc
# 2017-03-29 kdw  "<>" changed to "NE", etc
# 2017-03-24 kdw  minor reorg
# 2017-03-22 kdw  minor cleanup
# 2017-03-19 kdw  minor tweak
# 2017-03-17 kdw  space after comma
# 2017-03-13 kdw  VB: pow function
# 2017-03-12 kdw  shorten long comments
# 2017-03-10 kdw  get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  futile experiment
# 2017-03-06 kdw  sigils rmed
# 2017-03-01 kdw  var[y]log-a[d]d space messup
# 2017-02-28 kdw  REQ[U]IRE function ()
# 2017-02-24 kdw  REP[L]ACE rework, et al
# 2017-02-23 kdw  var array nam change
# 2017-02-14 kdw  FWIP Loop syntax changed
# 2017-02-13 kdw  FWIP language change
# 2017-02-12 kdw  FWIP language change
# 2017-02-08 kdw  .PRO[T]OTYPE
# 2017-01-08 kdw  INSERT syntax change
# 2017-01-06 kdw  ..LAN[G]UAGE_[I]S.* stuff
# 2017-01-05 kdw  log1[pm]
# 2016-12-28 kdw  rearrangement
# 2016-12-27 kdw  mved earth* to sphere*, et al.
# 2016-12-26 kdw  mved *_distance funcs to new earth.fwip
# 2016-12-20 kdw  failed experiment w/ powers
# 2016-12-02 kdw  ..INS[E]RT changed
# 2016-11-28 kdw  file suffix change
# 2016-11-27 kdw  square, cube
# 2016-11-25 kdw  constant renam
# 2016-11-24 kdw  LAN[G]UAGE_N[O]T to LAN[G]UAGE_IFN[O]T
# 2016-11-23 kdw  CNST changed to REA[D]ONLY
# 2016-11-22 kdw  high-precision EU[L]ER calc experiment
# 2016-11-21 kdw  DE[F] changed to FU[N]C
# 2016-11-20 kdw  language change
# 2016-11-19 kdw  minor rearrangement
# 2016-11-17 kdw  sinx rmed; cbrtx renamd
# 2016-11-16 kdw  magic stuff
# 2016-11-15 kdw  MOD/BIT* syntax change
# 2016-11-14 kdw  mod[u]lo
# 2016-11-11 kdw  minor refactor
# 2016-11-09 kdw  FO[R]EVER loop rmed
# 2016-11-08 kdw  AW[A]IT.*COU[N]T syntax
# 2016-11-07 kdw  __LANG_* syntax changed
# 2016-11-06 kdw  isz[e]ro changed to ise[q]ual
# 2016-11-01 kdw  hyper
# 2016-10-30 kdw  comment in fmod
# 2016-10-28 kdw  comment reorg
# 2016-10-14 kdw  _p added to several vars
# 2016-10-10 kdw  BC:moved var decls in un and tn
# 2016-10-08 kdw  lowercased Tn for BC
# 2016-10-07 kdw  Tn
# 2016-09-28 kdw  change in vk[k]cp.sh
# 2016-09-19 kdw  not magic; _[_]INSERT[_]_
# 2016-09-14 kdw  added () to return statements
# 2016-09-14 kdw  lang change
# 2016-09-13 kdw  lang change
# 2016-09-08 kdw  return statement tweak
# 2016-09-01 kdw  comment tweak
# 2016-08-25 kdw  hypot prevent div by 0
# 2016-07-22 kdw  fmod issues
# 2016-07-19 kdw  tweak (float numbers)
# 2016-05-25 kdw  debugging compiler
# 2016-05-24 kdw  long lines
# 2016-05-18 kdw  comment change
# 2016-05-12 kdw  VIS[U]ALBA[S]IC6 rename
# 2016-05-04 kdw  deprecated P[R]INT
# 2016-05-02 kdw  debugging on darw[i]n
# 2016-04-27 kdw  comment tweak
# 2016-03-12 kdw  cbrt debugging
# 2016-02-29 kdw  comment tweak
# 2016-01-22 kdw  long lines
# 2016-01-05 kdw  minor comment change
# 2015-12-31 kdw  bounded (possible) infinite loops
# 2015-12-30 kdw  __DECLARE__
# 2015-12-28 kdw  rearranged includes
# 2015-12-28 kdw  __IF_X__ changed to __IF_NONE__
# 2015-12-21 kdw  nested __IFs
# 2015-12-11 kdw  __ENDIF__ renamed
# 2015-12-10 kdw  i[s]zero stuff
# 2015-12-09 kdw  debugging
# 2015-12-04 kdw  end-cr
# 2015-12-03 kdw  approximations
# 2015-11-27 kdw  long lines
# 2015-11-26 kdw  long lines
# 2015-11-19 kdw  long lines
# 2015-11-15 kdw  m[a]gic stuff
# 2015-11-13 kdw  cb[r]t tweak; long lines changed
# 2015-11-12 kdw  continued fraction expansion
# 2015-11-05 kdw  par[a]bola.fwip rmed
# 2015-11-02 kdw  compiler change
# 2015-11-01 kdw  interp[o]lation
# 2015-10-29 kdw  refactored c[b]rt
# 2015-10-28 kdw  refactored c[b]rt
# 2015-10-26 kdw  fm[o]d2
# 2015-10-22 kdw  tweak
# 2015-10-18 kdw  tweak
# 2015-10-17 kdw  tweak
# 2015-10-16 kdw  rmed su[n].fwip, add ju[l]ian.fwip
# 2015-10-14 kdw  su[n].fwip
# 2015-10-13 kdw  _[_]DEFI[N]E_[_]
# 2015-10-10 kdw  is* functions moved
# 2015-10-09 kdw  [agh]+m1 improvements
# 2015-10-08 kdw  i[n]va[g]m1()
# 2015-10-07 kdw  L[N]G_MA[X]IMUM
# 2015-10-05 kdw  i[s]alm[o]stequal
# 2015-10-03 kdw  ro[u]ndy uses rou[n]d
# 2015-10-02 kdw  earranged order of functions
# 2015-10-01 kdw  float equality checks to is.*
# 2015-09-30 kdw  _[_]IF_[N]OT_.*
# 2015-09-29 kdw  variables renamed; fixed c[b]rt
# 2015-09-28 kdw  variable rename in par[a]bola_a[x]is
# 2015-09-27 kdw  par[a]bola_a[x]is
# 2015-09-27 kdw  infinite loop in c[b]rt function
# 2015-09-26 kdw  debugging agm vs BCC
# 2015-09-25 kdw  B[I]T* format change
# 2015-09-24 kdw  bit ops changed
# 2015-09-22 kdw  Units on constants
# 2015-09-22 kdw  VB6 VBDOTNET: no m[o]d function
# 2015-09-21 kdw  m[o]d function
# 2015-09-20 kdw  moved several functions
# 2015-09-19 kdw  redim redo
# 2015-09-18 kdw  renamed various
# 2015-09-17 kdw  at[o]thenmodp, co[n]tfrac
# 2015-09-16 kdw  functions var[i]ance and ave[r]age
# 2015-09-15 kdw  long lines changed
# 2015-09-14 kdw  g[p]f
# 2015-09-11 kdw  dont print newlines
# 2015-09-10 kdw  e[r]f stuff
# 2015-09-09 kdw  rmed empty lines
# 2015-09-08 kdw  mv global vars to where theyre used
# 2015-09-07 kdw  n[2]com[b]r
# 2015-09-06 kdw  bino[m]ial
# 2015-09-04 kdw  ber[n]oulli[nd], *_EP[S]ILON
# 2015-09-03 kdw  array passing addressed
# 2015-09-02 kdw  cli[p] refactor
# 2015-09-01 kdw  s[t]ts_n[e]w* stuff
# 2015-08-31 kdw  RE[D]IM stuff
# 2015-08-30 kdw  BC long lines
# 2015-08-29 kdw  more BC stuff
# 2015-08-28 kdw  BC stuff
# 2015-08-27 kdw  random number work
# 2015-08-26 kdw  random number work
# 2015-08-25 kdw  addeed GL[O]BAL designator for Python
# 2015-08-24 kdw  fixed syntax for VB
# 2015-08-23 kdw  rmed unneeded ()
# 2015-08-22 kdw  bern[o]ulli refactor
# 2015-08-21 kdw  kw[2].pl change (C stuff)
# 2015-08-20 kdw  kw[2].pl change
# 2015-08-19 kdw  stts_* stuff
# 2015-08-18 kdw  redid some stat stuff
# 2015-08-17 kdw  syntax error
# 2015-08-16 kdw  added CO[N]STs, stts_*
# 2015-08-15 kdw  tweak
# 2015-08-14 kdw  rmed () in syntax of WH[I]LE, FO[R], I[F]
# 2015-08-12 kdw  tweak
# 2015-08-11 kdw  touched
# 2015-08-10 kdw  comment changed
# 2015-08-09 kdw  sigma*, et al.
# 2015-08-08 kdw  cdf[k]s2; randtri, randnbd, randbin
# 2015-08-07 kdw  longlines broken up
# 2015-08-06 kdw  keyword BEG rmed
# 2015-08-05 kdw  fa[c]torial, et al.
# 2015-08-04 kdw  std[e]v2sp[r]ead ; rto[iz]
# 2015-08-03 kdw  VB6 VBDOTNET debugging
# 2015-08-02 kdw  python fixes; GL[O]BAL
# 2015-08-01 kdw  python fixes; CONT[I]NUE
# 2015-07-31 kdw  F[O]R loops
# 2015-07-30 kdw  refactor
# 2015-07-29 kdw  refactor / more functions
# 2015-07-28 kdw  refactor / rename
# 2015-07-27 kdw  typo
# 2015-07-17 kdw  *normal stuff
# 2015-07-16 kdw  e[r]f
# 2015-07-15 kdw  W[0]
# 2015-07-14 kdw  gamma
# 2015-07-13 kdw  created

IMPORT_MASTER; # insert master functions before other code
#TEST: atan2(-1, 1) == -PI/4;
#TEST: atan2(-1, -1) == -3*PI/4;
#TEST: atan2(1, -1) == 3*PI/4;
#TEST: atan2(0, -18) == PI;
#TEST: atan2(0, 18)-0;
#TEST: atan2(-18, 0) == -PI/2;
#TEST: atan2(18, 0) == PI/2;
#TEST: cbrt(3) == 1.44224957030740838232163831078010958839186925;
#TEST: ln(3) == 1.0986122886681096913952452369225257046474905578;
#TEST: exp(2) == 7.389056098930650227230427460575007813180315571;
#TEST: sin(1) == 0.841470984807896506652502321630298999622563061;
#TEST: cos(1) == 0.540302305868139717400936607442976603732310421;
#TEST: log(exp(4.7)) == 4.7;
#TEST: cbrt(pow(2.73, 3)) == 2.73;
#TEST: pow(frac(sqrt(17)) + floor(sqrt(17)), 2) == 17;

# Start doing things, ..
{INSERT_FILE "Macros.fwip" }

{INSERT_FILE "constants.fwip" }
#TEST: EULER == 0.5772156649015328606065120900824024310421593359;
{INSERT_FILE "simple.fwip" }

## Exponential related functions
FUNC DBL ln(DBL xx):
   # logarithm base E, of XX
   RETURN LN(xx);
FUNC_END
FUNC DBL lg(DBL xx):
   # logarithm base 2 of XX
   RETURN LN(xx) / TWOLN;
FUNC_END
FUNC DBL log10(DBL xx):
   # logarithm base 10 of XX
   RETURN LN(xx) / LN(10.0);
FUNC_END
FUNC DBL logx(DBL xx, DBL bb):
   # logarithm base BB of XX
   RETURN LN(xx) / LN(bb);
FUNC_END
FUNC DBL l10(DBL xx):
   # logarithm base 10 of XX
   RETURN LN(xx) / LN(10.0);
FUNC_END
#TEST: l10(100) == 2;

LANGUAGE_NOT LANG_C:                                             # C has log2
   FUNC DBL log2(DBL xx):
      # logarithm base 2 of XX
      RETURN LN(xx) / Kw.TWOLN;
   FUNC_END
LANGUAGE_END                                                     # C has log2

LANGUAGE_NOT LANG_C LANG_PYTHON:                        # C, PYTHON have fmod
   FUNC DBL fmod(DBL xx, DBL yymodulus):
      #    == XX - RTOZ(XX / YYMODULUS) * YYMODULUS
      # return value has same sign as XX
      DBL retvalu;
      DBL qu;

      IF yymodulus < 0.0 OR 0.0 < yymodulus:
         qu = xx / yymodulus;
         IF qu < 0.0:
            retvalu = xx - CEIL(qu) * yymodulus;
         ELSE:
            retvalu = xx - FLOOR(qu) * yymodulus;
         IF_END
      ELSE:
         retvalu = 0.0;
      IF_END
      RETURN retvalu;
   FUNC_END
   FUNC DBL modf(DBL xx, WRITEONLY DBL ret_int_arr_p[]):
      # Split xx into a integer part returned in RET_INT_ARR_P,
      #    and an fractional part which is returned
      DBL retvalu;
      DBL int_part;

      IF xx < 0.0:
         int_part = CEIL(xx);
      ELSIF 0.0 < xx:
         int_part = FLOOR(xx);
      ELSE:
         int_part = 0;
      IF_END
      ret_int_arr_p[0] = xx - int_part;
      RETURN retvalu;
   FUNC_END
LANGUAGE_END                                            # C, PYTHON have fmod

FUNC DBL fmody(DBL xx, DBL yymodulus):
   #    == XX - FLOOR(XX / YYMODULUS) * YYMODULUS
   # return value has same sign as YYMODULUS
   DBL retvalu;

   IF yymodulus < 0.0 OR 0.0 < yymodulus:
      retvalu = xx - FLOOR(xx / yymodulus) * yymodulus;
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL fmodu(DBL xx, DBL yymodulus):
   #   == XX - FLOOR(XX / ABS(YYMODULUS)) * ABS(YYMODULUS)
   # return value always has a positive sign
   # ZZ in [0, ABS(YYMODULUS)) such that
   #    XX = NN * YYMODULUS + ZZ for some integer NN
   DBL retvalu;

   IF yymodulus < 0.0 OR 0.0 < yymodulus:
      retvalu = fmod(xx, yymodulus);
      IF retvalu < 0.0:
         retvalu += ABS(yymodulus);
      IF_END
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST: fmodu(-5.7,-2) == 0.3;
#TEST: fmodu(5.7,-2) == 1.7;

FUNC DBL remquou(DBL xx
         , DBL yymodulus
         , WRITEONLY DBL ret_int_arr_p[]):
   # return value is remainder of XX / YYMODULUS
   # RET_INT_ARR_P[0] is always positive
   DBL retvalu;
   DBL qu;
   DBL fl;

   IF yymodulus < 0.0 OR 0.0 < yymodulus:
      qu = xx / yymodulus;
      fl = FLOOR(qu);
      retvalu = qu - fl;
   ELSE:
      fl = 0.0;
      retvalu = xx;
   IF_END
   ret_int_arr_p[0] = fl;
   RETURN retvalu;
FUNC_END

FUNC DBL fmods(DBL xx, DBL yymodulus):
   # ZZ in [-ABS(YYMODULUS)/2,ABS(YYMODULUS)/2) such that
   #    XX = NN * YYMODULUS + ZZ for some integer NN
   DBL retvalu;
   DBL ayy;
   DBL lim;

   IF yymodulus < 0.0 OR 0.0 < yymodulus:
      retvalu = fmod(xx, yymodulus);
      ayy = ABS(yymodulus);
      lim = ayy / 2.0;
      IF retvalu < -lim:
         retvalu += ayy;
      ELSIF lim <= retvalu:
         retvalu -= ayy;
      IF_END
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END

#TEST: pow(5, 3) == 125;
#TEST: pow(5, -3) == 0.008;

FUNC DBL pow2(DBL expo):
   # 2**EXPO
   RETURN POW(2.0, expo);
FUNC_END

FUNC DBL pow10(DBL expo):
   # 10**EXPO
   RETURN POW(10.0, expo);
FUNC_END

FUNC DBL sigmoid(DBL xx):
   # SIGMOID function (-inf, inf) to (0, 1)
   RETURN 1.0 / (1.0 + EXP(-xx));
FUNC_END

FUNC DBL sigmoidinv(DBL xx):
   # inverse SIGMOID function (0, 1) to (-inf, inf)
   RETURN -LN(((1.0 / xx - 0.5) - 0.5));
FUNC_END

FUNC DBL sigmoid3(DBL aa
         , DBL bb
         , DBL xx):
   # An infinitely differential function (-Inf,Inf) to (0,1)
   #   going thru (0, AA) and (1,BB)
   # sigmoid(xx) = sigmoid3(0.5, E / (E + 1), xx);
   DBL retvalu;
   DBL alfa;
   DBL xzero;
   DBL taa;

   IF aa <= 0.0 OR 1.0 <= aa OR bb <= 0.0 OR 1.0 <= bb:
      retvalu = 0.0;
   ELSE:
      taa = LN((1.0 - aa) / aa);
      alfa = LN((1.0 - bb) / bb) - taa;
      xzero = -taa / alfa;
      retvalu = 1.0 / (1.0 + EXP(alfa * (xx - xzero)));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL taninv3(DBL aa
         , DBL bb
         , DBL xx):
   # a function in arctan family passing through points (0,AA) and (1,BB)
   DBL retvalu;
   DBL alfa;
   DBL taa;

   IF aa <= 0.0 OR 1.0 <= aa OR bb <= 0.0 OR 1.0 <= bb:
      retvalu = 0.0;
   ELSE:
      taa = TAN((aa - 0.5) * Kw.PI);
      alfa = TAN((bb - 0.5) * Kw.PI) - taa;
      retvalu = taninv(alfa * xx + taa) / Kw.PI + 0.5;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL sigmoid3d(DBL aa
         , DBL bb
         , DBL xx):
   # derivative of sigmoid3()
   DBL retvalu;
   DBL alfa;
   DBL xzero;
   DBL taa;
   DBL expa;

   IF aa <= 0.0 OR 1.0 <= aa OR bb <= 0.0 OR 1.0 <= bb:
      retvalu = 0.0;
   ELSE:
      taa = LN((1.0 - aa) / aa);
      alfa = LN((1.0 - bb) / bb) - taa;
      xzero = -taa / alfa;
      expa = EXP(alfa * (xx - xzero));
      retvalu = -alfa * expa / Kw.square(1.0 + expa);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL sqrtx(DBL xx):
   # a real-valued extension of square root functions
   DBL retvalu;
   IF xx < 0.0:
      retvalu = -SQRT(-xx);
   ELSE:
      retvalu = SQRT(xx);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL smooth(DBL xx):
   # An infinitely differential function [-1,1] to [0,1]
   DBL retvalu;

   IF xx <= -1.0:
      retvalu = 0.0;
   ELSIF 1.0 <= xx:
      retvalu = 1.0;
   ELSE:
      retvalu = sigmoid(4.0 * xx / (1.0 - xx * xx));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL hypot(DBL xx, DBL yy):
   # length of hypotenuse of a right triangle with legs XX and YY
   # sqrt(XX*XX+YY*YY), avoiding round off error
   DBL retvalu;
   DBL axx;
   DBL ayy;

   axx = ABS(xx);
   ayy = ABS(yy);
   IF axx < ayy:
      retvalu = ayy;
      ayy = axx;
      axx = retvalu;
   IF_END
   # Now 0 <= ayy <= axx
   IF 0.0 < axx:
      IF ayy < Kw.DBLEPS * axx:
         retvalu = axx;
      ELSE:
         ayy /= axx;
         retvalu = axx * SQRT(1.0 + ayy * ayy);
      IF_END
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST: hypot(3.0, 4.0) == 5.0;

FUNC DBL hypot1(DBL xx):
   # length of hypotenuse of a right triangle with legs XX and 1.0
   # sqrt(1 + XX*XX), avoiding round off error
   RETURN hypot(1.0, xx);
FUNC_END
#TEST: square(hypot1(2)) == 5.0;

FUNC DBL hypot1inv(DBL xx):
   # length of aleg of a right triangle with hypotenuse 1.0 and other leg XX
   # sqrt(XX * XX - 1); i.e. HYPOT1INV(HYPOT1(XX))==XX
   RETURN SQRT(xx * xx - 1.0);
FUNC_END
#TEST: hypot1inv(sqrt(5)) == 2.0;

FUNC DBL hypot3(DBL xx, DBL yy, DBL zz):
   # distance from (XX,YY,ZZ) to (0,0,0)
   RETURN SQRT(xx * xx + yy * yy + zz * zz);
FUNC_END
#TEST: hypot3(1,2,3) == sqrt(14);

FUNC DBL topyh(DBL xx, DBL yy):
   # length of a leg of a right triangle with hypotenuse XX and other leg YY
   # sqrt(abs(XX*XX-YY*YY))
   DBL retvalu;
   DBL xsq;
   DBL ysq;

   xsq = xx * xx;
   ysq = yy * yy;
   IF ysq <= 0.0:
      retvalu = xx;
   ELSIF xsq <= 0.0:
      retvalu = yy;
   ELSIF xsq < ysq:
      xsq /= ysq;
      retvalu = -sign(xx) * SQRT(1.0 - xsq) * ABS(yy);
   ELSE:
      ysq /= xsq;
      retvalu = SQRT(1.0 - ysq) * xx;
   IF_END

   RETURN retvalu;
FUNC_END
#TEST: topyh(13.0,12.0) == 5.0;

FUNC DBL topyh1(DBL xx):
   # length of leg of a right triangle with
   # hypotenuse 1.0 and other leg XX
   # topyh(1.0,XX) == SQRT(1 - XX * XX)
   DBL retvalu;

   IF xx < -1.0 OR 1.0 < xx:
      retvalu = -SQRT(xx * xx - 1.0);
   ELSE:
      retvalu = SQRT(1.0 - xx * xx);
   IF_END

   RETURN retvalu;
FUNC_END
#TEST: topyh1(0.5) == sqrt(3.0) / 2.0;

FUNC INT cnv_dbl2si16(DBL xx):
   # (safely) convert a DOUBLE to an 16-bit signed INTEGER
   DBL retvalu;

   IF xx <= Kw.SI16MIN:
      retvalu = Kw.SI16MIN;
   ELSIF xx <= Kw.SI16MAX:
      retvalu = FLOORL(xx + 0.5);
   ELSE:
      retvalu = Kw.SI16MAX;
   IF_END

   RETURN retvalu;
FUNC_END

{MACRO TEMP_CONVERSION <NM> ; <LC> ; <UC> {
   FUNC DBL k2temp<LC>(DBL temp_k):
      # Kelvin to a <NM> temperature
      RETURN (temp_k - Kw.K_AT_0TEMP<UC>) * Kw.KELVIN / Kw.DEG<UC>;
   FUNC_END
   FUNC DBL temp<LC>2k(DBL temp_<LC>):
      # <NM> temperature to Kelvin
      RETURN temp_<LC> * Kw.DEG<UC> / Kw.KELVIN + Kw.K_AT_0TEMP<UC>;
   FUNC_END
}}

{TEMP_CONVERSION Celsius    ; c ; C }
{TEMP_CONVERSION Fahrenheit ; f ; F }
{TEMP_CONVERSION Rankine    ; r ; R }

FUNC DBL tempf2tempc(DBL temp_f):
   # Fahrenheit temperature to a Celsius temperature
   RETURN (temp_f - TEMPF_AT_0TEMPC) * DEGF;
FUNC_END

FUNC DBL tempc2tempf(DBL temp_c):
   # Celsius temperature to a Fahrenheit temperature
   RETURN temp_c / DEGF + TEMPF_AT_0TEMPC;
FUNC_END

#TEST: tempf2k(212) == 373.15;
#TEST: tempf2tempc(185) == 85;
#TEST: tempc2tempf(37) == 98.6;
#TEST: tempf2tempc(tempc2tempf(3.2)) == 3.2;

{INSERT_FILE "is.fwip" }

BLOCK: # MAGIC stuff
   BLOCK_DEF CONST LC_MAGIC_INT 2070108020;
   BLOCK_DEF CONST LC_MAGIC_INT_NOT 301040105;
   FUNC INT magicset(NUL):
      # return "magic" number
      RETURN LC_MAGIC_INT;
   FUNC_END
   FUNC INT magicnot(NUL):
      # return something NOT "magic" number
      RETURN LC_MAGIC_INT_NOT;
   FUNC_END
BLOCK_END # MAGIC stuff

FUNC BOL ismagic(INT xx):
   # does XX equal magic number
   RETURN iseq(xx, magicset());
FUNC_END

{INSERT_FILE "round.fwip" }
{INSERT_FILE "trig.fwip" }

FUNC DBL sqrtxp1m1(DBL xx):
   # SQRT(1+XX)-1 via
   DBL retvalu;

   IF ABS(xx) < 0.01:
      retvalu = ((((((((
               - 429.0 / 32768.0) * xx
               + 33.0 / 2048.0) * xx
               - 21.0 / 1024.0) * xx
               + 7.0 / 256.0) * xx
               - 5.0 / 128.0) * xx
               + 1.0 / 16.0) * xx
               - 1.0 / 8.0) * xx
               + 1.0 / 2.0) * xx;
   ELSE:
      retvalu = SQRT(1.0 + xx) - 1.0;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL ln1p(DBL xx):
   # ln(1 + XX) accurately via
   # ln(1+x) = (x**1/1 - x**2/2 + x**3/3 - x**4/4 + ...
   #         = x (1 - x (1/2 + x (1/3 - x (1/4 + ...
   DBL retvalu;
   DBL sum_curr;
   INT jj;
   INT start;

   IF 0.1 < ABS(xx):
      retvalu = LN(1.0 + xx);
   ELSIF Kw.iszero(xx):
      retvalu = 0.0;
   ELSE:
      start = CEIL(ABS(LN(Kw.DBLEPS) / LN(ABS(xx))));
      IF start < 2:
         start = 2;
      IF_END
      sum_curr = 0.0;
      FOR jj FROM start TO 1 BY -1:
         sum_curr = 1.0 / jj - sum_curr * xx;
      FOR_END
      retvalu = sum_curr * xx;
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL expm1(DBL xx):
   # exp(XX) - 1 accurately via
   #    == x**1/1 + x**2/2 + x**3/6 + x**4/24 ...
   #    == x (1 + x/2 (1 + x/3 (1 + x/4 (...
   DBL retvalu;
   DBL sum_curr;
   INT jj;
   INT start;

   IF 0.1 < ABS(xx):
      retvalu = EXP(xx) - 1.0;
   ELSIF Kw.iszero(xx):
      retvalu = 0.0;
   ELSE:
      start = CEIL(ABS(LN(Kw.DBLEPS) / LN(ABS(xx))));
      IF start < 2:
         start = 2;
      IF_END
      sum_curr = 0.0;
      FOR jj FROM start TO 1 BY -1:
         sum_curr = xx * (1.0 + sum_curr) / jj;
      FOR_END
      retvalu = sum_curr;
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL cosm1(DBL xx):
   # cos(XX) - 1 accurately via
   #    == - x**2/2 + x**4/24 - x**6/720 ...
   #    == - x**2/2 (1 - x**2/12 (1 + x**2/30 (1 - ...
   DBL retvalu;
   DBL sum_curr;
   INT jj;
   INT start;
   DBL xr_sqr;

   IF 0.1 < ABS(xx):
      retvalu = COS(xx) - 1.0;
   ELSIF Kw.iszero(xx):
      retvalu = 0.0;
   ELSE:
      start = CEIL(ABS(LN(Kw.DBLEPS) / LN(ABS(xx))));
      IF start < 6:
         start = 6;
      ELSIF Kw.isodd(start):
         start += 1;
      IF_END
      xr_sqr = - xx * xx;
      sum_curr = 1.0 / (start * (start + 1.0));
      FOR jj FROM start TO 2 BY -2:
         sum_curr += 1.0;
         sum_curr *= xr_sqr / (jj * (jj - 1.0));
      FOR_END
      retvalu = sum_curr;
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL lns(DBL xx):
   # logarithm base E of ABS(XX) , bounded
   DBL aa;
   DBL retvalu;

   aa = ABS(xx);
   IF aa < 1.0 / Kw.DBLMAX:
      retvalu = -Kw.DBLMAXLN - 1.0;
   ELSE:
      retvalu = LN(aa);
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL trip(DBL xx):
   # piecewise linear function from -1 to 1, period 1
   # TRIP(0)=1  TRIP(0.5)=-1  TRIP(1)=1
   DBL retvalu;
   DBL fx;

   fx = 4.0 * frac(xx);

   IF fx < 2.0:
      retvalu = 1.0 - fx;
   ELSE:
      retvalu = fx - 3.0;
   IF_END
   RETURN retvalu;
FUNC_END

BLOCK: # cube root
   BLOCK_DEF FUNC DBL lf_cbrtx_gt_zero(DBL xx):
      # Power of 2 closest to cuberoot of ABS(XX).
      # Only call this with a positive (0<) argument
      # if XX in [27/64,64/27) then ZZ in [1,8) and YY == 1
      DBL yy;
      DBL zz;

      zz = 64.0 * xx / 27.0;  # (4/3)**3
      yy = 1.0;
      WHILE zz <= 1.0:
         zz *= 8.0;
         yy /= 2.0;
      WHILE_END
      WHILE 8.0 < zz:
         zz /= 8.0;
         yy *= 2.0;
      WHILE_END
      # Now 1.0 < zz <= 8.0

      RETURN yy;
   FUNC_END

   FUNC DBL cbrt(DBL yy):
      # cube root of YY sans logarithms or exponentials using Newton-Raphson
      #    method on  F(XX) = XX * XX * XX - YY
      DBL ayy;
      DBL init_xx;
      {RAPHSON_DECLARATIONS}

      ayy = ABS(yy);
      IF 0.0 < ayy:
         # find a quick approximation of ABS(YY)**(1/3)
         init_xx = lf_cbrtx_gt_zero(ayy);
         IF yy < 0.0:
            init_xx = -init_xx;
         IF_END
         # refine approximation using NR method on
         #       nrvx_xx**3 - YY = 0
         {RAPHSON_LOOP init_xx
                  ; nrvx_xx * nrvx_xx * nrvx_xx - yy
                  ; 3.0 * nrvx_xx * nrvx_xx }
      ELSE:
         nrvx_xx = 0.0;
      IF_END
      RETURN nrvx_xx;
   FUNC_END
BLOCK_END

FUNC DBL cuberoot(DBL xx):
   # convienent name
   RETURN cbrt(xx);
FUNC_END

FUNC DBL squareroot(DBL xx):
   # convienent name
   RETURN SQRT(xx);
FUNC_END

{INSERT_FILE "print.fwip" }
{INSERT_FILE "financial.fwip" }
{INSERT_FILE "hyper.fwip" }
{INSERT_FILE "lambert.fwip" }
{INSERT_FILE "integral.fwip" }
{INSERT_FILE "number.fwip" }
{INSERT_FILE "bessel.fwip" }
{INSERT_FILE "partition.fwip" }
{INSERT_FILE "bits.fwip" }
{INSERT_FILE "erf.fwip" }
{INSERT_FILE "gamma.fwip" }
{INSERT_FILE "combin.fwip" }
{INSERT_FILE "julian.fwip" }
{INSERT_FILE "mean.fwip" }
{INSERT_FILE "random.fwip" }
{INSERT_FILE "randdist.fwip" }
{INSERT_FILE "stat.fwip" }
{INSERT_FILE "stts.fwip" }
{INSERT_FILE "fit.fwip" }  # must come after stts
{INSERT_FILE "approx.fwip" }
{INSERT_FILE "sphere.fwip" }
{INSERT_FILE "shc.fwip" }
{INSERT_FILE "elliptic.fwip" }
{INSERT_FILE "ellipse.fwip" }
{INSERT_FILE "cdf.fwip" }
{INSERT_FILE "search.fwip" }

FUNC DBL blackbodyl(DBL wavelen, DBL temp_k):
   # blackbody spectral radiance at WAVELENGTH and TEMP_K
   # returns WATT / (STERADIAN METER**3)
   DBL hc;
   DBL hc_kt;
   DBL retvalu;

   IF wavelen <= 0.0 OR temp_k <= 0.0:
      retvalu = 0.0;
   ELSE:
      hc = Kw.PLANCK * Kw.LIGHT;
      hc_kt = hc / (Kw.BOLTZMANN * temp_k);
      retvalu = 2.0 * hc * Kw.LIGHT
               / (POW(wavelen, 5) * (EXP(hc_kt / wavelen) - 1.0));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL blackbodyf(DBL wavefreq, DBL temp_k):
   # blackbody spectral radiance at WAVEFREQ and TEMP_K
   # returns WATT / (STERADIAN METER**3)
   DBL h_kt;
   DBL retvalu;

   IF wavefreq <= 0.0 OR temp_k <= 0.0:
      retvalu = 0.0;
   ELSE:
      h_kt =  Kw.PLANCK / (Kw.BOLTZMANN * temp_k);
      retvalu = 2.0 * Kw.PLANCK * POW(wavefreq, 3)
               / (POW(Kw.LIGHT, 2) * (EXP(h_kt * wavefreq) - 1.0));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL blackbodymode(DBL temp_k):
   # Wavelength at mode of blackbody spectral radiance
   # at TEMP_K
   DBL hc_kt;
   DBL retvalu;

   IF temp_k <= 0.0:
      retvalu = 0.0;
   ELSE:
      hc_kt = Kw.PLANCK * Kw.LIGHT / (Kw.BOLTZMANN * temp_k);
      retvalu = hc_kt / (5.0 + Kw.wp(-5.0 * EXP(-5.0)));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL blackbodypower(DBL temp_k):
   # power output of a blackbody at temperature TEMP_K
   # Also known as Stefan-Boltzmann Law
   RETURN Kw.STEFAN * POW(temp_k, 4.0);
FUNC_END

FUNC DBL bhmass_to_tempk(DBL bhmass_kg):
   # Temperature of a blackhole with mass BHMASS_KG
   RETURN BHMASSTEMP / bhmass_kg;
FUNC_END

FUNC DBL bhtempk_to_mass(DBL bhtemp_k):
   # Mass of a blackhole with temperature BHTEMP_K
   RETURN BHMASSTEMP / bhtemp_k;
FUNC_END

FUNC DBL bhmass_to_radius(DBL bhmass_kg):
   # Radius of a blackhole with mass BHMASS_KG
   RETURN bhmass_kg / BHMASS_RADIUS;
FUNC_END

FUNC DBL bhradius_to_mass(DBL bhradius_m):
   # Mass of a blackhole with radius BHRADIUS_M
   RETURN BHMASS_RADIUS * bhradius_m;
FUNC_END

FUNC DBL bhmass_to_entropy(DBL bhmass_kg):
   # Entropy of a blackhole with mass BHMASS_KG
   RETURN bhmass_kg * bhmass_kg / BHMASS2_ENTROPY;
FUNC_END

FUNC DBL bhentropy_to_mass(DBL bhentropy):
   # Mass of a blackhole with entropy BHENTROPY
   RETURN SQRT(bhentropy * BHMASS2_ENTROPY);
FUNC_END

FUNC DBL bhmass_to_power(DBL bhmass_kg):
   # Power output of a blackhole with mass BHMASS_KG
   RETURN BHMASS2POWER / (bhmass_kg * bhmass_kg);
FUNC_END

FUNC DBL bhpower_to_mass(DBL bhpower_w):
   # Mass of a blackhole outputting BHPOWER_W
   RETURN SQRT(BHMASS2POWER / bhpower_w);
FUNC_END

FUNC DBL bhmass_to_area(DBL bhmass_kg):
   # surface area of a blackhole with mass BHMASS_KG
   RETURN bhmass_kg * bhmass_kg / BHMASS2_AREA;
FUNC_END

FUNC DBL bharea_to_mass(DBL bharea):
   # Mass of a blackhole with surface area BHAREA
   RETURN SQRT(BHMASS2_AREA * bharea);
FUNC_END

FUNC DBL bhlifetime_to_mass(DBL bhlifetime_s):
   # Mass of a blackhole with a lifetime of BHLIFETIME_S
   RETURN cbrt(BHMASS3_LIFETIME * bhlifetime_s);
FUNC_END

FUNC DBL bhmass_to_lifetime(DBL bhmass_kg):
   # Lifetime of a blackhole of mass BHMASS_KG
   RETURN bhmass_kg * bhmass_kg * bhmass_kg / BHMASS3_LIFETIME;
FUNC_END

FUNC DBL bhmass_to_density(DBL bhmass_kg):
   # Density of a blackhole of mass BHMASS_KG
   RETURN bhmass_kg * bhmass_kg / BHMASS2_DENSITY;
FUNC_END

FUNC DBL bhdensity_to_mass(DBL bhdensity):
   # Mass of a blackhole with density BHDENSITY
   RETURN SQRT(bhdensity * BHMASS2_DENSITY);
FUNC_END

FUNC DBL pendulum(DBL len_m, DBL ang_offset_rad, DBL grav):
   # Period of pendulum of length LEN_M, initial angle offset ANG_OFFSET_RAD,
   #      and acceleration due to gravity GRAV.
   RETURN Kw.TAU * SQRT(len_m / grav)
            / Kw.agmean(1.0, COS(ang_offset_rad / 2.0));
FUNC_END

## Special Relativistic functions - ----- ----- ----- ----- ----- ----- -----
FUNC DBL sr_mass(DBL velo_mps):
   # relativistic mass increase at velocity VELO_MPS m/s
   RETURN 1.0 / Kw.sqrtxp1m1(-Kw.square(velo_mps / Kw.LIGHT));
FUNC_END

FUNC DBL sr_time(DBL velo_mps):
   # relativistic time dilation at velocity VELO_MPS m/s
   RETURN Kw.sqrtxp1m1(-Kw.square(velo_mps / Kw.LIGHT));
FUNC_END

## General Relativistic functions - ----- ----- ----- ----- ----- ----- -----
FUNC DBL gr_massgm(DBL gm_gm, DBL radius_m):
   # relativistic gravitational mass change at a distance RADIUS_M meters
   # from a mass with gravitational parameter GM_GM, via E=mc**2
   RETURN gm_gm / (radius_m * Kw.LIGHT * Kw.LIGHT);
FUNC_END

FUNC DBL gr_mass(DBL mass_kg, DBL radius_m):
   # relativistic gravitational mass change at a distance RADIUS_M meters
   # from a mass MASS_KG
   RETURN gr_massgm(Kw.GRAVITATION * mass_kg, radius_m);
FUNC_END

FUNC DBL gr_timegm(DBL gm_gm, DBL radius_m):
   # relativistic gravitational time dilation at a distance RADIUS_M meters
   # from a mass with gravitational parameter GM_GM
   DBL con;

   con = 2 * gm_gm / (Kw.LIGHT * Kw.LIGHT);
   RETURN Kw.sqrtxp1m1(-con / radius_m);
FUNC_END

FUNC DBL gr_time(DBL mass_kg, DBL radius_m):
   # relativistic gravitational time dilation at a distance RADIUS_M meters
   # from a mass MASS_KG
   RETURN gr_timegm(Kw.GRAVITATION * mass_kg, radius_m);
FUNC_END

FUNC DBL gr_timegm_dr(DBL gm_gm, DBL radius_m):
   # derivative of relativistic gravitational time dilation at a distance
   #   RADIUS_M meters from a mass with gravitational parameter GM_GM
   DBL con;

   con = 2 * gm_gm / (Kw.LIGHT * Kw.LIGHT);
   RETURN con / ( 2 * radius_m * radius_m * SQRT(1.0 - con / radius_m));
FUNC_END

FUNC DBL cent2ratio(DBL cnt):
   RETURN pow2(cnt / 1200.0);
FUNC_END

FUNC DBL ratio2cent(DBL rat):
   RETURN lg(rat) * 1200.0;
FUNC_END

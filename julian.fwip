#    Copyright (C) 2015-2021 by Kevin D. Woerner
# 2021-04-20 kdw  var name change (mainly mm)
# 2021-04-15 kdw  indent work
# 2021-04-11 kdw  indent work
# 2021-04-10 kdw  indent work
# 2021-04-02 kdw  comments changed
# 2021-03-25 kdw  rosh hashanah work; upped line length
# 2021-03-15 kdw  lx_.* const names
# 2021-03-14 kdw  const name renam
# 2021-02-23 kdw  gyear_at_0j2k defd
# 2021-02-13 kdw  various
# 2021-02-05 kdw  test lines
# 2021-02-01 kdw  bool syntax debugging
# 2020-12-08 kdw  year-per-metonic constant defined
# 2020-12-06 kdw  jewish month length rework
# 2020-12-04 kdw  float explicit const work
# 2020-12-02 kdw  ym[d]2j[2]k work
# 2020-10-03 kdw  s/print_.*/.*_print/
# 2020-08-20 kdw  boolean checks changed
# 2020-08-19 kdw  comment change
# 2020-08-17 kdw  comment change
# 2020-07-29 kdw  block-def work
# 2020-07-27 kdw  block syntax
# 2020-07-24 kdw  comment cleanup
# 2020-06-29 kdw  halaqim def local
# 2020-06-22 kdw  local-use mved before var decls
# 2020-06-17 kdw  modulo parens
# 2020-05-30 kdw  CONST syntax change
# 2020-05-20 kdw  module for tau made explicit
# 2020-05-18 kdw  minor cleanup
# 2020-05-13 kdw  .*_LA[S]T changed to .*_COU[N]T
# 2020-05-11 kdw  REPL[A]CE replaced with LO[C]AL_CO[N]ST
# 2020-05-07 kdw  more boolean variable work
# 2020-05-06 kdw  boolean variable work
# 2020-04-28 kdw  tweaks here and there
# 2020-04-26 kdw  BL[O]CK indentation work
# 2020-04-24 kdw  sec[2]dhms
# 2020-04-23 kdw  const format change
# 2020-04-17 kdw  comments changed; minor rearrange
# 2020-04-14 kdw  tests added
# 2020-04-13 kdw  numeric inequality work
# 2020-04-12 kdw  comment change
# 2020-04-08 kdw  preprocess sigil change
# 2020-03-17 kdw  isl[e]apyear renam
# 2020-03-10 kdw  LO[C]AL_USE more consistent
# 2020-03-09 kdw  LO[C]AL_.* keywords
# 2020-03-06 kdw  RE[P]LACE / IN[D]EX changes
# 2020-03-03 kdw  comment change
# 2020-03-02 kdw  s/_N[E]XT/_E[N]D/
# 2020-02-24 kdw  function comments
# 2020-01-22 kdw  print_j[d]264
# 2020-01-21 kdw  j[d]264 func
# 2019-12-31 kdw  clock.*() funcs
# 2019-12-27 kdw  eplicit K[w] module
# 2019-12-26 kdw  module name addded to funcs
# 2019-11-08 kdw  mved consts to constants
# 2019-10-17 kdw  halaqin work
# 2019-10-14 kdw  jewish work
# 2019-10-04 kdw  comment change
# 2019-10-02 kdw  comment change
# 2019-09-27 kdw  replace word JD with JD[A]Y
# 2019-09-22 kdw  s/J[D]_AT_/JDSEC_AT_/g
# 2019-09-21 kdw  several const renamd
# 2019-09-18 kdw  comment change
# 2019-09-17 kdw  rmed c[n]v_db[l]2i32
# 2019-09-11 kdw  tweak in RH func
# 2019-08-20 kdw  jew[i]shy[m]d2jd func
# 2019-08-18 kdw  B[O]OL to B[O]L
# 2019-08-11 kdw  comment cleanup
# 2019-08-06 kdw  rmed backslashes; macro arg name change
# 2019-07-20 kdw  func descriptions
# 2019-05-29 kdw  comment changed
# 2019-05-24 kdw  local replaced private
# 2019-05-23 kdw  replace renam
# 2019-05-21 kdw  je[w]ish2j[d]x refactor / fix
# 2019-04-30 kdw  rework of jd2ymdhms, j2k2ymdhms funcs
# 2019-03-19 kdw  re[t]_val to re[t]valu
# 2019-03-08 kdw  is[e]qual to is[e]q, et al.
# 2019-03-01 kdw  ymd[h]ms2j2k created
# 2019-02-28 kdw  REP[L]ACE/DE[F]INE work
# 2019-02-03 kdw  day2hms.* funcs
# 2019-01-31 kdw  conversion func rework
# 2018-12-08 kdw  comment change
# 2018-10-08 kdw  vbdotnet stuff
# 2018-09-28 kdw  var renam
# 2018-09-17 kdw  comment change
# 2018-09-16 kdw  func renam
# 2018-07-19 kdw  comments; array reformat
# 2018-06-14 kdw  const changed
# 2018-05-22 kdw  comment change
# 2018-05-14 kdw  BL(O)CK syntax change
# 2018-05-06 kdw  comment change
# 2018-04-16 kdw  .*_diff work
# 2018-04-15 kdw  (k)wt work
# 2018-04-14 kdw  ep(o)chx renamd to (k)wt
# 2018-04-10 kdw  reorder conversion funcs
# 2018-04-03 kdw  rm () from return
# 2018-03-20 kdw  replaced index w/ "at"replace
# 2018-03-19 kdw  var nam change
# 2018-03-16 kdw  format of constant and index change
# 2018-03-12 kdw  made PP statements not need semicolon
# 2018-02-15 kdw  var nam change for VB6 VBDOTNET
# 2018-02-14 kdw  IN[D]EX stuff
# 2018-02-01 kdw  tweak
# 2018-01-29 kdw  julian consts renamd
# 2018-01-28 kdw  time const name change
# 2018-01-22 kdw  *_elapsed_* funcs renamd; parenthesis
# 2017-12-08 kdw  ym[d]2jd refactor
# 2017-12-05 kdw  doo[m]sday comments
# 2017-11-26 kdw  FR[O]M and B[Y] keywords
# 2017-11-23 kdw  rm digits from var names
# 2017-11-22 kdw  var renam
# 2017-10-25 kdw  h2[h]ms.*
# 2017-10-21 kdw  macros start with "at"
# 2017-10-20 kdw  REP[L]ACE syntax changed
# 2017-09-27 kdw  var nam changed
# 2017-09-26 kdw  jewish elapsed days work
# 2017-09-22 kdw  jd2y(m)dhms rework
# 2017-09-20 kdw  nasty bug in jd2y(m)dhms; rmed ym(d)2j2k
# 2017-09-18 kdw  ymd(h)ms2jd work
# 2017-09-17 kdw  ymd(h)ms2jd
# 2017-09-14 kdw  units work
# 2017-09-12 kdw  day2h[m]s function
# 2017-09-11 kdw  consts renamed, refactor ym(d)2j2k
# 2017-09-06 kdw  UNITS support
# 2017-08-25 kdw  d(a)y2hms bug
# 2017-08-20 kdw  rmed/renamd .*_P[E]R_.* vars
# 2017-07-12 kdw  m(o)dulo to M(O)D
# 2017-06-23 kdw  REP(L)ACE redo
# 2017-04-21 kdw  func to function
# 2017-03-19 kdw  comments
# 2017-03-17 kdw  python stuff in jd2ym.*
# 2017-03-12 kdw  shorten long comments
# 2017-03-10 kdw  get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  sigils rmed
# 2017-03-01 kdw  var[y]log-a[d]d space messup
# 2017-02-28 kdw  REQ[U]IRE function ()
# 2017-02-24 kdw  REP[L]ACE rework, et al
# 2017-02-23 kdw  var renam
# 2017-02-20 kdw  var renam
# 2017-02-14 kdw  FWIP Loop syntax changed
# 2017-02-12 kdw  FWIP language change
# 2017-02-07 kdw  comment rearrangement
# 2017-01-31 kdw  long lines
# 2016-12-18 kdw  (j)ewish_* refactor
# 2016-12-16 kdw  (j)ewish_* refactor
# 2016-12-12 kdw  var name change; comment changed
# 2016-12-05 kdw  comment change
# 2016-12-04 kdw  comment reorg
# 2016-12-02 kdw  rmed unused hour-per-degree
# 2016-11-28 kdw  file suffix changed
# 2016-11-21 kdw  D(E)F to F(U)NC
# 2016-11-20 kdw  language change
# 2016-11-19 kdw  is leap tyear refactor
# 2016-11-18 kdw  (_)_(P)OD(_)_
# 2016-11-16 kdw  function renam
# 2016-11-15 kdw  function descriptions
# 2016-11-14 kdw  ho(l)id.fwip consolidation
# 2016-11-11 kdw  var name change
# 2016-09-14 kdw  lang change
# 2016-08-08 kdw  corrected comment
# 2016-08-05 kdw  moved stuff to const
# 2016-08-02 kdw  tweak
# 2016-08-01 kdw  ymd2j* refactor
# 2016-07-30 kdw  ymd2j* refactor
# 2016-07-29 kdw  ymd2j* refactor
# 2016-07-28 kdw  ymd2j* refactor
# 2016-07-27 kdw  unix funcs
# 2016-07-26 kdw  ymdhms functions
# 2016-07-19 kdw  renamed / refactor things
# 2016-07-18 kdw  .*d(o)w functions
# 2016-07-14 kdw  const name changed
# 2016-07-13 kdw  (y)md2j(2)000 epoch correction
# 2016-04-11 kdw  variables renamed
# 2015-12-14 kdw  long line
# 2015-11-18 kdw  long line changed
# 2015-11-12 kdw  ym[d]2doy change
# 2015-10-26 kdw  j[d]2000 to j[2]000
# 2015-10-20 kdw  changed to epoch J2000
# 2015-10-19 kdw  corrected julian day of 2000-01-01
# 2015-10-16 kdw  hms2day
# 2015-10-15 kdw  created

FUNC INT days_in_month(INT g_year, INT g_month):
   # number of days in the given month
   INT retvalu;

   MODE_INTEGER:
      IF g_month == 2:
         IF Kw.isleapyear(g_year):
            retvalu = 29;
         ELSE:
            retvalu = 28;
         IF_END
      ELSIF (6 * g_month + 1) % 11 < 5:
         retvalu = 30;
      ELSE:
         retvalu = 31;
      IF_END
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END

FUNC DBL sec2dhms(DBL seconds):
   # convert seconds to DD.HHMMSS
   DBL dy;
   DBL hr;
   DBL mn;
   DBL tm;
   DBL sg;

   IF seconds < 0.0:
      sg = -1.0;
   ELSE:
      sg = 1.0;
   IF_END
   dy = FLOOR(seconds * Kw.SECOND / Kw.DAY);
   tm = (seconds * Kw.SECOND / Kw.DAY - dy) * Kw.DAY / Kw.HOUR;
   hr = FLOOR(tm);
   tm = (tm - hr) * Kw.HOUR / Kw.MINUTE;
   mn = FLOOR(tm);
   tm = (tm - mn) * Kw.MINUTE / Kw.SECOND;

   RETURN dy + sg * (hr + (mn + tm / 100.0) / 100.0) / 100.0;
FUNC_END

FUNC DBL day2dhms(DBL dayfrac):
   # convert fractional days to DD.HHMMSS
   DBL dy;
   DBL hr;
   DBL mn;
   DBL tm;
   DBL sg;

   IF dayfrac < 0.0:
      sg = -1.0;
   ELSE:
      sg = 1.0;
   IF_END
   dy = FLOOR(dayfrac);
   tm = (dayfrac - dy) * Kw.DAY / Kw.HOUR;
   hr = FLOOR(tm);
   tm = (tm - hr) * Kw.HOUR / Kw.MINUTE;
   mn = FLOOR(tm);
   tm = (tm - mn) * Kw.MINUTE / Kw.SECOND;

   RETURN dy + sg * (hr + (mn + tm / 100.0) / 100.0) / 100.0;
FUNC_END

FUNC DBL day2dhmsinv(DBL xx_hms):
   # convert DD.HHMMSSss... to fractional days
   # (undo day2hms)
   DBL dy;
   DBL hr;
   DBL mn;
   DBL tm;

   dy = FLOOR(xx_hms);
   tm = (xx_hms - dy) * 100.0;
   hr = FLOOR(tm);
   tm = (tm - hr) * 100.0;
   mn = FLOOR(tm);
   tm = (tm - mn) * 100.0;
   RETURN dy + (hr * Kw.HOUR + mn * Kw.MINUTE + tm * Kw.SECOND) / Kw.DAY;
FUNC_END

FUNC DBL hms2day(DBL hourx, DBL minutex, DBL secondx):
   # convert hour-minute-second into fractional days
   RETURN (secondx * Kw.SECOND + minutex * Kw.MINUTE + hourx * Kw.HOUR)
            / Kw.DAY;
FUNC_END
#TEST: hms2day(5,39,24.48) - 0.2357;

FUNC DBL hour2day(DBL hourx):
   # convert hours into fractional days
   RETURN hourx * Kw.HOUR / Kw.DAY;
FUNC_END

FUNC DBL day2hour(DBL dayx):
   # convert days into hours
   RETURN dayx * Kw.DAY / Kw.HOUR;
FUNC_END

##    JDAY Conversion-functions --- ----- ----- ----- ----- ----- ----- -----
FUNC DBL jd2kwt(DBL jjdtime):
   # convert a Julian date to a KWT epoch
   RETURN (jjdtime * Kw.JDAY - Kw.JDSEC_AT_0KWT) / Kw.KWT;
FUNC_END

FUNC DBL jd2j2k(DBL jjdtime):
   # convert a Julian date to a J2000 date
   RETURN (jjdtime * Kw.JDAY - Kw.JDSEC_AT_0J2K) / Kw.J2KDAY;
FUNC_END

FUNC DBL jd2uet(DBL jjdtime):
   # convert a Julian date to a UET epoch
   RETURN (jjdtime * Kw.JDAY - Kw.JDSEC_AT_0UET) / Kw.UET;
FUNC_END

FUNC DBL kwt2jd(DBL kwttime):
   # convert a KWT epoch to a Julian date
   RETURN (kwttime * Kw.KWT + Kw.JDSEC_AT_0KWT) / Kw.JDAY;
FUNC_END

FUNC DBL uet2jd(DBL uettime):
   # convert a UET to a Julian date
   RETURN (uettime * Kw.UET + Kw.JDSEC_AT_0UET) / Kw.JDAY;
FUNC_END

FUNC DBL j2k2jd(DBL jtwoktm):
   # convert a J2000 date to a Julian date
   RETURN (jtwoktm * Kw.J2KDAY + Kw.JDSEC_AT_0J2K) / Kw.JDAY;
FUNC_END

##    JDAY Conversion-functions derived - ----- ----- ----- ----- ----- -----
FUNC DBL j2k2kwt(DBL jtwoktm):
   # convert a J2000 to a KWT epoch
   RETURN jd2kwt(j2k2jd(jtwoktm));
FUNC_END

FUNC DBL j2k2uet(DBL jtwoktm):
   # convert a J2000 to a UET epoch
   RETURN jd2uet(j2k2jd(jtwoktm));
FUNC_END

FUNC DBL kwt2j2k(DBL kwttime):
   # convert a KWT to a J2000 date
   RETURN jd2j2k(kwt2jd(kwttime));
FUNC_END

FUNC DBL kwt2uet(DBL kwttime):
   # convert a KWT to a Julian date
   RETURN jd2uet(kwt2jd(kwttime));
FUNC_END

FUNC DBL uet2kwt(DBL uettime):
   # convert a UET to a KWT date
   RETURN jd2kwt(uet2jd(uettime));
FUNC_END

FUNC DBL uet2j2k(DBL uettime):
   # convert a UET to a J2000 date
   RETURN jd2j2k(uet2jd(uettime));
FUNC_END

FUNC INT jd2dow(DBL jjd):
   # day of week of the given Julian date
   INT jjtemp;

   jjtemp = FLOOR(jjd + 1.5);
   RETURN jjtemp % 7;
FUNC_END

FUNC INT j2k2dow(DBL jtwok):
   # day of week of the given J2000 date
   INT jjtemp;

   jjtemp = FLOOR(jtwok + 6.5);
   RETURN jjtemp % 7;
FUNC_END

FUNC DBL ymd2doy(INT g_year, INT g_month, DBL g_daymon):
   # convert year-month-day to day of year
   DBL delta;

   # Assume 1 <= g_month <= MONTHS_IN_YEAR
   IF 2 < g_month:
      # March 0 is the 59th day of a non-leap year.
      delta = FLOOR(30.6001 * g_month - 32.3); # 2<mon
      IF Kw.isleapyear(g_year):
         delta += 1;
      IF_END
   ELSIF g_month == 2:
      delta = 31;
   ELSE:
      delta = 0;
   IF_END

   RETURN delta + g_daymon;
FUNC_END

FUNC DBL ymd2j2k__1(DBL g_year, DBL g_month, DBL g_day):
   # convert a YEAR, MONTH, DAY into a J2000 date
   DBL yr;
   DBL mn;
   DBL jtwok;
   DBL jcen;
   DBL dayoffset;

   yr = g_year - Kw.GYEAR_AT_0J2K;
   mn = g_month;
   IF mn < 3:  # Jan and Feb need special treatment
      mn += Kw.MONTHS_IN_YEAR;
      yr -= 1;
   IF_END

   jcen = FLOOR(yr / 100);
   # The first 2 terms give the number of missing leap days
   #  due to the " == 0 mod 100 and <> 0 mod 400" rule.
   dayoffset = jcen - FLOOR(jcen / 4.0) + 31.3;
   jtwok = (FLOOR(yr * Kw.JYEAR / Kw.JDAY) + FLOOR(30.6001 * mn - dayoffset)
            + g_day - 1.5);

   RETURN jtwok;
FUNC_END

FUNC DBL ymd2j2k(DBL g_year, DBL g_month, DBL g_day):
   # convert a YEAR, MONTH, DAY into a J2000 date
   DBL yr;
   DBL mn;
   DBL jtwok;
   INT jcen;

   yr = g_year - Kw.GYEAR_AT_0J2K;
   mn = g_month;

   jcen = FLOOR((yr - 1) / 100);
   # The oneth term gives the approximate number of days that
   #    have elapsed since 2000-01-01
   # The next 2 terms give the number of missing leap days
   #    due to the " == 0 mod 100 and <> 0 mod 400" rule.
   jtwok = (FLOOR(yr * Kw.JYEAR / Kw.JDAY - 0.001) + FLOOR(jcen / 4.0) - jcen
            + ymd2doy(yr, mn, g_day) - 0.5);

   RETURN jtwok;
FUNC_END

FUNC DBL ymd2jd(DBL g_year, DBL g_month, DBL g_day):
   # convert a YEAR, MONTH, DAY into a Julian date
   RETURN j2k2jd(ymd2j2k(g_year, g_month, g_day));
FUNC_END
#TEST: ymd2jd(1960,11,2.16125) - 2437240.66125;
#TEST: ymd2jd(2017,9,3.5) - 2458000;

FUNC INT ymd2dow(INT g_year, INT g_month, DBL g_daymon):
   # day of week of the given year-month-day
   RETURN jd2dow(ymd2jd(g_year, g_month, g_daymon));
FUNC_END

FUNC INT doomsday(INT g_year):
   # The Doomsday of a given G_YEAR is the day of the week of
   #    the last day of February.
   # 04-04, 06-06, 08-08, 10-10, and 12-12 are Doomsdays.
   # "I work 9 to 5 at the 7-11":
   #    09-05, 05-09, 07-11 and 11-07 are all Doomsdays.
   # For January:
   #    01-03 is a Doomsday in non-leap years;
   #    01-04 is a Doomsday in leap years.
   #       (01-03 is a Doomsday 3 out of 4 years).
   #    Year Doomsday
   #    1700 0 (Sunday)
   #    1800 5 (Friday)
   #    1900 3 (Wednesday)
   #    2000 2 (Tuesday)
   #    2100 0 (Sunday)
   #    2200 5 (Friday)
   # Doomsday(CCYY) = Doomsday(CC00) + YY + floor(YY / 4)
   # The following days are Doomsdays:
   #    03-00 The Zeroth of March
   #    03-14 Pi day
   #    07-04 The Fourth of July
   #    09-19 Talk Like A Pirate day
   #    10-31 Halloween
   #    11-00 The Zeroth of November
   #    12-26 Boxing Day
   INT cc;
   INT yy;
   INT lps;
   INT anchor;
   INT retvalu;

   MODE_INTEGER:
      cc = FLOOR(g_year / 100);
      anchor = (cc % 4) * 5 + 2;
      yy = g_year % 100;
      lps = FLOOR(yy / 4);
      # Determine the Doomsday for the year in question
      retvalu = (anchor + yy + lps) % 7;
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END
#TEST: doomsday(2018) - 3;

BLOCK:  # Julian specific defines
   BLOCK_DEF CONST LC_GD_YEAR 0;
   BLOCK_DEF CONST LC_GD_MONTH 1;
   BLOCK_DEF CONST LC_GD_DAY 2;
   BLOCK_DEF CONST LC_GD_HOUR 3;
   BLOCK_DEF CONST LC_GD_MIN 4;
   BLOCK_DEF CONST LC_GD_SEC 5;
   BLOCK_DEF CONST LC_GD_DOW 6;
   BLOCK_DEF CONST LC_GD_NUM 7;
   BLOCK_DEF CONST LC_GD_JD 8;
   BLOCK_DEF CONST LC_GD_CNT 9;
   BLOCK_DEF DBL lv_ymdhms_arr[20];

   FUNC DBL jd2ymdhms(DBL jjulid):
      # convert a julian date to a year-mon-day-hour-min-sec array
      # use in conjunction with ymdhms_get()
      # returns a number YYYYMMDD.hhmmss
      BLOCK_USE lv_ymdhms_arr[];
      INT jcent;
      INT bbdays;
      INT bdiff;
      INT g_years;
      INT month_next;
      DBL ftime_frac;
      DBL dtime_rem;
      INT ijulian;

      lv_ymdhms_arr[LC_GD_JD] = jjulid;
      ftime_frac = Kw.frac(jjulid + 0.5);
      ijulian = FLOOR(jjulid + 0.5); # rounded
      # 60.5 = (days in January) + (days in leap February)
      #      + 0.5 for good luck
      jcent = FLOOR(((ijulian - 60.5) * Kw.JDAY - Kw.JDSEC_AT_0GREGORIAN)
               / (100.0 * Kw.GYEAR));
      bbdays = ijulian + jcent - FLOOR(jcent / 4.0);
      g_years = FLOOR((bbdays + 1399.9) * Kw.JDAY / Kw.JYEAR);
      bdiff = bbdays - FLOOR(g_years * Kw.JYEAR / Kw.JDAY) + 1522;
      month_next = FLOOR(bdiff / 30.6001);
      # time (in days) remaining in month
      dtime_rem = bdiff - FLOOR(30.6001 * month_next) + ftime_frac;

      lv_ymdhms_arr[LC_GD_YEAR] = g_years - 4716.0;
      IF 13 < month_next:
         lv_ymdhms_arr[LC_GD_MONTH] = month_next - 13;
      ELSE:
         lv_ymdhms_arr[LC_GD_MONTH] = month_next - 1;
      IF_END
      IF lv_ymdhms_arr[LC_GD_MONTH] < 3:
         lv_ymdhms_arr[LC_GD_YEAR] += 1;
      IF_END

      lv_ymdhms_arr[LC_GD_DAY] = FLOOR(dtime_rem);
      dtime_rem = Kw.DAY / Kw.HOUR * Kw.frac(dtime_rem);
      lv_ymdhms_arr[LC_GD_HOUR] = FLOOR(dtime_rem);
      dtime_rem = Kw.HOUR / Kw.MINUTE * Kw.frac(dtime_rem);
      lv_ymdhms_arr[LC_GD_MIN] = FLOOR(dtime_rem);
      dtime_rem = Kw.MINUTE / Kw.SECOND * Kw.frac(dtime_rem);
      lv_ymdhms_arr[LC_GD_SEC] = dtime_rem;

      lv_ymdhms_arr[LC_GD_DOW] = FLOOR(Kw.fmod(ijulian + 1.0, 7.0));
      # reuse FTIME_FRAC, DTIME_REM
      dtime_rem = (lv_ymdhms_arr[LC_GD_MONTH] * 100.0
               + lv_ymdhms_arr[LC_GD_DAY]
               + lv_ymdhms_arr[LC_GD_HOUR] / 100.0
               + lv_ymdhms_arr[LC_GD_MIN] / 10000.0
               + lv_ymdhms_arr[LC_GD_SEC] / 1000000.0);
      ftime_frac = lv_ymdhms_arr[LC_GD_YEAR] * 10000.0;

      IF ftime_frac < 0.0:
         lv_ymdhms_arr[LC_GD_NUM] = ftime_frac - dtime_rem;
      ELSE:
         lv_ymdhms_arr[LC_GD_NUM] = ftime_frac + dtime_rem;
      IF_END
      RETURN lv_ymdhms_arr[LC_GD_NUM];
   FUNC_END
   #TEST: jd2ymdhms(2437240.66125) - 19601102.035212;

   FUNC DBL j2k2ymdhms(DBL jtwokd):
      # convert a j2k date to a year-mon-day-hour-min-sec array
      # use in conjunction with ymdhms_get()
      # returns a number YYYYMMDD.hhmmss
      RETURN jd2ymdhms(j2k2jd(jtwokd));
   FUNC_END

   FUNC DBL ymdhms_get(INT indexp):
      # retrieve the INDEXPth result from the last
      # .*2ymdhms conversion
      # year-mon-day-hour-min-sec array
      # INDEXP  RETURNS
      #    0    year
      #    1    month
      #    2    day
      #    3    hour
      #    4    minute
      #    5    second
      #    6    day-of-week
      #    7    YYYMMDD.hhmmss
      #    8    Julian day
      BLOCK_USE lv_ymdhms_arr[];
      DBL retvalu;

      IF LC_GD_YEAR <= indexp AND indexp < LC_GD_CNT:
         retvalu = lv_ymdhms_arr[indexp];
      ELSE:
         retvalu = -1;
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC DBL jd2ymdhmsinv(NUL):
      # given previously fillled year-mon-day-hour-min-sec array
      # return the Julian day
      BLOCK_USE lv_ymdhms_arr[];

      RETURN ymd2jd(lv_ymdhms_arr[LC_GD_YEAR]
               , lv_ymdhms_arr[LC_GD_MONTH]
               , lv_ymdhms_arr[LC_GD_DAY])
               + hms2day(lv_ymdhms_arr[LC_GD_HOUR]
               , lv_ymdhms_arr[LC_GD_MIN]
               , lv_ymdhms_arr[LC_GD_SEC]) * Kw.DAY / Kw.JDAY;
   FUNC_END
BLOCK_END

FUNC DBL jd264_print(DBL jjulid):
   # print out gregorian day in format YYMDhms as a base-64 string for
   #   Julian date JJULID
   CALL jd2ymdhms(jjulid);
   CALL base_out_print(ymdhms_get(LC_GD_YEAR), 64);
   CALL base_out_print(ymdhms_get(LC_GD_MONTH), 64);
   CALL base_out_print(ymdhms_get(LC_GD_DAY), 64);
   CALL base_out_print(ymdhms_get(LC_GD_HOUR), 64);
   CALL base_out_print(ymdhms_get(LC_GD_MIN), 64);
   CALL base_outf_print(ymdhms_get(LC_GD_SEC), 64);
   RETURN jjulid;
FUNC_END

FUNC DBL ymdhms2jd(DBL ymdhmsx):
   # given a number YYYYMMDD.hmmss, return the Julian day
   DBL xx_arr[LC_GD_CNT];
   DBL ys;

   ys = ymdhmsx * (1.0 + Kw.DBLEPS); # facilitate rounding
   xx_arr[LC_GD_YEAR] = FLOOR(ys / 10000.0);
   IF ys < 0:
      ys = -ys;
   IF_END
   xx_arr[LC_GD_MONTH] = Kw.fmodu(FLOOR(ys / 100.0), 100.0);
   xx_arr[LC_GD_DAY] = Kw.fmodu(FLOOR(ys), 100.0);
   xx_arr[LC_GD_HOUR] = Kw.fmodu(FLOOR(ys * 100.0), 100.0);
   xx_arr[LC_GD_MIN] = Kw.fmodu(FLOOR(ys * 10000.0), 100.0);
   xx_arr[LC_GD_SEC] = Kw.frac(ys * 10000.0) * 100.0;

   RETURN ymd2jd(xx_arr[LC_GD_YEAR], xx_arr[LC_GD_MONTH], xx_arr[LC_GD_DAY])
            + hms2day(xx_arr[LC_GD_HOUR], xx_arr[LC_GD_MIN]
            , xx_arr[LC_GD_SEC]) * Kw.DAY / Kw.JDAY;
FUNC_END

FUNC DBL ymdhms2j2k(DBL ymdhmsx):
   # convert a YYYYMMDD.hhmmss into a J2000 date
   RETURN jd2j2k(ymdhms2jd(ymdhmsx));
FUNC_END

FUNC DBL clocksec(DBL secnds):
   # Radian angular position from 12:00:00 postion of second hand of a clock
   #    at SECNDS past midnight
   RETURN Kw.frac(secnds / Kw.MINUTE) * Kw.TAU;
FUNC_END
FUNC DBL clockmin(DBL secnds):
   # Radian angular position from 12:00:00 postion of minute hand of a clock
   #    at SECNDS past midnight
   RETURN Kw.frac(secnds / Kw.HOUR) * Kw.TAU;
FUNC_END
FUNC DBL clockhour(DBL secnds):
   # Radian angular position from 12:00:00 postion of hour hand of a clock
   #    at SECNDS past midnight
   RETURN Kw.frac(secnds / (Kw.DAY / 2)) * Kw.TAU;
FUNC_END

FUNC DBL clocksum(DBL secnds):
   # Sum of radian angular position differences of hands of a clock at SECNDS
   #    past midnight
   DBL sc;
   DBL mn;
   DBL hr;

   sc = clocksec(secnds);
   mn = clockmin(secnds);
   hr = clockhour(secnds);
   RETURN Kw.dist(sc - mn, Kw.TAU) + Kw.dist(hr - mn, Kw.TAU)
            + Kw.dist(sc - hr, Kw.TAU);
FUNC_END

FUNC DBL clockstdev(DBL secnds):
   # compute standard deviation of angular differences between hour, minute,
   #    and second hands of a clock at time SECNDS after midnight
   DBL sc;
   DBL mn;
   DBL hr;
   DBL da;
   DBL db;
   DBL dc;

   sc = clocksec(secnds);
   mn = clockmin(secnds);
   hr = clockhour(secnds);
   da = Kw.dist(sc - mn, Kw.TAU);
   db = Kw.dist(hr - mn, Kw.TAU);
   dc = Kw.dist(sc - hr, Kw.TAU);
   RETURN SQRT((da * da + db * db + dc * dc
            - Kw.square(da + db + dc) / 3.0) / 2.0);
FUNC_END

BLOCK:  # Halaqim / Metonic
   BLOCK_DEF CONST LC_HALAQIM_PER_HOUR    1080; #T
   BLOCK_DEF CONST LX_HALAQIM  Kw.HOUR / LC_HALAQIM_PER_HOUR; #T
   BLOCK_DEF CONST LC_YEAR_PER_METONIC 19; #1

   FUNC INT date_easter(INT g_year):
      # what day of *March* is easter in Gregorian year G_YEAR
      # The algorithm is due to J.-M. Oudin (1940) and is
      # reprinted in the Explanatory Supplement to the
      # Astronomical Almanac, ed. P. K. Seidelmann (1992).
      # See Chapter 12, "Calendars", by L. E. Doggett.
      INT century;
      INT ii;
      INT dow;
      INT kk;
      INT jj;
      INT skipped_leap;
      INT modmet;
      INT leap_years;

      MODE_INTEGER:
         century = FLOOR(g_year / 100);
         modmet = g_year % LC_YEAR_PER_METONIC;
         skipped_leap = century - FLOOR(century / 4);
         leap_years = FLOOR(g_year / 4);
         kk = FLOOR((century + 8) / 25 - 1);
         jj = FLOOR((century - kk) / 3);
         ii = (skipped_leap - jj + LC_YEAR_PER_METONIC * modmet + 15) % 30;

         IF 28 < ii OR (ii == 28 AND 10 < modmet):
            ii -= 1;
         IF_END
         dow = (g_year + leap_years + ii + 2 - skipped_leap) % 7;
      MODE_INTEGER_END

      RETURN ii - dow + 28;
   FUNC_END

   FUNC DBL date_rosh_hashanah(INT g_year):
      # which day of *September* is Rosh HaShanah in
      #   the *GREGORIAN* year G_YEAR
      # 1 hour = 1080 parts("halaqim") = 3.333333 seconds
      # Moon month = 29.530587981 days
      #            = 29 d + 12 h + 44 m + 2.8 s
      #            = 29 d + 12 h + 792.84 halaqim
      #            = 765432.84046752 halaqim
      #            about round(MOON_MONTH / LX_HALAQIM)
      INT aa;
      DBL dos;
      INT day_of_september;
      DBL parts;
      INT doww;
      DBL am;

      aa = (12 * g_year + 12) % LC_YEAR_PER_METONIC;
      # 11<aa iff jewish leap year
      am = round(Kw.MOON_MONTH / Kw.LX_HALAQIM) * aa - 1565.0 * g_year;
      dos = FLOOR(g_year / 100) - FLOOR(g_year / 400) - 2
               + (g_year % 4) / 4.0
               + (am - 445405) / (LC_YEAR_PER_METONIC * Kw.DAY / LX_HALAQIM);
      day_of_september = FLOOR(dos);
      parts = (dos - day_of_september) * Kw.DAY / LX_HALAQIM;

      doww = ymd2dow(g_year, 9, day_of_september);
      # delay rules: R-H cant be next to Shabbat, and it cant be Wednesday
      #    as that would make Yom Kippur next to Shabbat.
      IF doww == 0 OR doww == 3 OR doww == 5:
         day_of_september += 1;   # Adu
      ELSIF doww == 1 AND 11 < aa AND 23269 <= parts:
         day_of_september += 1;   # Batu Thakpad
      ELSIF doww == 2 AND 6 < aa AND 16404 <= parts:
         day_of_september += 2;   # Gatarad
      IF_END

      RETURN day_of_september - 0.25;
   FUNC_END

   FUNC DBL jewish2jdx(INT hebyear):
      # Julian day of Rosh Hashanah in Jewish year HEBYEAR
      INT months_el;
      INT halaqims_el;
      INT hour_el;
      INT hq_left;
      INT days_left;
      INT alt_days;
      INT alt_dow;
      INT hymod;

      MODE_INTEGER:
         # LC_YEAR_PER_METONIC JYears = 235.002093574 Moon Months
         hymod = (hebyear - 1) % LC_YEAR_PER_METONIC;
         months_el = (235 * FLOOR((hebyear - 1) / LC_YEAR_PER_METONIC)
                  + 12 * hymod + FLOOR((7 * hymod + 1)
                  / LC_YEAR_PER_METONIC));

         # MOON_MONTH = 29 * DAY + 12 * HOUR + 792.84046752 LX_HALAQIM
         halaqims_el = 204 + (793 * (months_el % LC_HALAQIM_PER_HOUR));

         hour_el = (5 + (12 * months_el)
                  + 793 * FLOOR(months_el / LC_HALAQIM_PER_HOUR)
                  + FLOOR(halaqims_el / LC_HALAQIM_PER_HOUR));

         days_left = FLOOR(hour_el / (Kw.DAY / Kw.HOUR))
                  + 1 + 29 * months_el;
         # 347996.25 = Julian day of the zeroth day of the
         #    seventh month in Jewish year 1
         #    = Gregorian date -3760-09-06
         alt_days = days_left + 347996;
         alt_dow = (alt_days % Kw.iround(Kw.WEEK / Kw.DAY));
         hq_left = (halaqims_el % LC_HALAQIM_PER_HOUR);
      MODE_INTEGER_END
      hq_left += Kw.DAY * Kw.frac(hour_el * Kw.HOUR / Kw.DAY) / LX_HALAQIM;

      IF 19440 <= hq_left:  # after 18:00:00 or 64800s
         IF 0 == alt_dow OR 2 == alt_dow OR 4 == alt_dow:
            alt_days += 2;
         ELSE:
            alt_days += 1;
         IF_END
      ELSIF 0 == alt_dow:
         IF 9924 <= hq_left:
            IF NOT isjewishleap(hebyear):
               # after 09:11:20 or 33080s
               alt_days += 2;
            IF_END
         IF_END
      ELSIF 6 == alt_dow:
         IF 16789 <= hq_left AND isjewishleap(hebyear - 1):
            # after 15:32:43.333 or 55963.33s
            alt_days += 1;
         IF_END
      ELSIF 1 == alt_dow OR 3 == alt_dow OR 5 == alt_dow:
         alt_days += 1;
      IF_END

      RETURN alt_days + 0.25;
   FUNC_END

   FUNC BOL isjewishleap(INT hebyear):
      # Is the Jewish year HEBYEAR a leap year?
      # True iff (HEBYEAR mod 19 == 0,3,6,8,11,14,17)
      RETURN (7 * hebyear + 1) % LC_YEAR_PER_METONIC < 7;
   FUNC_END
BLOCK_END   # Halaqim
#TEST: jewish2jdx(5776) - 2457279.25;
#TEST: jewish2jdx(1) - 347997.25;

FUNC DBL date_pesach(INT g_year):
   # Pesach occurs exactly 163 days before Rosh HaShanah
   # If Rosh Hashanah is Sept M (where Sept 30+N == Oct N),
   # then Pesach (in that *Gregorian* year) is March 21 + M
   DBL rh;

   rh = date_rosh_hashanah(g_year);
   RETURN rh + 21;
FUNC_END

FUNC INT g2jewish(INT g_year):
   # What Jewish year starts in Gregorian year G_YEAR?
   RETURN g_year + 3761;
FUNC_END

FUNC INT jewish2g(INT hebyear):
   # What Gregorian year starts in Jewish year HEBYEAR?
   RETURN hebyear - 3760;
FUNC_END

FUNC INT jewish_months_in_year(INT hebyear):
   # number of months in Jewish year HEBYEAR
   INT miy;
   IF isjewishleap(hebyear):
      miy = 13;
   ELSE:
      miy = 12;
   IF_END
   RETURN miy;
FUNC_END

FUNC INT jewish_yearlength(INT hebyear):
   # number of days in Jewish year HEBYEAR
   INT g_year;
   INT retvalu;

   # Is there an easier way?
   g_year = jewish2g(hebyear - 1);
   retvalu = (FLOOR(Kw.JYEAR / Kw.JDAY) + (date_rosh_hashanah(g_year + 1)
            - date_rosh_hashanah(g_year)));
   IF Kw.isleapyear(g_year + 1):
      retvalu += 1;
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL jewish2jd(INT hebyear):
   # Julian day of Rosh Hashanah in Jewish year HEBYEAR
   INT gregyear;

   gregyear = jewish2g(hebyear - 1);
   RETURN ymd2jd(gregyear, 9, date_rosh_hashanah(gregyear));
FUNC_END

FUNC BOL isjewish8short(INT hebyear):
   # Is there an easier way to tell if Month 8 is long?
   # Month 8 is long iff the Hebrew year is multiple of 5
   #   days long
   INT remten;
   MODE_INTEGER:
      remten = jewish_yearlength(hebyear) % 10;
   MODE_INTEGER_END
   RETURN remten <> 5;
FUNC_END

FUNC BOL isjewish9short(INT hebyear):
   # Is there an easier way to tell if Month 9 is short?
   # Month 9 is short iff the Hebrew year is 3 mod 10
   #   days long
   INT remten;
   MODE_INTEGER:
      remten = jewish_yearlength(hebyear) % 10;
   MODE_INTEGER_END
   RETURN remten == 3;
FUNC_END

FUNC INT jewish_monthlength(INT hebyear, INT hebmonth):
   # Number of days in Jewish month HEBMONTH
   #    in Jewish year HEBYEAR
   INT retvalu;

   retvalu = 30;
   IF hebmonth < 1 OR 13 < hebmonth:
      retvalu = 0;
   ELSIF hebmonth < 8:
      IF Kw.iseven(hebmonth):
         retvalu = 29;
      IF_END
   ELSIF hebmonth == 8:
      IF isjewish8short(hebyear):
         retvalu = 29;
      IF_END
   ELSIF hebmonth == 9:
      IF isjewish9short(hebyear):
         retvalu = 29;
      IF_END
   ELSIF hebmonth == 10:
      retvalu = 29;
   ELSIF hebmonth == 11:
      retvalu = 30;
   ELSIF hebmonth == 12:
      IF NOT isjewishleap(hebyear):
         retvalu = 29;
      IF_END
   ELSIF hebmonth == 13 AND isjewishleap(hebyear):
      retvalu = 29;
   ELSE:
      retvalu = 0;
   IF_END

   RETURN retvalu;
FUNC_END

FUNC INT jewish_monthbegin(INT hebyear, INT hmonth):
   # What day of (Gregorian month HMONTH + 2) is
   # the Jewish date HEBYEAR-HMONTH-01
   INT g_year;
   INT g_month;
   INT hm;
   DBL gdate;

   g_year = jewish2g(hebyear - 1);
   g_month = 9;
   IF hmonth < Kw.JEWISH_FIRST_MONTH:
      g_year += 1;
      gdate = date_rosh_hashanah(g_year);
      FOR hm FROM Kw.JEWISH_FIRST_MONTH - 1 TO hmonth BY -1:
         g_month -= 1;
         gdate += (days_in_month(g_year, g_month)
                  - jewish_monthlength(hebyear, hm));
      FOR_END
   ELSE: # IF Kw.JEWISH_FIRST_MONTH <= hmonth
      gdate = date_rosh_hashanah(g_year);
      FOR hm FROM Kw.JEWISH_FIRST_MONTH TO hmonth - 1:
         gdate -= (days_in_month(g_year, g_month)
                  - jewish_monthlength(hebyear, hm));
         g_month += 1;
         IF Kw.MONTHS_IN_YEAR < g_month:
            g_month = 1;
            g_year += 1;
         IF_END
      FOR_END
   IF_END

   RETURN gdate;
FUNC_END

FUNC DBL jewishymd2jd(INT hebyear, INT hebmonth, DBL hebday):
   # The Julian day of the Jewish date HEBYEAR-HEBMONTH-HEBDAY
   DBL jds;
   INT hfirst;
   INT hmon;
   INT moninyear;

   moninyear = jewish_months_in_year(hebyear);
   IF 1 <= hebmonth AND hebmonth <= moninyear:
      jds = jewish2jd(hebyear);
      hfirst = Kw.JEWISH_FIRST_MONTH;
      hmon = Kw.JEWISH_FIRST_MONTH;
      WHILE hmon <> hebmonth:
         jds += jewish_monthlength(hebyear, hmon);
         hmon += 1;
         IF moninyear < hmon:
            hmon = 1;
         ELSIF hmon == hfirst:
            hebyear += 1;
            moninyear = jewish_months_in_year(hebyear);
         IF_END
      WHILE_END
   ELSE:
      jds = 0;
   IF_END

   RETURN jds + hebday - 1.0;
FUNC_END

#    Copyright (C) 2015-2021 by Kevin D. Woerner
# 2021-04-15 kdw  indent work
# 2021-04-11 kdw  indent work
# 2021-04-10 kdw  indent work
# 2021-03-27 kdw  long lines update
# 2021-03-14 kdw  const name renam
# 2021-02-26 kdw  fwip syntax debugging
# 2020-08-17 kdw  comment change
# 2020-07-27 kdw  block syntax
# 2020-07-25 kdw  s/BITWISE/BIT/
# 2020-07-24 kdw  comment cleanup
# 2020-06-22 kdw  local-use mved befroe var decls
# 2020-06-17 kdw  mode integer added to several funcs
# 2020-05-30 kdw  CONST syntax change
# 2020-05-14 kdw  local funcs only in blocks
# 2020-05-13 kdw  .*_LA[S]T changed to .*_COU[N]T
# 2020-05-12 kdw  nul rets changed
# 2020-05-11 kdw  REPL[A]CE replaced with LO[C]AL_CO[N]ST
# 2020-05-05 kdw  magic check func changed
# 2020-04-28 kdw  tweaks here and there
# 2020-04-26 kdw  BL[O]CK indentation work
# 2020-04-23 kdw  const format change
# 2020-04-14 kdw  minor tweak to init array
# 2020-04-12 kdw  comment change
# 2020-04-09 kdw  MO[D]E syntax change
# 2020-04-08 kdw  preprocess sigil change
# 2020-03-11 kdw  comment change
# 2020-03-09 kdw  LO[C]AL_.* keywords
# 2020-03-06 kdw  RE[P]LACE / IN[D]EX changes
# 2020-03-03 kdw  comment changed:odd chars
# 2020-03-02 kdw  s/_N[E]XT/_[E]ND/
# 2019-12-27 kdw  explicit K[w] module
# 2019-12-26 kdw  module name addded to funcs
# 2019-10-04 kdw  comment change
# 2019-09-17 kdw  rmed c[n]v_db[l]2i32
# 2019-09-05 kdw  refactor
# 2019-08-25 kdw  loop rework
# 2019-08-24 kdw  for and count loops have from clause
# 2019-08-11 kdw  comment cleanup
# 2019-08-06 kdw  rmed backslashes, macro arg renam
# 2019-08-01 kdw  rand-cycle refactor
# 2019-07-31 kdw  bit to bitwise func nams
# 2019-07-03 kdw  var renam: "s/ind/_ind/;s/__ind/_ind/"
# 2019-05-29 kdw  comment changed
# 2019-05-24 kdw  local replaced private
# 2019-05-22 kdw  s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-17 kdw  explicit module for intmax
# 2019-03-08 kdw  is[e]qual to is[e]q, et al.
# 2019-02-28 kdw  REP[L]ACE/DE[F]INE work
# 2018-07-17 kdw  private lf_.* funcs
# 2018-06-19 kdw  die keyword
# 2018-05-15 kdw  DIE.* change
# 2018-05-14 kdw  BL[O]CK syntax
# 2018-05-13 kdw  MO?DE.* syntax change
# 2018-04-03 kdw  rm () from return
# 2018-04-02 kdw  Pro?totype, et al.
# 2018-03-20 kdw  replaced index w/ "at"replace
# 2018-03-16 kdw  format of constant and index change
# 2018-02-14 kdw  IN[D]EX stuff
# 2017-11-26 kdw  FR[O]M and B[Y] keywords
# 2017-11-21 kdw  FR[O]M
# 2017-10-21 kdw  macros start with "at"
# 2017-10-20 kdw  RE[P]LACE syntax changed
# 2017-08-30 kdw  INT_* to INT* consts; Req?uires rmed
# 2017-08-24 kdw  var renam
# 2017-06-23 kdw  REPL?ACE redo
# 2017-06-08 kdw  magic constants now hidden
# 2017-04-30 kdw  func to function
# 2017-04-04 kdw  comments deleted
# 2017-03-12 kdw  shorten long comments
# 2017-03-10 kdw  get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  sigils rmed
# 2017-03-01 kdw  var[y]log-a[d]d space messup
# 2017-02-28 kdw  REQ[U]IRE function ()
# 2017-02-24 kdw  REP[L]ACE rework, et al
# 2017-02-21 kdw  var renam
# 2017-02-20 kdw  array var names
# 2017-02-14 kdw  FWIP Loop syntax changed
# 2017-02-13 kdw  FWIP language change
# 2017-02-12 kdw  FWIP language change
# 2017-01-06 kdw  ?[?]USE.* to ?[?].*_MODE; ?[?]DIGR.*
# 2016-12-28 kdw  comment change
# 2016-12-07 kdw  comment change
# 2016-11-24 kdw  while loops changed to await loops
# 2016-11-23 kdw  CN?ST to REA?DON?LY
# 2016-11-21 kdw  DE?F to FU?NC
# 2016-11-20 kdw  language change
# 2016-11-16 kdw  r?and_ini?t_arrays; comments
# 2016-11-15 kdw  M?OD/B?IT* syntax change
# 2016-10-30 kdw  reorg
# 2016-10-29 kdw  reorg
# 2016-10-28 kdw  comment reorg; moved several func
# 2016-10-14 kdw  _p added to several vars
# 2016-09-19 kdw  magic vars declred as doubles
# 2016-09-18 kdw  debugging; yfs number change
# 2016-09-13 kdw  lang change
# 2016-09-14 kdw  lang change
# 2016-08-16 kdw  randint refactor; comments
# 2016-07-02 kdw  randgam refactor
# 2016-05-23 kdw  long lines
# 2016-05-18 kdw  comment change
# 2016-04-27 kdw  PYTHON: randpoi (int vs dbl div)
# 2016-01-22 kdw  long lines
# 2016-01-18 kdw  long lines
# 2015-12-30 kdw  ra?nd_se?ed to ra?nd_in?it, et al.
# 2015-12-25 kdw  default seed is time
# 2015-12-21 kdw  define local functions before use
# 2015-12-14 kdw  minor refactor ; rmed sigils
# 2015-12-11 kdw  s/LC_// from some consts
# 2015-12-03 kdw  long lines
# 2015-12-02 kdw  rearranged
# 2015-11-26 kdw  long lines
# 2015-11-19 kdw  long lines
# 2015-11-17 kdw  F[O]R format changed
# 2015-11-17 kdw  block comments
# 2015-11-15 kdw  m[a]gic stuff
# 2015-11-13 kdw  comment shortened
# 2015-11-12 kdw  comment shortened
# 2015-10-27 kdw  variable rename
# 2015-10-13 kdw  _[_]DEFI[N]E_[_]
# 2015-10-08 kdw  refactor KNUTH stuff
# 2015-10-07 kdw  l[f]_ra[n]_init_.*_array has 2 args
# 2015-10-05 kdw  var rename; ra?nd_se?ed returns arg
# 2015-10-01 kdw  float equality checks to is.*;magic
# 2015-09-30 kdw  rmed unused variables
# 2015-09-25 kdw  reworked for VB anmd BC
# 2015-09-24 kdw  bit ops changed
# 2015-09-22 kdw  _[_]* format changed
# 2015-09-20 kdw  created

BLOCK: # Random numbers
   BLOCK_DEF CONST LC_KNUTH_MAX 1073741823; # 2**30-1 MUST BE ODD
   BLOCK_DEF CONST LC_KNUTH_QUALITY_CNT 1009;
   BLOCK_DEF CONST LC_KNUTH_KK_CNT 100;
   BLOCK_DEF CONST LC_KNUTH_LL 37;
   BLOCK_DEF CONST LC_KNUTH_TT 70;
   # array size must be greater than LC_KNUTH_QUALITY_CNT
   #  AND greater than 2 * LC_KNUTH_KK_CNT - 1
   BLOCK_DEF CONST LC_KNUTH_ARRAY_CNT 1100;

   BLOCK_DEF INT lv_ranz_ind = -3;
   BLOCK_DEF DBL lv_ranz_magic = 0.0;
   BLOCK_DEF INT lv_ranz_arr[LC_KNUTH_QUALITY_CNT];
   BLOCK_DEF INT lv_ran_a_arr[LC_KNUTH_ARRAY_CNT];
   # generator state
   BLOCK_DEF INT lv_ran_x_arr[LC_KNUTH_KK_CNT];

   # cannabalized from D. E. Knuth: "The Art of Computer Programming"
   #    Vol 2, Ed 3, pg 186 Random Number Generation
   BLOCK_DEF FUNC INT lf_ran_cycle(INT nn):
      BLOCK_USE lv_ran_x_arr[];
      BLOCK_USE lv_ran_a_arr[];
      INT aa;
      INT bb;
      INT cc;
      INT mody;

      MODE_INTEGER:
         # must have LC_KNUTH_KK_CNT < nn
         aa = 0;
         WHILE aa < LC_KNUTH_KK_CNT:
            lv_ran_a_arr[aa] = lv_ran_x_arr[aa];
            aa += 1;   # [0..KK)
         WHILE_END

         bb = 0;
         cc = (LC_KNUTH_KK_CNT - LC_KNUTH_LL);
         # Before each loop:
         #   aa - bb == LC_KNUTH_KK_CNT mod nn
         #   aa - cc == LC_KNUTH_LL       mod nn

         WHILE aa < nn:
            mody = lv_ran_a_arr[bb] - lv_ran_a_arr[cc];
            lv_ran_a_arr[aa] = BITAND(LC_KNUTH_MAX, mody);
            aa += 1;   # [KK   ..nn)
            bb += 1;   # [0    ..nn-KK)
            cc += 1;   # [KK-LL..nn-LL)
         WHILE_END

         aa = 0;
         WHILE aa < LC_KNUTH_LL:
            mody = lv_ran_a_arr[bb] - lv_ran_a_arr[cc];
            lv_ran_x_arr[aa] = BITAND(LC_KNUTH_MAX, mody);
            aa += 1;   # [0    ..LL)
            bb += 1;   # [nn-KK..nn-KK+LL)
            cc += 1;   # [nn-LL..nn)
         WHILE_END

         cc = 0;
         WHILE aa < LC_KNUTH_KK_CNT:
            mody = lv_ran_a_arr[bb] - lv_ran_x_arr[cc];
            lv_ran_x_arr[aa] = BITAND(LC_KNUTH_MAX, mody);
            aa += 1;   # [LL      ..KK)
            bb += 1;   # [nn-KK+LL..nn)
            cc += 1;   # [0       ..KK-LL)
         WHILE_END

      MODE_INTEGER_END
      RETURN bb;
   FUNC_END

   BLOCK_DEF FUNC INT lf_fill_ranz(NUL):
      BLOCK_USE lv_ranz_magic;
      BLOCK_USE lv_ranz_ind;
      BLOCK_USE lv_ranz_arr[];
      BLOCK_USE lv_ran_a_arr[];
      INT jj;

      CALL lf_ran_cycle(LC_KNUTH_QUALITY_CNT);

      FOR jj FROM 0 TO LC_KNUTH_QUALITY_CNT - 1:
         lv_ranz_arr[jj] = lv_ran_a_arr[jj];
      FOR_END
      lv_ranz_arr[LC_KNUTH_KK_CNT] = -1;
      lv_ranz_ind = 0;
      lv_ranz_magic = Kw.magicset();
      RETURN lv_ranz_arr[0];
   FUNC_END

   BLOCK_DEF FUNC INT lf_next_ranz(NUL):
      BLOCK_USE lv_ranz_magic;
      BLOCK_USE lv_ranz_ind;
      BLOCK_USE lv_ranz_arr[];

      # if not initialized: initialize; else if buffer empty: create more
      IF NOT Kw.ismagic(lv_ranz_magic):
         CALL rand_init(Kw.timee());
      ELSIF lv_ranz_arr[lv_ranz_ind] < 0:
         CALL lf_fill_ranz();
      IF_END

      lv_ranz_ind += 1;

      RETURN lv_ranz_arr[lv_ranz_ind - 1];
   FUNC_END

   FUNC DBL rand_init_array(INT seed_size
            , READONLY INT seed_arr_pc[]):
      # Initialize Random Number generator with an array of SEED_SIZE longs
      # (at most LC_KNUTH_KK_CNT are used)
      BLOCK_USE lv_ran_x_arr[];
      INT tt;
      INT jj;
      INT kk;
      INT dd;
      INT rnd_arr[2 * LC_KNUTH_KK_CNT];
      INT rndss;
      INT rndx;
      INT rndff;
      INT seed_ind;
      INT bitmask;

      MODE_INTEGER:
         rndss = BITAND((seed_arr_pc[0] + 2), (LC_KNUTH_MAX - 1));
         # rndss is now even
         FOR jj FROM 0 TO LC_KNUTH_KK_CNT - 1:
            rnd_arr[jj] = rndss;
            rndss = BITSHIFTL(rndss, 1);
            IF LC_KNUTH_MAX < rndss:
               rndss -= (LC_KNUTH_MAX - 1);
            IF_END
            # rndss is still even
         FOR_END

         rndff = 0;
         seed_ind = 0;
         bitmask = 0;
         FOR jj FROM 0 TO LC_KNUTH_KK_CNT - 1:
            IF bitmask <= 1:
               seed_ind += 1;
               IF seed_size <= seed_ind:
                  FOR_EXIT;
               IF_END
               rndff = seed_arr_pc[seed_ind];
               bitmask = BITSHIFTL(1, 30);
            IF_END
            IF BITAND(rndff, bitmask) <> 0:
               # bitmask, rnd_arr[ii] are even, hence so is xor
               rnd_arr[jj] = BITXOR(bitmask, rnd_arr[jj]);
            IF_END
            bitmask = BITSHIFTR(bitmask, 1);
         FOR_END

         # Back to Knuths code
         # All numbers in rnd_arr[] are even
         rnd_arr[1] += 1;
         # All numbers rnd_arr[] are even EXCEPT rnd_arr[1]
         rndss = BITAND(seed_arr_pc[0], LC_KNUTH_MAX);
         tt = LC_KNUTH_TT - 1;

         WHILE 0 < tt:
            FOR jj FROM LC_KNUTH_KK_CNT - 1 TO 1 BY -1:
               rnd_arr[jj + jj] = rnd_arr[jj];
               rnd_arr[jj + jj - 1] = 0;
            FOR_END

            jj = LC_KNUTH_KK_CNT + LC_KNUTH_KK_CNT - 2;
            dd = LC_KNUTH_KK_CNT + LC_KNUTH_LL - 2;
            kk = LC_KNUTH_KK_CNT - 2;
            WHILE 0 <= kk:
               rndx = rnd_arr[dd] - rnd_arr[jj];
               rnd_arr[dd] = BITAND(rndx, LC_KNUTH_MAX);
               rndx = rnd_arr[kk] - rnd_arr[jj];
               rnd_arr[kk] = BITAND(rndx, LC_KNUTH_MAX);
               dd -= 1;
               kk -= 1;
               jj -= 1;
            WHILE_END

            IF Kw.isodd(rndss):
               FOR jj FROM LC_KNUTH_KK_CNT TO 1 BY -1:
                  rnd_arr[jj] = rnd_arr[jj - 1];
               FOR_END
               rnd_arr[0] = rnd_arr[LC_KNUTH_KK_CNT];
               jj = rnd_arr[LC_KNUTH_LL] - rnd_arr[0];
               rnd_arr[LC_KNUTH_LL] = BITAND(LC_KNUTH_MAX, jj);
               rndss = BITSHIFTR(rndss, 1);
            ELSIF rndss == 0:
               tt -= 1;
            ELSE:
               rndss = BITSHIFTR(rndss, 1);
            IF_END
         WHILE_END

         kk = (LC_KNUTH_KK_CNT - LC_KNUTH_LL);
         jj = 0;
         # Before each loop: jj - kk = LC_KNUTH_LL mod LC_KNUTH_KK_CNT

         WHILE jj < LC_KNUTH_LL:
            lv_ran_x_arr[kk] = rnd_arr[jj];
            kk += 1;
            jj += 1;
         WHILE_END

         # jj == LC_KNUTH_LL; kk == LC_KNUTH_KK_CNT
         kk = 0;
         WHILE jj < LC_KNUTH_KK_CNT:
            lv_ran_x_arr[kk] = rnd_arr[jj];
            kk += 1;
            jj += 1;
         WHILE_END

         FOR jj FROM 0 TO 9:
            CALL lf_ran_cycle(2 * LC_KNUTH_KK_CNT - 1);
         FOR_END
      MODE_INTEGER_END
      CALL lf_fill_ranz();
      RETURN 0;
   FUNC_END

   FUNC DBL rand_init(DBL seed):
      # Initialize Random Number generator with a single double SEED
      INT sd_arr[2];

      sd_arr[0] = FLOOR(seed);
      sd_arr[1] = FLOOR(frac(seed) * Kw.INTMAX);

      CALL rand_init_array(2, sd_arr[]);

      RETURN seed;
   FUNC_END

   FUNC INT randl(INT nn):
      # Return a uniformly distributed integer in [0,NN)
      INT max_allowed;
      INT rndm;
      INT retvalu;

      MODE_INTEGER:
         max_allowed = LC_KNUTH_MAX - (LC_KNUTH_MAX % nn);
         # Now MAX_ALLOWED is a multiple of NN
         AWAIT rndm < max_allowed:
            rndm = lf_next_ranz();
         AWAIT_END
         retvalu = rndm % nn;
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END

   FUNC DBL randd(NUL):
      # Return a uniformly distributed number in [0.0,1.0)
      RETURN (lf_next_ranz() + lf_next_ranz() / (LC_KNUTH_MAX + 1.0))
               / (LC_KNUTH_MAX + 1.0);
   FUNC_END

BLOCK_END # Random numbers
